<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"  lang="ko-KR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>Share Memory By Communicating | Hello, There</title>



<link href="http://jaeyo.github.io/index.xml" rel="alternate" type="application/rss+xml" title="Hello, There">

<link rel="stylesheet" href="/css/style.css"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<link rel="canonical" href="http://jaeyo.github.io/share-memory-by-communicating/">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">
</head>
<body>
<section class="section">
  <div class="container">
    <nav id="nav-main" class="nav">
      <div id="nav-name" class="nav-left">
        <a id="nav-anchor" class="nav-item" href="http://jaeyo.github.io/">
          <h1 id="nav-heading" class="title is-4">Hello, There</h1>
        </a>
      </div>
      <div class="nav-right">
        <nav id="nav-items" class="nav-item level is-mobile"><a class="level-item" aria-label="github" href='https://github.com/Jaeyo'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"/>
    
  </svg></i>
            </span>
          </a><a class="level-item" aria-label="facebook" href='https://facebook.com/jaeyo.developer'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z"/>
    
  </svg></i>
            </span>
          </a><a class="level-item" aria-label="twitter" href='https://twitter.com/lastiverse'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"/>
    
  </svg></i>
            </span>
          </a><a class="level-item" aria-label="instagram" href='https://instagram.com/jaeyoyoyo'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <rect x="2" y="2" width="20" height="20" rx="5" ry="5"/>
    <path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"/>
    <line x1="17.5" y1="6.5" x2="17.5" y2="6.5"/>
    
  </svg></i>
            </span>
          </a><a class="level-item" aria-label="email" href='mailto:jaeyo.developer@gmail.com'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"/>
    <polyline points="22,6 12,13 2,6"/>
    
  </svg></i>
            </span>
          </a><a class="level-item" aria-label="about" href='/about'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12" y2="8"></line>
    
  </svg></i>
            </span>
          </a></nav>
      </div>
    </nav>

    <nav class="nav">
      

      
    </nav>

  </div>
  <script src="/js/navicon-shift.js"></script>
</section>
<section class="section">
  <div class="container">
    <div class="subtitle tags is-6 is-pulled-right">
      
      
<a class="subtitle is-6" href="/tags/tech/">#tech</a>




      
    </div>
    <h2 class="subtitle is-6">October 9, 2020</h2>
    <h1 class="title">Share Memory By Communicating</h1>
    
    <div class="content">
      <p>Go 언어는 동시성 프로그래밍에 매우 특화된 언어다. 이러한 특징은 Go 언어가 탄생하게 된 유래에서도 관련이 있다. 지금은 매우 당연하게 사용되고 있는 멀티 코어 프로세서가 상용으로 세상에 나온지는 사실 생각보다 그리 오래되지 않았다. 2005 년에서 2006 년 사이에 인텔에서 상용 듀얼 코어 프로세서를 출시했다. 그리고 바로 2007년, Google 에서는 이러한 멀티 코어의 이점을 언어에서 native 레벨로 챙길 수 있는 언어로 Go 언어를 개발하기 시작하였다.</p>
<p>실제로 Go 언어로 멀티스레딩 코드를 만들어보면 이를 체감할 수 있다. 다른 프로그래밍 언어에 비해서 비교적 쉽게 동시성을 다룰 수 있도록 지원하고 있다. Java 의 경우처럼 <code>Runnable</code> 인터페이스를 구현하거나 <code>Thread</code> 를 상속받아서 <code>run</code> 메소드를 작성할 필요없이, 별도의 스레드로 실행할 함수 앞에 <code>go</code> 라는 키워드만 붙여주면 된다.</p>
<p>이러한 문법적 편리성은 여기서 그치지 않는다. 각 스레드들끼리의 데이터 공유 수단으로 <code>channel</code> 이라는 빌트인 타입을 만들어 제공하고 있다. <code>channel</code> 은 <code>queue</code> 와 그 쓰임새가 매우 유사하다. <code>enqueue</code> / <code>dequeue</code> 기능이 있고 선입선출의 순서를 가진다. 그럼 Go 언에서 이 <code>channel</code> 이란 타입을 빌트인으로 만들어서 제공한 이유는 뭘까? 그냥 표준 패키지에서 구현해도 되는 자료구조를 왜 언어의 native 기능으로 추가했을까?</p>
<p>Go 언어에서 <code>channel</code> 개념을 학습하다보면 꼭 접하게 되는 문장이 있다.</p>
<p><code>Do not communicate by sharing memory; instead, share memory by communicating</code></p>
<p>언뜻보면 금방 이해가 안가는 문장이다. 하지만 이해하고 나면 Go 언어에서 동시성 문제를 얼마나 중요하게 다뤘는지에 대해 알 수 있다.</p>
<p>간단한 샘플 코드를 짜보자.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">counter</span> = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">100</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">increaseCounter</span>()
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">counter</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">increaseCounter</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">counter</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>간단한 내용의 코드다. <code>counter</code> 변수를 증가시키는 로직을 수행하는 <code>increaseConter</code> 라는 함수가 있고 메인 스레드에서는 이 함수를 각각 별도의 스레드로 100번 실행시킨 후에 <code>counter</code> 변수의 값을 실행한다. 직관적으로는 당연히 <code>counter</code> 의 값이 100이 될 것 같지만 사실 그렇지 않다. 내 맥북을 기준으로 결과값은 80 후반대에서 90 초반대의 값이 출력된다. 하지만 만약 이 코드를 싱글코어 머신에서 실행하면 값은 의도한 대로 100이 나올 것이다.</p>
<p>이렇게 되는 이유는, <code>counter</code> 라는 공유 자원을 각각의 스레드에서 동시에 접근하게 되기 때문이다. 듀얼 코어 이상의 머신에서는 <code>counter</code> 를 증가시키는 코드가 동시에 여러 스레드에서 실행되는 케이스가 발생하고, 이 때문에 <code>counter</code> 의 값이 오롯이 100 이 안되는 것이다.</p>
<p>멀티스레드 프로그래밍을 하면서 가장 많이 하게 되는 실수 중 하나다. 각 스레드들간 공유하고 있는 자원을 적절하게 핸들링하지 못하게 되는 케이스다. 이런 문제를 해결하는 가장 간단한 방법은 Lock 을 이용하는 것이다. 공유자원에 접근하기 전에 먼저 lock 을 걸고 자원 사용이 끝나면 다시 unlock 을 호출하는 것이다. Go 언어에서도 Mutex 라는 구조체를 통해 이러한 lock 을 이용한 접근을 지원하고 있기는 하다.</p>
<p>사실 이러한 방법은 Go 언어에서 지양해야 하는 접근 중 하나이다. 위의 문장에서도 <code>Do not communicate by sharing memory</code> 라고 이야기하고 있다. 본 예제 코드에서는 <code>counter</code> 라는 메모리 상의 자원을 스레드들간에 공유한 것이기 때문이다.</p>
<p>이제 <code>channel</code> 을 이용해서 다시 짜보자.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">receiver</span>(<span style="color:#a6e22e">ch</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">sender</span>(<span style="color:#a6e22e">ch</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">receiver</span>(<span style="color:#a6e22e">ch</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">counter</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">ch</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">counter</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">value</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">counter</span>)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sender</span>(<span style="color:#a6e22e">ch</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">100</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>이 코드는 두 개의 스레드에서 실행된다. 하나는 <code>receiver</code> 함수를 실행시키면서 <code>channel</code> 을 통해 들어오는 데이터를 계속해서 받아서 <code>counter</code> 지역변수에 계속 더하고 있고, 다른 하나는 메인 스레드로 실행되면서 <code>sender</code> 함수를 실행시켜 1이라는 데이터를 계속해서 <code>channel</code> 을 통해서 보내고 있다.</p>
<p>이 코드에서 각 스레드들은 오직 <code>channel</code> 만을 공유하도록 했다. 앞의 코드처럼 별도의 공유자원을 가지지 않도록 말이다. 이렇게 되면 별도의 lock 을 이용한 접근이 필요없게 된다. <code>channel</code> 을 통해 communicating 함으로써 데이터를 공유하도록 한 셈이다.</p>
<p>멀티스레드 프로그래밍는 사실 생각보다 까다롭고 신경써야 하는 부분들이 많다. 제일 문제가 많이 발생하는 경우들이 이러한 공유자원을 잘못 핸들링해서 생기는 경우다. 공유 자원 문제를 방지하려고 lock 를 사용하면 코드는 복잡해지고 가독성을 잃으면서 다시 다른 문제를 유발하기 십상이다. 또한 매번 lock 을 걸고 빼고 하면서 성능 문제가 생기기도 쉽다.</p>
<p>이러한 문제를 애초부터 방지하기 위해 Go 언어에서는 goroutine 생성과 channel 이라는 타입을 빌트인으로 넣어가면서 까지 동시성 프로그래밍에서의 베스트 프랙티스를 가이드해주고 있는 셈이다.</p>
<hr>

      
      <div class="related">

<h3>Similar articles:</h3>
<ul>
	
	<li><a href="/look-back-on-8-years-3/">8년 간의 개발자 생활 회고 (3)</a></li>
	
	<li><a href="/look-back-on-8-years-2/">8년 간의 개발자 생활 회고 (2)</a></li>
	
	<li><a href="/look-back-on-8-years-1/">8년 간의 개발자 생활 회고 (1)</a></li>
	
	<li><a href="/contribute-code-into-telegraf/">오픈소스 프로젝트에 코드 기여한 이야기</a></li>
	
	<li><a href="/git-delete-branch-and-push/">Git - branch 삭제 후 push</a></li>
	
</ul>
</div>
      
    </div>
    
    
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-format="fluid"
     data-ad-layout="in-article"
     data-ad-client="ca-pub-5009679768762757"
     data-ad-slot="6857547199"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

    
  </div>
</section>


<section class="section">
  <div class="container">
    <aside><div id="disqus_thread"></div></aside>
  
    <script type="text/javascript">
      var disqus_shortname = 'jaeyo-blog';
      function disqus() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }
  
      disqus();
  

    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
  </div>
</section>


<section class="section">
  <div class="container has-text-centered">
    <p></p>
    
  </div>
</section>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-142557602-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>






</body>
</html>

