<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Hello, there]]></title><description><![CDATA[A starter blog demonstrating what Gatsby can do.]]></description><link>https://jaeyo.github.io</link><generator>RSS for Node</generator><lastBuildDate>Wed, 07 Aug 2019 15:23:30 GMT</lastBuildDate><item><title><![CDATA[qmk_firmware 빌드 시에 chibios 관련 에러 발생]]></title><description><![CDATA[는 programmable한 여러 키보드들을 지원하는 오픈소스 펌웨어다. 이 펌웨어가 지원하는 대표적인 키보드는 planck, ergodox 등이 있다.
documentation 및 자세한 정보는 https://qmk.fm…]]></description><link>https://jaeyo.github.io/error-while-building-qmk_firmware/</link><guid isPermaLink="false">https://jaeyo.github.io/error-while-building-qmk_firmware/</guid><pubDate>Tue, 16 Oct 2018 10:34:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;qmk_firmware&lt;/code&gt;는 programmable한 여러 키보드들을 지원하는 오픈소스 펌웨어다. 이 펌웨어가 지원하는 대표적인 키보드는 planck, ergodox 등이 있다.
documentation 및 자세한 정보는 &lt;a href=&quot;https://qmk.fm/&quot;&gt;https://qmk.fm/&lt;/a&gt; 에서 확인할 수 있다.
처음 이 소스를 clone 받아서 빌드를 하기 위해서 documentation을 보면 아래와 같이 가이드를 해준다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;$ make &amp;lt;my_keyboard&amp;gt;:&amp;lt;my_keymap&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;하지만 그대로 따라치면 아래와 같은 에러를 볼 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;$ make ergodo_infinity:default

tmk_core/chibios.mk:38: lib/chibios-contrib/os/common/startup/ARMCMx/compilers/GCC/mk/startup_k20x7.mk: No such file or directory
tmk_core/chibios.mk:40: lib/chibios/os/hal/hal.mk: No such file or directory
tmk_core/chibios.mk:46: lib/chibios-contrib/os/hal/ports/KINETIS/K20x/platform.mk: No such file or directory
tmk_core/chibios.mk:78: lib/chibios-contrib/os/hal/boards/PJRC_TEENSY_3_1/board.mk: No such file or directory
tmk_core/chibios.mk:79: lib/chibios/os/hal/osal/rt/osal.mk: No such file or directory
tmk_core/chibios.mk:81: lib/chibios/os/rt/rt.mk: No such file or directory
tmk_core/chibios.mk:87: lib/chibios/os/common/ports/ARMCMx/compilers/GCC/mk/port_v7m.mk: No such file or directory
tmk_core/chibios.mk:89: lib/chibios/os/hal/lib/streams/streams.mk: No such file or directory
quantum/visualizer/visualizer.mk:77: lib/ugfx/gfx.mk: No such file or directory
make[1]: *** No rule to make target `lib/ugfx/gfx.mk&amp;#39;.  Stop.
make: *** [ergodox_infinity:default] Error 1&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이는 submodule이 적절히 업데이트 되지 않아 발생하는 문제다.
따라서 아래의 명령어로 submodule을 업데이트 시켜주면 정상적으로 다시 빌드를 할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;$ make git-submodule&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;혹은 아래의 두 명령어도 같은 역할을 한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;$ git submodule sync --recursive
$ git submodule update --init --recursive --progress&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[reselect]]></title><description><![CDATA[https://github.com/reactjs/reselect reselect는 redux에 붙여서 쓸 수 있는 selector 라이브러리로 역할은 아래의 두 가지로 정리된다. 컴포넌트를 redux에 connect 시킬 때 store…]]></description><link>https://jaeyo.github.io/reselect/</link><guid isPermaLink="false">https://jaeyo.github.io/reselect/</guid><pubDate>Sat, 06 Oct 2018 11:44:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;reselect&quot;&gt;https://github.com/reactjs/reselect&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;reselect는 redux에 붙여서 쓸 수 있는 selector 라이브러리로 역할은 아래의 두 가지로 정리된다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;컴포넌트를 redux에 connect 시킬 때 store로부터 데이터를 꺼내와서 매핑시키는 부분 추상화&lt;/li&gt;
&lt;li&gt;selector 함수에서 반환되는 값을 캐싱하여 성능 향상&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;가령 아래와 같은 코드가 있다고 가정하면,&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;mapStateToProps&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;state&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; ownProps&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; contentIds &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; state&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;userContent&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
		contentIds&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;reselect를 붙여 아래와 같은 형태로 정리할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// selector&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;getUserContent&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; state&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;userContent&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; selectUserContentIds &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;createSelector&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt; getUserContent &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// input selector&lt;/span&gt;
	&lt;span class=&quot;token parameter&quot;&gt;userContent&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; userContent&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;contentIds
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;//component&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;mapStateToProps&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;state&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; ownProps&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	contentIds&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;selectUserContentIds&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;state&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이러한 형태에서 먼저 눈에 띄는 장점은 컴포넌트 단에서 redux store의 구조를 알 필요없이 selector 만 호출할 수 있다는 점이다.
이외에도 reselect는 memoized selector 를 통해서 성능 향상을 꾀할 수 있다.&lt;/p&gt;
&lt;p&gt;여기서 주의할 점은, 만약 리스트 형태의 컴포넌트에서 selector를 사용할 경우 각 리스트 아이템마다 필요로 하는 데이터가 다르게 되기 떄문에 정상적으로 memoized 되지 않는다는 점이다. 이 경우에는 selector를 생성하는 로직을 함수로 한번 래핑하여 각 리스트 아이템들마다 다른 selector를 사용하도록 해야 한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// selector&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;getUserContent&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; state&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;favoriteContent&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;selectTitleByContentId&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;state&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; contentId&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;createSelector&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt; getUserContent &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;token parameter&quot;&gt;userContent&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; userContent&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;titles&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;contentId&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;state&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// list item component&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;mapStateToProps&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;state&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; ownProps&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	title&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;selectTitleByContentId&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;state&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; ownProps&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;contentId&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;reselect의 또다른 특징으로는 composable 하다는 점이다.
아래의 경우처럼 미리 만들어놓은 selector가 다른 selector의 input selector가 될 수 있어 selector들을 조합하는 것이 가능하다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// selector&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;getUserContent&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; state&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;userContent&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;getEntities&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; state&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;entities&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; selectUserContentIds &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;createSelector&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt; getUserContent &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// input selector&lt;/span&gt;
	&lt;span class=&quot;token parameter&quot;&gt;userContent&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; userContent&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;contentIds
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; selectUserContents &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;createSelector&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt; selectUserContentIds&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; getEntities &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;userContentIds&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; entities&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; userContentIds&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;contentId&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; entities&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;contents&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;contentId&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;data&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;//component&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;mapStateToProps&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;state&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; ownProps&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	contents&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;selectUserContents&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;state&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[AWS API, IP 기반으로 접근 제한하기]]></title><description><![CDATA[EC2 상의 인스턴스나 로드밸런서에 특정 IP 대역만 접근 가능하도록 설정하고 싶다면 Security Group 혹은 ACL을 이용하면 된다. 하지만 그 외의 AWS에서 제공하는 API 들에 대해서 IP 기반으로 접근제한을 걸고 싶다면 Security…]]></description><link>https://jaeyo.github.io/aws-api-ip-based-access-control/</link><guid isPermaLink="false">https://jaeyo.github.io/aws-api-ip-based-access-control/</guid><pubDate>Tue, 30 Jan 2018 17:19:00 GMT</pubDate><content:encoded>&lt;p&gt;EC2 상의 인스턴스나 로드밸런서에 특정 IP 대역만 접근 가능하도록 설정하고 싶다면 Security Group 혹은 ACL을 이용하면 된다. 하지만 그 외의 AWS에서 제공하는 API 들에 대해서 IP 기반으로 접근제한을 걸고 싶다면 Security Group, ACL 로는 불가능하다. 이 부분은 IAM의 Policy로 해결을 봐야 한다.&lt;/p&gt;
&lt;p&gt;예를 들어, AWS System Manager의 Parameter Store에 접근해서 데이터를 읽어오는 API를 IP 기반으로 제한하고 싶다고 가정하자.
그럼 일단 Parameter Store에 대한 기본 Policy 부터 확인해보자.
“AWS IAM -&gt; 정책” 로 들어가서 찾아볼 수 있다.&lt;/p&gt;
&lt;p&gt;확인해본 결과 &lt;code class=&quot;language-text&quot;&gt;AmazonSSMReadOnlyAccess&lt;/code&gt; 라는 정책이 있다. 정책 상세값은 아래와 같다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;json&quot;&gt;&lt;pre class=&quot;language-json&quot;&gt;&lt;code class=&quot;language-json&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;Version&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;2012-10-17&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;Statement&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token property&quot;&gt;&quot;Effect&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Allow&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;token property&quot;&gt;&quot;Action&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
                &lt;span class=&quot;token string&quot;&gt;&quot;ssm:Describe*&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;token string&quot;&gt;&quot;ssm:Get*&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;token string&quot;&gt;&quot;ssm:List*&quot;&lt;/span&gt;
            &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;token property&quot;&gt;&quot;Resource&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;*&quot;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;우리는 여기서 IP 기반 조건만 넣어주면 된다.
일단 기본 정책 &lt;code class=&quot;language-text&quot;&gt;AmazonSSMReadOnlyAccess&lt;/code&gt;의 상세 JSON 값을 복사한 후에 새로운 정책을 생성해보자.&lt;/p&gt;
&lt;p&gt;“AWS IAM -&gt; 정책 -&gt; 정책 생성”으로 들어가면 정책을 생성하기 위한 도구로써 시각적 편집기와 JSON 입력창이 제공되는데 JSON 입력창을 이용하여 다음의 내용을 입력한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;json&quot;&gt;&lt;pre class=&quot;language-json&quot;&gt;&lt;code class=&quot;language-json&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;Version&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;2012-10-17&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;Statement&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token property&quot;&gt;&quot;Effect&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Allow&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;token property&quot;&gt;&quot;Action&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
                &lt;span class=&quot;token string&quot;&gt;&quot;ssm:Describe*&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;token string&quot;&gt;&quot;ssm:Get*&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;token string&quot;&gt;&quot;ssm:List*&quot;&lt;/span&gt;
            &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;token property&quot;&gt;&quot;Resource&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;*&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;token property&quot;&gt;&quot;Condition&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;token property&quot;&gt;&quot;IpAddress&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;token property&quot;&gt;&quot;aws:SourceIp&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
                        &lt;span class=&quot;token string&quot;&gt;&quot;{IP_ADDRESS_TO_ALLOW}&quot;&lt;/span&gt;
                    &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
                &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;처음봤던 기본 조건에 비교하여 달라진 점은 “Condition” 부분이 추가되었다는 것이다. &lt;code class=&quot;language-text&quot;&gt;{IP_ADDRESS_TO_ALLOW}&lt;/code&gt; 부분을 적절하게 Allow 할 IP로 대체하면 된다.
단, aws api를 요청하는 경우에는 대부분의 경우 source ip가 외부 ip로 찍히게 되므로 사설 ip 대역은 설정해놓으면 안된다.&lt;/p&gt;
&lt;p&gt;이런식으로 정책을 설정한 뒤에 특정 계정에게 적용해놓으면 해당 계정을 통해서는 기 설정해놓은 IP 대역대에서만 접근할 수 있다. &lt;/p&gt;
&lt;p&gt;본문에는 “Allow” 기반으로 했는데 “Allow” 대신 “Deny”로 바꾸고 “IpAddress”를 “NotIpAddress”로 바꿔도 동일하게 동작 할 것이다.&lt;/p&gt;
&lt;p&gt;IAM 정책상에서 동일 리소스 및 동작에 대해 Allow와 Deny가 같이 존재한다면 Deny가 우선순위를 가진다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[조중균의 세계를 읽었다.]]></title><description><![CDATA[…]]></description><link>https://jaeyo.github.io/shame/</link><guid isPermaLink="false">https://jaeyo.github.io/shame/</guid><pubDate>Tue, 21 Nov 2017 13:31:00 GMT</pubDate><content:encoded>&lt;p&gt;그는 “지나간 세계” 라는 시를 쓰고 또 동명의 술집에서 형수라는 친구와 함께 산다.
대학생 무렵에는 운동권에 몸담았다. 운동권 학생들이 마음에 안들었던 한 교수는 역사 시험에서 시험지에 이름만 쓰면 점수를 주겠다고 했다. 다른 친구들은 아무렇지 않게 그 시험을 받아들일 때 그는 부끄러움을 생각했다. “아무것도 하지 않음으로써 이득을 취하는 일”에 그는 동조하지 않고 시험지에는 이름과 함께 시를 썼다.
이후 회사에 다니면서도 점심을 안먹고 점심 식대를 월급에서 제하지 않는 그에게 누군가 “몰래 점심을 먹을 수도 있지 않냐”라는 의심을 하자 그는 다시 부끄럽지 않기 위해서 매일 점심을 먹지 않았다는 확인 서명을 받았다. 일정대로 일이 진행되지 않자 상사는 그가 나태하게 일한다는 의심을 했고 그는 다시 그 의심 앞에서 부끄럽지 않기 위해서 매 시간 조카뻘되는 동료에게 찾아가 나태하게 일하지 않았다는 확인 서명을 받았다.
왼손 약지가 두 마디 정도 없던 그의 삶은 무엇을 가지고 있는지보다 무엇을 가지고 있지 못한지를 찾는 것이 편했다. 부끄럽지 않기 위한 대가였다.&lt;/p&gt;
&lt;p&gt;신념 이라는 단어를 내뱉으면 어쩐지 고리타분한 냄새가 난다. 돈이 신념이 되버린 시대다. 내게 이득이 되도록 우리는 무수히도 부끄러운 순간들을 눈감아왔다. 신념 같은 것들은 국어사전 속에나 존재했고, 이득을 위해 어느 선까지 부끄러울 수 있는가를 저울질하는 정도의 차이만 있을 뿐이지 우리는 전부 부끄러움 앞에서 발가벗은 것처럼 무력하다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[리디스토리 프론트엔드 개발기]]></title><description><![CDATA[본 포스팅은 회사 블로그에 올려놓았던 글을 옮겨놓은 것입니다. 몬타나 존스 라는 만화영화가 있었습니다. 199…]]></description><link>https://jaeyo.github.io/how-to-develop-ridistory-frontend/</link><guid isPermaLink="false">https://jaeyo.github.io/how-to-develop-ridistory-frontend/</guid><pubDate>Sun, 08 Oct 2017 14:57:00 GMT</pubDate><content:encoded>&lt;p&gt;본 포스팅은 &lt;a href=&quot;https://www.ridicorp.com/blog/2017/09/13/how-to-develop-ridistory-front/&quot;&gt;회사 블로그에 올려놓았던 글&lt;/a&gt;을 옮겨놓은 것입니다.&lt;/p&gt;
&lt;br /&gt;
&lt;hr&gt;
&lt;br /&gt;
&lt;p&gt;몬타나 존스 라는 만화영화가 있었습니다. 1990년대 중반쯤에 방영되었던 것으로 기억이 나네요. 에피소드마다 의인화된 사자와 호랑이가 유적지를 탐험하다 제로경으로 대표되는 악의 무리와 부딪힙니다. 제로경은 니트로 박사라는 부하가 만들어준 로봇을 타고 주인공의 앞길을 막고, 쫓고 쫓기는 아슬아슬한 활극 끝에 결국 정의의 편인 주인공이 승리하곤 합니다. 여기서 제로경과 니트로 박사가 주고받는 대화가 일품입니다. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;제로경: 니트로 박사, 사정을 설명해보실까? &lt;br /&gt;
니트로 박사: 지금이라도 시간과 예산을 조금만 더 주신다면… &lt;br /&gt;
제로경: &lt;strong&gt;변명은 죄악이란 걸 모르나!&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;오래된 기억 상자 속에서 몬타나 존스라는 만화영화 이야기를 꺼낸 이유는 신규 서비스를 개발하는 입장에서 니트로 박사에게 어쩐지 묘하게 공감했기 때문입니다. 스타트업에서 개발을 하는 많은 개발자분들도 공감할 수 있는 이야기라는 생각이 듭니다. &lt;/p&gt;
&lt;p&gt;우리에게 시간이 좀 더 있다면! 예산이 더 있다면! 인력이 더 있다면! &lt;/p&gt;
&lt;br&gt;
&lt;h2&gt;가장 큰 문제는 시간&lt;/h2&gt;
&lt;p&gt;아, 시간! 콘텐츠 플랫폼의 비즈니스 가치는 유료 회원수와 콘텐츠의 질에 따라 결정됩니다. 그렇기 때문에 초기 시장을 선점하는 일은 굉장히 중요합니다. 이미 사용자는 기존 플랫폼이 제공하는 UX에 익숙해져 있습니다. 특별한 이유가 없다면 다른 제품을 사용하지 않습니다. 또한 콘텐츠 제공자는 시장에 영향력을 가진 플랫폼을 선호하기 때문에, 신생 플랫폼 입장에서 콘텐츠를 확보하려면 많은 노력이 필요합니다.&lt;/p&gt;
&lt;p&gt;하지만 리디스토리 개발이 시작될 당시 이미 굳건한 위치를 잡고 있는 플랫폼들이 많이 있었습니다. 따라서 리디스토리는 골리앗에게 도전하는 다윗의 심정으로 조금이라도 더 누구보다 빠르게 남들과는 다르게 출시해야 했습니다.&lt;/p&gt;
&lt;p&gt;이러한 사정은 비단 리디스토리 만의 이야기는 아닙니다. 많은 스타트업들이 빠르게 시장에 진입하기 위해 기반기술 같은 부분들은 가능하면 매니지드 서비스를 이용하고 생산성이 좋은 언어와 프레임워크를 이용하는 것이 요즘 트렌드인 것 같습니다.&lt;/p&gt;
&lt;br&gt;
&lt;h2&gt;웹앱, 그리고 더 빠르게&lt;/h2&gt;
&lt;p&gt;그래서 웹앱이었습니다. 서비스 론칭까지 4개월, 선택지는 그리 많지 않았습니다. 사실 개발 초기에는 서버 개발자 2명밖에 없었습니다. 팀 내에 네이티브 앱 개발 경험을 가진 개발자가 있더라도 빠른 서비스 론칭을 위해서는 결국 웹앱 쪽으로 방향을 잡을 수밖에 없었습니다. 동일한 서비스를 구현하는 코드를 Android, iOS 각각의 플랫폼별로 두 벌을 만들어 유지하고 각각의 코드에서 발생할 이슈들까지 잡아나가기엔 시간과 인력의 효율 면에서 좋지 못했습니다.&lt;/p&gt;
&lt;p&gt;방향이 웹앱으로 정해지고 나서부터 리디스토리 개발팀은 익숙하고 빠르게 결과물을 낼 수 있는 방식으로 작업을 하기 시작했습니다. 서비스에 필요한 UI를 HTML로 구성하고 그 안에서 동적으로 변경되는 부분들은 &lt;a href=&quot;https://www.djangoproject.com/&quot;&gt;Django&lt;/a&gt;에서 지원하는 &lt;a href=&quot;http://jinja.pocoo.org/&quot;&gt;Jinja2&lt;/a&gt;라는 템플릿을 통해서 구성하는 전통적인(?) 방식이었습니다. 그렇게 서비스의 얼개가 대강 잡혔을 때쯤 우리는 그동안 우리 안에서 가지고 있던 불안에 대해 꺼내놓고 이야기하기 시작했습니다. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;이거 너무 느린데요?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;네, 너무 느렸습니다. 느릴 수밖에 없었습니다. 스마트폰에 앱이라는 형태로 인스톨된 이상 사용자는 여타 다른 네이티브 애플리케이션과 비슷한 반응성을 기대하며 리디스토리 앱을 이용하게 됩니다. 하지만 리디스토리 앱의 내부는 웹과 동일한 형태로 구현이 되었으니 사용자 입장에서는 어딘가 모르게 굼뜨다는 인상을 받게 됩니다. 매 화면 이동마다 흰 화면이 순간적으로 노출되고 인터랙션도 어딘가 모르게 답답합니다. &lt;/p&gt;
&lt;p&gt;개발팀은 하던 일을 모두 중지하고 회의실에 모여 머리를 맞대고 대책을 강구하기 시작했습니다. 길고 긴 회의 끝에 기존의 방법을 버리고 Single Page Application(이하  SPA)으로 전면 개편이라는 선택지로 겁도 없이 손을 뻗었습니다. SPA 개발을 도와줄 도구로서 &lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;React&lt;/a&gt;와 &lt;code class=&quot;language-text&quot;&gt;Angular&lt;/code&gt;를 비교했고, 학습곡선이 낮고 좀 더 자유로운 방식으로 사용 가능한 &lt;code class=&quot;language-text&quot;&gt;React&lt;/code&gt;에 &lt;code class=&quot;language-text&quot;&gt;React-router&lt;/code&gt;를 곁들여 사용하기로 했습니다. 그때부터 이른바 고난의 행군이 시작되었습니다. &lt;/p&gt;
&lt;p&gt;개발팀 태스크보드에는 서비스 화면의 이름이 쓰인 태스크들이 무더기로 등장했습니다. 개발자들은 그 태스크들을 하나씩 가져와 기존에 Jinja2 템플릿으로 되어 있던 화면을 &lt;code class=&quot;language-text&quot;&gt;React&lt;/code&gt; 기반으로 옮기기 시작했습니다. 단순 포팅을 넘어서 화면의 각 구성요소를 적절하게 컴포넌트화하여 재사용성을 높이고, 각 화면들의 시나리오들을 &lt;code class=&quot;language-text&quot;&gt;React&lt;/code&gt; 라이프사이클에 적절하게 녹여내야 했습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.ridicorp.com/blog/img/2017-09-13/code_deleted_added.png&quot; alt=&quot;git commit graph&quot;&gt;&lt;/p&gt;
&lt;figcaption&gt;어마어마한 양의 코드들이 삭제되고 또 추가되었습니다. &lt;/figcaption&gt;
&lt;br&gt;
&lt;h2&gt;그냥 Redux 쓸 걸&lt;/h2&gt;
&lt;p&gt;우리가 겪은 기술적인 문제들은 대부분 &lt;strong&gt;웹이면서 웹이 아닌 척해야 하는 웹앱&lt;/strong&gt;의 숙명으로부터 비롯된 것이었습니다. 순조롭게 진행되는가 싶던 SPA로의 전환 작업의 첫 번째 고난은 댓글 화면에서 시작되었습니다. 사용자는 댓글 목록 화면에서 새로운 댓글을 쓰기 위해 댓글 작성 화면으로 이동하게 됩니다. 새로운 댓글을 성공적으로 올리고 댓글 목록 화면으로 돌아왔을 때, 사용자는 자신이 방금 작성한 댓글이 댓글 목록에 없는 것을 발견하게 됩니다. 댓글 목록에 있는 댓글은 새로운 댓글을 적기 전에 받아온 데이터니까요. 그리고 이는 용납하기 어려운 사용자 경험입니다.&lt;/p&gt;
&lt;p&gt;이 문제를 해결하기 위해 우리는 클라이언트에서 상태와 데이터를 저장하고 관리하는 코드들을 추가하기 시작했습니다. 서버로부터 받아온 댓글 목록 데이터를 변수에 저장하고 사용자가 새로운 댓글을 작성하면 서버로 전송됨과 동시에 그 변수에도 추가하게 됩니다. 이제 댓글 목록 화면으로 돌아오더라도 이 저장소에 있는 데이터를 기반으로 화면을 그리기 때문에 방금 작성한 댓글도 댓글 목록에 볼 수 있습니다. 댓글 외에도 클라이언트에서 유지해야 하는 데이터의 종류들은 상당히 많았습니다. 예를 들어, 로그인된 사용자의 정보는 많은 화면에서 공통으로 사용하기 때문에 매번 서버에서 받아오는 것은 비효율적이었습니다. &lt;/p&gt;
&lt;p&gt;게다가 문제는 또 있었습니다. &lt;code class=&quot;language-text&quot;&gt;React&lt;/code&gt;로 코딩하다 보면 화면의 구성요소들을 컴포넌트 단위로 잘게 나누고 그 컴포넌트들을 조합하는 방식을 사용하게 됩니다. 따라서 화면이 복잡한 경우에는 A 컴포넌트가 B 컴포넌트를 포함하고, B 컴포넌트는 또 다른 C 컴포넌트를 포함하는 식으로 depth가 깊어지기에 십상인데요, 이때 A 컴포넌트에서 가지고 있는 데이터를 C 컴포넌트까지 내려주려면 B 컴포넌트를 통해서 props라는 형태로 내려주어야 합니다. depth가 깊어질수록 문제가 커지죠. 개발팀은 다시 회의실에 모여 이야기합니다. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;그냥 Redux 쓸 걸 그랬네요.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;네, 사실 &lt;code class=&quot;language-text&quot;&gt;React&lt;/code&gt; 도입 단계에서 &lt;code class=&quot;language-text&quot;&gt;Redux&lt;/code&gt;까지 고려했으나 당시 필요 이상의 엔지니어링이라는 판단이 들어 배제했었고 나중에야 그것이 잘못된 판단이라는 것을 깨달았습니다. 클라이언트에서 상태를 유지하는 문제, 컴포넌트 depth를 따라서 데이터를 내려줘야 하는 문제 모두 &lt;code class=&quot;language-text&quot;&gt;Redux&lt;/code&gt;를 도입함으로써 깔끔하게 해결할 수 있는 문제였습니다. 잠깐 후회했지만 빠르게 &lt;code class=&quot;language-text&quot;&gt;Redux&lt;/code&gt;를 서비스에 적용했습니다. 더불어 &lt;code class=&quot;language-text&quot;&gt;Redux-thunk&lt;/code&gt; 라던가 &lt;code class=&quot;language-text&quot;&gt;Reselect&lt;/code&gt; 같은 &lt;code class=&quot;language-text&quot;&gt;Redux&lt;/code&gt;와 함께 묶어서 사용할 수 있는 라이브러리들까지 도입하면서 프론트엔드 코드를 좀 더 깔끔하게 작성할 수 있었습니다. &lt;/p&gt;
&lt;br&gt;
&lt;h2&gt;Entity의 등장&lt;/h2&gt;
&lt;p&gt;앞서 언급한 사용자 정보에 대한 데이터 외에도 여러 화면에서 공통으로 사용되는 데이터는 또 있었습니다. 바로 작품에 대한 메타데이터였습니다. 작품의 Primary Key(이하 pk)와 제목, 저자 정보 등으로 구성된 이 데이터는 여러 화면에서 공통으로 사용되고 있었고 매화면 이동 시마다 중복해서 서버에서 내려주고 있었습니다. 예를 들면 아래와 같은 시나리오입니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;럭키박스 발급 화면에서 작품 이용권 당첨&lt;br /&gt;
→ 작품의 제목을 표시하기 위해 작품 메타데이터를 서버에서 전달&lt;/li&gt;
&lt;li&gt;해당 작품을 터치해 작품 상세 화면으로 이동&lt;br /&gt;
→ 작품의 상세 정보들을 표시하기 위해 작품 메타데이터를 &lt;strong&gt;또&lt;/strong&gt; 서버에서 전달 &lt;/li&gt;
&lt;li&gt;해당 작품을 읽기 위해 뷰어 화면으로 이동&lt;br /&gt;
→ 작품의 제목을 표시하기 위해 작품 메타데이터를 &lt;strong&gt;또다시&lt;/strong&gt; 서버에서 전달 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;클라이언트에서 데이터가 중복으로 저장되어 메모리 사용량이 늘어나는 것은 차치하더라도 전송 시마다 트래픽을 과하게 소비하면서 화면 로딩을 늦추는 것을 우리는 용서할 수 없었습니다.
이 적폐를 청산하기 위해서 작품 메타데이터를 조금 특별하게 취급하기로 했습니다. &lt;code class=&quot;language-text&quot;&gt;Redux&lt;/code&gt; store에 &lt;code class=&quot;language-text&quot;&gt;Entity&lt;/code&gt; 라는 개념을 만들고 메타데이터들을 저장하고 관리하기로 했습니다.&lt;/p&gt;
&lt;p&gt;기존에 메타데이터를 내려주던 API들에서는 메타데이터에 대한 pk만을 내려줍니다.
클라이언트에서는 이 pk를 이용해 가지고 있지 않은 pk들만 별도의 메타데이터 API에 요청하도록 하였습니다.
이렇게 받아온 메타데이터는 &lt;code class=&quot;language-text&quot;&gt;Entity&lt;/code&gt;에서 관리하면서 다른 화면에서 재사용할 수 있도록 했고요. &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.ridicorp.com/blog/img/2017-09-13/entity.png&quot; alt=&quot;Entity 설명 이미지&quot;&gt;&lt;/p&gt;
&lt;figcaption&gt;Entity는 이렇게 동작합니다.&lt;/figcaption&gt;
&lt;p&gt;이렇게 구조를 변경하고 나니 각 API의 응답 데이터 사이즈가 눈에 띄게 줄었고 결과적으로 좀 더 빠르게 화면을 그려줄 수 있게 되었습니다. 어쩌면 수십 ms 정도의 차이겠지만 티끌 모아 태산이니까요. &lt;/p&gt;
&lt;br&gt;
&lt;h2&gt;웹 같은 앱, 앱 같은 웹 그리고 앞으로는?&lt;/h2&gt;
&lt;p&gt;리디스토리는 웹앱으로 개발되었습니다. 웹앱으로 하면 하나의 코드로 모든 플랫폼에 대응할 수 있으며, 개발 편의성도 높습니다. 또한, 버그 수정 및 기능추가를 빠르게 실 서비스에 적용할 수 있습니다. &lt;/p&gt;
&lt;p&gt;하지만 그에 따른 단점들도 있습니다. 네이티브에 비해 속도도 느리고 사용성도 좋지 않습니다.
개발팀은 네이티브앱 처럼 보이기 위해 많은 노력을 했습니다. 특히 성능 개선 측면에서 많은 시도를 했습니다. 여러 화면에서 데이터를 최신으로 유지하기 위해 &lt;code class=&quot;language-text&quot;&gt;Redux&lt;/code&gt;를 도입한다던가, &lt;code class=&quot;language-text&quot;&gt;Entity&lt;/code&gt;라는 개념을 만들어 중복 데이터 및 서버 응답의 용량을 줄이는 것도 이런 노력의 일환이었죠. 저사양 안드로이드 기기들을 위해 커스텀 웹뷰를 어플에 내장하기도 했습니다. 물론 이것 외에도 필연적으로 느릴 수 밖에 없는 실행속도를 UX를 통해 개선하는 것들도 있었습니다. 그렇지만 아무리 최적화를 해도 개선에는 한계가 있고, 최적화를 하는 시간이 예상보다 많이 소요되었습니다. &lt;/p&gt;
&lt;p&gt;여전히 팀에서는 “지금이라도 네이티브로 가야 할까?” 혹은 “리액트 네이티브라도 도입을 해볼까?”라는 이야기가 종종 나오는 편입니다. 이렇듯 적은 인원으로 빠르게 개발하면서 높은 사용성을 추구하는 것은 매우 도전적인 일입니다. 하지만 그만큼 기술적인 문제를 해결했을 때의 보람이 있다고 생각합니다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[삶은 무지개 색이어야 한다.]]></title><description><![CDATA[…]]></description><link>https://jaeyo.github.io/life-with-rainbow-colors/</link><guid isPermaLink="false">https://jaeyo.github.io/life-with-rainbow-colors/</guid><pubDate>Sat, 08 Jul 2017 06:21:00 GMT</pubDate><content:encoded>&lt;p&gt;아침부터 찌는 듯이 덥다가도 오후가 되니 거짓말처럼 폭우가 들이닥친다. 더운 공기가 사라진 것은 다행이지 싶지만 여전히 끈덕진걸 보니 여름은 여름인 모양이다.&lt;/p&gt;
&lt;p&gt;사실 “여름”이라는 단어를 곱씹고 있자면 어쩐지 그리운 느낌이 스물스물 든다. 꼬맹이 시절 방학숙제는 내팽게쳐놓고 하루종일 산으로 들로 뛰댕기던 모습들, 열대야에 잠못이룰때 티비에서 보던 공포영화 같은 것들이 생각난다. 친구들과 자전거 한 대에 둘씩 타고는 30분을 걸려 계곡으로 물놀이를 가던 장면들, 근처 실내 수영장에서 입술이 파래지도록 놀고 나온 후 수영장 옆 문구사에서 사먹었던 컵라면 같은 것들이 스쳐간다. &lt;/p&gt;
&lt;p&gt;그로부터 약 십여년이 지났고 내 삶은 많이도 변했다. 민증이 나오고 술, 담배를 합법적으로 하게 되었을 때도 어른이라는 자각은 그다지 없었지만 매달 내 통장을 스쳐 지나가는 대출이자를 보고 있자니 어른이란게 무언지 어렴풋이 알 것 같은 기분이다. 어느새 집에서 독립을 하니 주민등록등본 상에 엄마 아버지 이름이 없고 내가 세대주란다. 거기다 어찌어찌 결혼을 하고 나니 친구들은 나보고 이제 가장이란다. 삶이 참 많이도 변했다.&lt;/p&gt;
&lt;p&gt;나이를 한 살 두 살 먹을 때마다 “산다”는 것에 대해 새롭게 생각하게 된다. 입시란 걸 진지하게 준비하기 시작했던 시절부터 였을까, 당시의 나는 “산다”는 것은 무엇을 이루기 위해 준비해야 하는 과정 쯤으로 생각했던 것 같다. 어릴 때 엄마가 사주셨던 위인전 세트 때문 이었을까, 인서울을 했다던 학교 선배 이야기 때문 이었을까. 아니면 티비에 나오던 성공한 사람들의 화려한 삶의 단면 때문 이었을까. &lt;/p&gt;
&lt;p&gt;아침 8시까지 등교를 하고나면 밤 12시는 되어야 그 교문을 다시 나올 수는 있었다. 지겹고 답답했지만 버틸 만 했다. 끝이 분명히 있었고, 학교를 다니는 것 외에 삶을 즐겁게 만들 만한 취미도 딱히 없었으니까. 한달에 한번씩 치루는 모의고사 점수표가 일종의 당근과 채찍이 되어주었다. 원하는 대학에 진학을 하기 위한 “과정”을 그렇게 어찌어찌 버텨내었고 다행스럽게도 고3 겨울 수능날을 기점으로 그 길고 길었던 인내의 끝에 무사히 도달할 수 있었다. &lt;/p&gt;
&lt;p&gt;문득 지금의 삶과 비교를 해보게 된다. 지금도 나는 어딘가의 종착지에 닿기 위한 “과정”의 삶을 살고 있는걸까. 종착지로 삼기 좋은 것들은 차고 넘친다. 좋은 직장, 높은 연봉, 사회적인 명예나 좋은 차 같은 것들. 다소 속물스러운 늬앙스를 풍긴다는 점만 빼면 아주 매력적인 종착지 들이다. 고생스럽겠지만 페달을 밟아볼만 하다. 그 곳에 닿고 나면 삶은 행복해질테니까.&lt;/p&gt;
&lt;p&gt;아니, 삶은 행복해지지 않을 것이다.&lt;/p&gt;
&lt;p&gt;내일의 무언가를 위해 오늘을 희생하는 삶의 태도를 견지하는 이상, 내일도 다른 내일을 위해 희생될 수 밖에 없다. 목표했던 종착지에 닿았다고 생각했을 때에도 어느샌가 생겨버린 다른 종착지에 다시 닿기 위해 자전거에서 내릴 수 없을 것이다. 쉬지 않고 페달을 밟아야 한다. 아주 쉬운 이야기다. 삶이 행복해지기를 원한다면 그 시점은 내일이 아닌 오늘 이어야 한다.&lt;/p&gt;
&lt;p&gt;사실 이런 논리는 일과 삶의 균형에 대한 주제에 대해 이야기할 때 자주 나오는 흔한 클리셰다. 삶이 일이라는 괴물에 잡아먹히기 직전의 마지막 순간에서 모두가 하나같이 외치는 절규다. 또한 이런 외침을 반박하기 위한 논리 역시 어렵지 않게 찾아볼 수 있다. 사실 이 글을 쓰기 시작한 이유도 이와 관련이 있다.&lt;/p&gt;
&lt;p&gt;일이 삶이고 삶이 일인 사람들이 분명 있다. 그들에게 있어서 삶은 일에 잡아먹히는 성질의 것이 아니며 삶과 일이 자연스럽게 섞여있다. 특히 개발자들 사이에도 그런 사람들을 쉽게 찾아볼 수 있다. “좋아하는 일 = 잘 하는 일 = 돈이 되는 일” 정도가 되면 흔히들 덕업일치의 축복을 받았다고들 한다. 개인적으로 나는 이게 굉장히 큰 행운이라고 생각한다. 덕업일치가 안 되었더라면 나는 일찍히 개발자를 때려쳤겠지. 그렇게 되었다면 장사를 하고 있었을까. 그건 잘 모르겠다.&lt;/p&gt;
&lt;p&gt;현데 사람 산다는 게 또 참 어려운 것이, 덕업일치가 되는 단 몇가지의 즐거움 만으로 인생을 색칠해나가기에는 물감의 종류가 너무도 많다. 단 하나의 물감으로 인생을 색칠해나가는 것이 나쁘다는 이야기는 아니다. 오히려 위대해진 사람들은 대부분이 몇가지 안되는 물감에 선택과 집중을 한 사람들 일 것이다. 페이스북을 만든 주커버그 라던가, 만유인력을 발견한 뉴턴이라던가 뭐 그런 위인 격에 드는 사람들 말이다. &lt;/p&gt;
&lt;p&gt;하지만 나를 포함하여 대부분의 사람들은 단색으로 인생을 칠해나가는 것이 잘 되지도 않고, 또 그렇게 할 필요도 없다. 재미있는 일들, 하고 싶은 일들은 64색 크레파스 보다도 많다. 뷔페라도 온 마냥 그것들을 하나씩 물고 뜯고 즐기다보면 그 일들이 내가 잘하는 일이 아니기도 하고, 돈이 안되는 일이기도 하다. 그때부터 어른의 삶은 고달파진다.&lt;/p&gt;
&lt;p&gt;기타를 아주 그럴듯하게 치는 친구를 하나 알고 있다. 스쿨밴드로 시작해서 이제는 제법 난이도가 높은 곡들도 착착 연주해내고 언젠가부터는 자작곡을 만들어 페이스북에 간간히 올리곤 한다. 물론 프로 지향은 아니다. 단순히 연주를 하고 곡을 쓰는 것이 재미있는 것이다. 단지 그것만으로도 그의 삶에는 색깔이 하나 더해졌고 더 행복해졌을 것이다. 기타를 집었다고 해서 기타로 위대해질 필요는 없다. 인생은 그렇게 치열하게 사는 것이 아니라고 내 아버지는 말하셨다. 누군가는 기타로 세기의 클래식을 내면서 위대해지겠지만 내 친구에게 기타는 여가시간을 즐겁게 보내기 위한 수단일 뿐이다. &lt;/p&gt;
&lt;p&gt;졸릴 눈을 비비며 오랜만에 주저리 주저리 떠들다보니 글이 두서가 없다. 하고 싶은 말은 삶을 가능한 무지개 색으로 칠하면서 살자는 것이다. 여러 분야에 아마추어로 부담없이 걸치며 오늘을 좀 더 다채롭게 만들자는 이야기다. 위대해지기 위해서 오늘을 희생하지 말고 바로 오늘 행복하자는 이야기다. 사실 이 이야기들은 내 자신에게 해주고 싶은 이야기 이기도 하다. 위대해지기 위해서 거리낌없이 오늘들을 희생했던 어린날의 나에게 몇년을 더 산 지금의 내가 해주고 싶은 충고같은 이야기이기도 하다. &lt;/p&gt;</content:encoded></item><item><title><![CDATA[운전을 하고 싶다]]></title><description><![CDATA[운전을 하고 싶다. 틈 날때마다 생각한다. 참 희안한 것이, 운전면허를 따기전까지는 운전을 하고 싶다는 생각을 단 한번도 해본 적이 없다. 오히려 최대한 늦게 따야겠다고 다짐까지 했을 정도니까. 고…]]></description><link>https://jaeyo.github.io/drive/</link><guid isPermaLink="false">https://jaeyo.github.io/drive/</guid><pubDate>Thu, 18 May 2017 00:31:01 GMT</pubDate><content:encoded>&lt;p&gt;운전을 하고 싶다. 틈 날때마다 생각한다. 참 희안한 것이, 운전면허를 따기전까지는 운전을 하고 싶다는 생각을 단 한번도 해본 적이 없다. 오히려 최대한 늦게 따야겠다고 다짐까지 했을 정도니까. 고3 수능이 끝나고 친구들이 하나 둘씩 운전면허 학원에 등록을 할때도, “저것들은 차도 없는 것들이 왜 벌써부터 면허를 따려고 하나” 생각하며 알바 하기에 바빴고, 친구들과 여행을 가면 장거리 운전으로 피곤해 하는 친구에겐 미안하지만 (빈말이다. 사실 별로 미안하지도 않았다.) 뒷자리에서 편히 쉬면서 갈 수 있음을 즐기기도 했다. 지금 가지고 있는 운전면허도 아내와 제주도 여행을 앞두고 급하게 딴 것이다. 제주도에선 차가 없으면 불편하다는 아내의 성화가 없었다면 아마 높은 확률로 지금도 무면허였을 것이다.&lt;/p&gt;
&lt;p&gt;헌데 운전이 하고 싶다. 참으로 이상스런 일이 아닐 수 없다. 택시 앞자리에 앉으면 전방의 차들과 차선을 째려보며 마치 내가 운전을 하는 양 몰입을 하게 된다. 어쩌다 한번씩 고향에 내려가 엄마 차를 몰게 되기라도 하면 몇 시간이고 지치지 않고 여기, 또 저기로 쏘다니기 바쁘다. 이전까지는 몰랐다. 마음만 먹으면 언제든, 또 어디로든 갈 수 있다는 말이 주는 설렘을 전혀 알지 못했다. 아주 설레다 못해 명치께가 간질거리기까지 한다. &lt;/p&gt;
&lt;p&gt;2주 후에 계획된 제주도 여행에서도 관광 명소라던가, 맛집이라던가, 여행지에서의 멋진 숙소 같은 건 머릿 속에 들어오지도 않는다. 그저 운전할 일을 생각하며 설렌다. 해안 도로를 달리고, 그러다 배가 고파지면 맛집을 찾아다가 네비에 찍고 그대로 달린다. 그런 것들을 상상하게 된다. 참으로 이상한 일이 아닐 수 없다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[mariadb multi source replication]]></title><description><![CDATA[multi source replication 절차 slave가 될 mysql 인스턴스의 설정에 아래의 부분을 추가한다. master 데이터베이스에서 replication 용 계정 생성 후 권한을 부여한다 mysqldump 를 이용해서 master…]]></description><link>https://jaeyo.github.io/mariadb-multi-source-replication/</link><guid isPermaLink="false">https://jaeyo.github.io/mariadb-multi-source-replication/</guid><pubDate>Fri, 28 Apr 2017 17:51:00 GMT</pubDate><content:encoded>&lt;h2&gt;multi source replication 절차&lt;/h2&gt;
&lt;p&gt;slave가 될 mysql 인스턴스의 설정에 아래의 부분을 추가한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;# /etc/mysql/maridb.conf.d/50-server.cnf&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;mysqld&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token assign-left variable&quot;&gt;server_id&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;19823759&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;# master와 겹치지 않게&lt;/span&gt;
replicate-ignore-db&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;mysql &lt;span class=&quot;token comment&quot;&gt;# mysql 데이터베이스는 복제하지 않음&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;master 데이터베이스에서 replication 용 계정 생성 후 권한을 부여한다&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;grant replication slave on *.* to ‘repl’@‘%’ identified by ‘&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;repl123’&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;mysqldump 를 이용해서 master가 될 데이터베이스에서 덤프를 받는다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;mysqldump --databases database_1 database_2 --single_transaction --master-data&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; -h host_path -u account -p &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; dump.sql&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;락이 걸리는 걸 방지하기 위해 &lt;code class=&quot;language-text&quot;&gt;—single-transaction&lt;/code&gt; 옵션 추가해야 하며, 덤프를 받은 시점의 binlog 파일과 포지션을 확인하기 위해 &lt;code class=&quot;language-text&quot;&gt;—master-data=1&lt;/code&gt; 옵션 추가한다. 그러면 덤프 파일 상단에 &lt;code class=&quot;language-text&quot;&gt;change master …&lt;/code&gt; 구문이 생성되는데 multi source 로부터 replication 을 받아야 하기 때문에 아래와 같이 수정해준다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;CHANGE MASTER &lt;span class=&quot;token string&quot;&gt;&apos;master_name&apos;&lt;/span&gt; TO
&lt;span class=&quot;token assign-left variable&quot;&gt;master_host&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;host_path&apos;&lt;/span&gt;,
&lt;span class=&quot;token assign-left variable&quot;&gt;master_user&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;account&apos;&lt;/span&gt;,
&lt;span class=&quot;token assign-left variable&quot;&gt;master_password&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;password&apos;&lt;/span&gt;,
&lt;span class=&quot;token assign-left variable&quot;&gt;master_port&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3306&lt;/span&gt;,
&lt;span class=&quot;token assign-left variable&quot;&gt;MASTER_LOG_FILE&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;mysql-bin-changelog.052616&apos;&lt;/span&gt;, &lt;span class=&quot;token assign-left variable&quot;&gt;MASTER_LOG_POS&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;886626&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;# dump에 기록된 그대로 유지&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;만약 덤프 파일이 너무 커서 수정하기가 힘든 경우 아래와 같이 파일을 잘라서 수정한 후에 합치는 방법을 사용할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token function&quot;&gt;head&lt;/span&gt; -n &lt;span class=&quot;token number&quot;&gt;30&lt;/span&gt; dump.sql &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; new_dump.sql
&lt;span class=&quot;token function&quot;&gt;vim&lt;/span&gt; new_dump.sql
&lt;span class=&quot;token function&quot;&gt;tail&lt;/span&gt; -n +30 dump.sql &lt;span class=&quot;token operator&quot;&gt;&gt;&gt;&lt;/span&gt; new_dump.sql&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;slave가 될 데이터베이스에 덤프를 밀어넣는다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;mysql -h hostpath -u account -p database_name &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; dump.sql&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;여기서 database_name은 덤프 내 여러개의 데이터베이스가 담겨 있다고 해도 그 중 하나만 지정해도 되지만 지정된 데이터베이스는 미리 생성되어 있어야 한다.&lt;/p&gt;
&lt;p&gt;replication 스레드를 시작시킨다: &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;sql&quot;&gt;&lt;pre class=&quot;language-sql&quot;&gt;&lt;code class=&quot;language-sql&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;start&lt;/span&gt; slave &lt;span class=&quot;token string&quot;&gt;&apos;master_name&apos;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;기타 유의사항&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;replication 설정을 위해서는 super previleges가 필요한데 aws rds를 이용하면 일반 사용자가 super previleges를 가질 수 없다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;binary log가 너무 빨리 rotate 되는 경우에는 아래와 같이 retention 값을 확인 및 조정할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;call mysql.rds_show_configuration()&lt;/code&gt; 으로 &lt;code class=&quot;language-text&quot;&gt;binlog retention hours&lt;/code&gt; 값 확인&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;call mysql.rds_set_configuration(‘binlog retention hours’, 1);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[Too many open files]]></title><description><![CDATA[…]]></description><link>https://jaeyo.github.io/too-many-open-files/</link><guid isPermaLink="false">https://jaeyo.github.io/too-many-open-files/</guid><pubDate>Tue, 25 Apr 2017 19:25:01 GMT</pubDate><content:encoded>&lt;p&gt;집에서 기타치면서 놀고 있었는데 외출했던 아내가 귀가중이라는 메시지를 받았다. 집 앞 지하척 역으로 마중나가려고 핸드폰을 챙겨서 나가려는데 슬랙 메시지가 뭐가 많이 와있다. 평소 팀에서 커뮤니케이션을 슬랙으로 하기 때문에 별 생각없이 슬랙 메시지들을 확인해보고 있는데 서버쪽에 장애가 날 때 메시지가 오는 채널에 몇개의 메시지가 와있다. 순간 심장이 덜컹하며 확인해보니 몇가지 종류의 에러메시지가 꽤 여러번 발생한 형태다.&lt;/p&gt;
&lt;p&gt;첫번째 에러는 too many open files
두번째 에러는 unable to find server blabla&lt;/p&gt;
&lt;p&gt;두번째 에러로그는 심지어 디비서버를 못찾는다는 에러메시지!
디비 서버를 못찾았다면 서비스 자체가 안될텐데.
마음을 졸이며 우리 서비스에 들어가보니 일단 접속도 잘 되고 데이터 로딩도 문제없이 된다. 그렇다면 사태는 일단락 되었다는 이야긴데..&lt;/p&gt;
&lt;p&gt;그렇다고 손놓고 다시 기타나 뚱기뚱기할 수는 없으니 다시 로그를 뒤진다. was 로그와 syslog 등등을 종합적으로 뒤지고 수상해보이는 놈들은 죄 구글링을 해봤지만 별게 안나왔다.
할 수 없이 에러로그에 집중해보니, 일단 too many open files가 먼저 나고 그 다음에 디비서버를 못찾았다. 혹시나 싶어 로드밸런서에 물려있는 다른 서버를 확인해봤는데 다른 서버는 문제가 없었다. 그렇다면 실제 디비서버가 나가리가 되었다거나 한 문제는 아니라고 볼 수 있겠다고 생각했다. &lt;/p&gt;
&lt;p&gt;일단 too many open files가 떠있으니 ulimit 을 확인해주는데, 어라? 1024? 왜 이렇게 값이 작지?&lt;/p&gt;
&lt;p&gt;찬찬히 머리속에서 히스토리들을 뒤져보는데 한달전쯤 was를 변경했고 was가 변경되면서 리눅스 계정이 바꼈고 바뀐 리눅스 계정에 대해서 ulimit 값을 변경…을 안해줬구나. 아…&lt;/p&gt;</content:encoded></item><item><title><![CDATA[아닌 밤중에 리퀘스트가 튄다?]]></title><description><![CDATA[신규 서비스를 오픈하면서 서버 모니터링을 위해 aws cloudwatch를 사용하게 되었다. 원래는 cloudwatch와 newrelic 을 모두 선택지에 올려놓고 마지막까지 고민을 했다. newrelic…]]></description><link>https://jaeyo.github.io/weird-requests/</link><guid isPermaLink="false">https://jaeyo.github.io/weird-requests/</guid><pubDate>Tue, 25 Apr 2017 12:00:01 GMT</pubDate><content:encoded>&lt;p&gt;신규 서비스를 오픈하면서 서버 모니터링을 위해 aws cloudwatch를 사용하게 되었다. 원래는 cloudwatch와 newrelic 을 모두 선택지에 올려놓고 마지막까지 고민을 했다. newrelic 쪽이 기능도 많고 레퍼런스도 확실했지만 일부 서버에서 agent의 설치가 안되는 문제가 있었다. 사실 agent 설치 안되는 문제야 조금 더 시간을 들여서 파보면 해결할 수 있는 문제였겠지만 당장에 서비스 오픈을 코앞에 둔 상황에서 시간적인 여유가 부족했고, cloudwatch도 우리가 필요한 기능을 대부분 제공하고 있었기 때문에 cloudwatch로 가기로 했다.&lt;/p&gt;
&lt;p&gt;cpu, 메모리, 디스크 사용량 등의 지표를 대시보드로 구성해놓고 며칠 모니터링하고 있으려니까 좀 이상한 현상이 눈에 띄었다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/H99gBeu.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;일부 서버에서 주기적으로 network out이 튀고 있었다. 시간도 정확하게 6시 반쯤에 시작해서 11시에는 정상으로 돌아왔다. 제일 먼저 해당 서버에서 주기적으로 스케쥴링되어 돌고 있는 태스크가 있는지 확인했다. 하지만 스케쥴이 걸려있는 태스크라고는 cloudwatch 메트릭 값을 수집하는 agent 뿐이었고 이 에이전트도 5분마다 한번씩 실행되도록 구성되어 있었기 때문에 용의선상에서 벗어났다. 그외에 여러 의심되는 부분들을 샅샅이 뒤져봤으나 애초에 해당 서버는 aws s3에 있는 데이터들을 변환해 던져주는 역할만 하는 심플한 서버였기 때문에 원인을 진단하기가 어려웠다. network out이 튀는 정도가 분당 평균 5mb 근처였기 때문에 당장 서비스 운영에 문제를 줄만한 사안이 아니었고 이 문제 말고도 긴급을 요하는 태스크들이 많았기 때문에 자연히 칸반 보드의 todo list 어딘가로 해당 이슈는 쳐박히게 되었다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/RPkrl0O.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;문제는 다른 부분에서 다시 일어났다. 이 서버의 메모리 사용량이 슬금슬금 눈치채지 못할 정도로 느리게 증가하고 있었다. 최초 기동시에는 6퍼센트 정도에서 머물던 것이 시간이 지남에 따라 50%를 넘어 70%를 넘보는 수준까지 도달한 것이었다. 그때 팀원 중 한명이 s3fs를 의심하기 시작했다. 이 서버는 s3에 있는 데이터를 서빙하기 위해서 s3fs 라는 오픈소스를 이용해서 s3 특정 버킷을 가상으로 마운트 시켜놓고 쓰고 있었다. s3fs 프로젝트의 issue란을 뒤져보니 memory leak이 있다는 issue가 유난히 많았다. 팀 내부에서도 s3fs의 memory leak bug로 인한 현상으로 추정하고 옵션값 튜닝을 더 해보고 안되면 s3fs 대신 goofys 라는 솔루션으로 넘어가기로 했다. 하지만 그대로 s3fs의 memory leak bug 라고 단정해버리기엔 좀 찜찜한 것이, github issue에 올라온 memory leak 리포트들은 대부분 수십분에서 수 시간 내로 서버의 메모리를 모두 잡아먹고 뻗어버리는 현상이 발생했던 것과는 달리 우리 서버는 2주째 메모리 사용량을 야금야금 먹으면서 올라오긴 했지만 서버의 메모리를 모두 잡아먹진 않았다. 조금 더 살펴보기로 했다.&lt;/p&gt;
&lt;p&gt;일단 좀 더 정확한 정황을 확인하기 위해 s3fs의 디버그 로그 옵션을 켜고 다시 재기동하였다. syslog에 어마어마한 양의 로그가 쌓이기 시작했다. 양 자체가 워낙에 많에 전수조사를 할 수는 없었지만 일단 일부 확인한 내용으로는 이상해보이는 로그는 보이지 않았다. 그렇게 주말을 보내고 월요일 아침 다시 로그를 확인해보았다. 이 때 였다. 의심스러운 로그가 눈에 들어오기 시작했다.&lt;/p&gt;
&lt;p&gt;매일 아침 6시 25분마다 s3fs에 의해서 가상 마운트되어 있는 폴더 아래 모든 오브젝트들을 하나씩 순회하는 로그들이 찍혀있었다. 해당 s3 bucket에는 수만개 이상의 오브젝트들이 존재하고 있기 때문에 이 순회 작업은 수시간 후에야 끝났다. 그 때 잊고 있었던 네트워크 튐 현상이 떠올랐다. network out 지표에도 매일 아침 6시 반부터 11시 까지 그래프가 튀어 있었고 s3fs 로그에서는 그 시간대에 bucket내 모든 오브젝트들을 순회하는 로그가 찍혀있었다. 즉, s3fs 마운트 폴더에서의 순회요청은 그대로 디스크를 뒤지는 것이 아니라 network를 타고 나가 s3 서버로 요청을 던지게 되므로 network out 그래프가 튀게 된 것이다. 범인은 꼬리가 보이기 시작했다. 우리는 이 단서를 조금 더 파보기 시작했다.&lt;/p&gt;
&lt;p&gt;한가지 더 이상했던 것은 s3fs 마운트 폴더를 순회하는 로그가 정확히 각 syslog의 가장 첫부분부터 시작이 되고 있었다는 것이다. syslog는 logrotate에 의해서 롤링되고 있었기 때문에 logrotate가 실행되는 시점에 어떤 명령에 의해서 s3fs 마운트 폴더 순회 명령이 걸렸다고 추정할 수 있었다. 범인의 몽타주가 얼핏 보이는 듯 했다. logrotate 실행 스크립트가 담겨있는 cron.daily 폴더를 조회해보았다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/t2dXBN8.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;운좋게 몇놈 없었다. 이 놈들 중 범인이 있다고 확신한 나는 각 스크립트들을 하나씩 취조하기 시작했고 마침내 mlocate가 범인임을 확인할 수 있었다. mlocate는 빠른 파일 접근을 위해 디스크 내용을 인덱싱하는 역할을 하고 있었는데, 그 인덱싱 작업을 매일 아침마다 돌고 있었고 그 대상에는 안타깝게도 s3fs 마운트 폴더도 존재했던 것이다. mlocate가 인덱싱을 위해서 해당 폴더 내 모든 하위 플더들을 순회하면서 인덱싱을 했고, 순회하면서 발생하는 모든 요청들은 모두 s3 서버로의 요청이 되어 network out 지표를 튀게 만들었던 것이다. 메모리 사용량 증가도 자세한 경과까지는 확인하지 못했지만 짧은 시간내에 감당하기 힘든 네트워크 요청들로 인해서 발생한 것이라고 이해하기에 어려움이 없었다. &lt;/p&gt;
&lt;p&gt;조치는 간단했다. mlocate가 인덱싱을 하는 폴더들 중 s3fs 마운트 폴더를 예외로 넣은 후에 s3fs를 재기동해주었다. 메모리 사용량은 정상으로 돌아왔고 며칠이 지난 지금까지도 정상 범주를 벗어나지 않고 있다. network out 그래프 역시 정상의 범주로 돌아왔다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[겹겹의 공간들]]></title><description><![CDATA[…]]></description><link>https://jaeyo.github.io/spaces/</link><guid isPermaLink="false">https://jaeyo.github.io/spaces/</guid><pubDate>Tue, 25 Apr 2017 11:00:01 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;일상에서 우리가 기억이라고 부르는 것도 공간화한 기억이다. 프루스프가 “읽어버신 시간을 찾아서”에서 끊임없이 유년의 마을과 길과 집과 방들을 소환하는 까닭도, 추억이란 게 벌집 같은 공간 속에 특정의 시간들을 압축-공간화하고 있기 때문이다. 바슐라르가 “공감의 시학”에서 한 말처럼 “기억을 생생하게 하는 것은 시간이 아니라 공간이다. 우리들이 오랜 머무름에 의해 구체화된 지속의 아름다운 화석들을 발견하는 것은, 공간에 의해서, 공간 가운데서인 것이다”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;그러고보니, 추억이라는 것들을 하나둘씩 들여다보면 시간과 사람들, 그때 했던 생각이나 가졌던 감정들, 표정과 분위기같은 것들은 희끄무레하니 기억이 잘 나지 않는 반면에 공간만큼은 선명하게 기억이 난다. 생각보다 공간이라는 의미는 인간에게 이리도 푸대접받을 만한 작은 의미가 아닌걸까. 우리의 공간에 대한 인식이 이리 뚜렷한 이유가 뭘까.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[이직 면접 이야기]]></title><description><![CDATA[…]]></description><link>https://jaeyo.github.io/job-interview/</link><guid isPermaLink="false">https://jaeyo.github.io/job-interview/</guid><pubDate>Thu, 25 Aug 2016 14:40:55 GMT</pubDate><content:encoded>&lt;p&gt;직장인이 이직 면접을 준비하면서 받는 스트레스가 이혼을 할 때 받는 스트레스와 비슷하다는 이야기를 들은 적이 있다. 글쎄, 내 경우에 비추어보면 조금 과장되다 싶게 느껴지는 이야기긴 하지만, 그만치 감당해야 할 부담이 상당하다는 점에서는 공감을 하게 된다. 면접이 거듭될 때마다 자존감이 손바닥 위 모래처럼 사그러들고, 나는 지금까지 뭐하고 살아왔나 하는 인생 전반에 대한 후회를 하게 되는 것이, 이거 오래 준비하다간 내 명에 못살지 싶었다. 회사 입장에서는 심플하게 &lt;strong&gt;충원하려는 자리에 맞지 않아서&lt;/strong&gt; 퇴짜를 놓았다지만 지원자는 &lt;strong&gt;난 역시 이 정도밖에 안되는 인간인가&lt;/strong&gt; 하는 자괴감을 느끼게 되는 것이다.&lt;/p&gt;
&lt;p&gt;개인적인 경험에 빗대어 봤을 때, 긴장이 풀리면 면접이 잘 풀렸었다. 어느 순간부터 “지금 면접관이 날 어떻게 생각하고 있을까”하는 생각이 머릿 속에서 사라지고, “말빨”이 터져 진짜 내가 누군지를 여실히 떠들고나면 면접관들 입가에서 만족스런 미소를 여볼 수 있었다. 반대로 시작부터 긴장된 상태로 면접에 돌입하고, 지금 내가 긴장을 하고 있다는 사실을 수시로 확인하며 긴장은 더욱 더 증폭이 되고, 이쯤되면 면접관의 간단한 질문도 도저히 한국말로는 안들리게 되는 것이다. 질문을 듣고 고심하는 척 미간을 찌푸리지만 이미 머릿속은 백지다. 그리고 “지금 머릿속이 백지구나”라고 한번 더 되뇌이는 순간 사고는 정지되고 등 뒤로는 식은 땀이 흐른다.&lt;/p&gt;
&lt;p&gt;그래도 면접은 내게 대부분 즐거운 경험이었다. 실패에 대한 리스크가 작지 않다는 점에서 뭔가 위험천만한 스릴 같은 것들이 느껴지기도 했다. 면접을 준비하면서 “나는 이렇게 이런걸 쌓아왔어. 난 괜찮은 놈이야”라고 자기 최면을 걸고, 면접 당일에는 내 자신에 대한 이야기를 한시간에서 두시간 가량 마음껏 늘어놓을 수 있으니 두려움만 떨치면 이건 즐거운 경험이었다. 나는 말이 많은 편은 아니지만 자기 표현에 대한 욕구는 많은 사람이었다. “나는 이런 사람입니다, 이렇게 살아왔구요, 이런 것들을 중요하게 생각합니다.” 하고 떠들고 있다 보면 오랜 친구와 술에 거나하게 취해 인생이 어쩌고 하는 개똥철학을 주고 받는 장면을 떠올리게 한다.&lt;/p&gt;
&lt;p&gt;아쉬운 것은, 신입으로 경력을 쌓고 경력직으로 면접을 준비하게 되면 더이상 내 자신에 대한 의야기 보다는 내가 쌓아온 경험에 대해 이야기해야 하는 시간이 더 많았다. 하지만 이것 또한 나쁘지 않은 것이, 신입 시절 운좋게 내가 좋아할 수 있는 직무를 맡게 되면서 즐겁게 공부하고 경험해온 것들을 떠들 수 있어서 좋았다. &lt;/p&gt;
&lt;p&gt;면접 준비를 하고 면접에 떨어지고 나면 내가 가야할 길들이 좀 더 명확하게 느껴지곤 한다. 내가 가고싶은 회사, 가고싶은 직무의 구직공고에 붙어 있는 기본 요건과 우대 사항들을 보면서 앞으로 내가 공부해 나가야 될 청사진들을 대략적으로 잡을 수 있었고, 면접을 거친 후 내가 대답할 수 있었던 질문과, 대답하지 못했던 질문들을 다시 헤아리며 내가 지금 서있는 위치와 부족한 부분들을 객관적으로 알 수 있었다. &lt;/p&gt;
&lt;p&gt;그렇게 면접 준비와 면접 과정을 거쳐 지금 회사로 이직을 하게 되었고 꽤 만족스럽다고 생각하고 있다. 결과적으로 가고 싶은 회사, 하고 싶은 직무를 맡을 수 있었고, 원하는 조직 문화를 체험하게 됐으며, 똑똑한 사람들과 더 재미있는 일들을 할 수 있게 되었다. 이 회사에 평생 몸담을 수 있다면 그것도 그것 나름대로 좋겠지만 나는 아마 또 이직 준비를 해야 할 시기를 맞게 될 것이다. 하지만 이직을 준비하고 이직을 하게 되는 경험들이 크게 보면 나를 계속해서 채찍질하여 성장하게 만든다고 생각한다.&lt;/p&gt;</content:encoded></item></channel></rss>