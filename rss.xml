<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Hello, there]]></title><description><![CDATA[A starter blog demonstrating what Gatsby can do.]]></description><link>https://jaeyo.github.io</link><generator>RSS for Node</generator><lastBuildDate>Wed, 04 Sep 2019 02:40:05 GMT</lastBuildDate><item><title><![CDATA[오픈소스 프로젝트에 코드 기여한 이야기]]></title><description><![CDATA[그동안 개발자로 일하면서 오픈소스의 도움을 많이 받아왔던 것 같다. 아닌게 아니라 당장 Github…]]></description><link>https://jaeyo.github.io/contribute-code-into-telegraf/</link><guid isPermaLink="false">https://jaeyo.github.io/contribute-code-into-telegraf/</guid><pubDate>Thu, 22 Aug 2019 19:00:00 GMT</pubDate><content:encoded>&lt;p&gt;그동안 개발자로 일하면서 오픈소스의 도움을 많이 받아왔던 것 같다. 아닌게 아니라 당장 Github이 없으면 나는 현재의 생산성의 반의 반도 못 내고 있을 것이다. 하지만 부끄럽게도 작년에야 처음으로 오픈소스에 기여를 하게 되었다. 사실 기여를 하고자 하는 생각은 아주 오래전부터 가지고 있었다. 하지만 기여할 프로젝트를 고르는 문제부터 시작해서, 기존 소스코드를 파악하고, 버그의 원인을 찾고, 메인테이너와 소통하고 하는 일들이 너무 어렵게 느껴져 시도하지 못했다고 하는게 맞을 것 같다. 그러던 차에 우연찮게 처음으로 오픈소스 프로젝트에 기여하게 되었고 그 과정이 생각보다 어렵지 않다는 것을 알게 되었다.&lt;/p&gt;
&lt;p&gt;내가 참여한 오픈소스는 &lt;a href=&quot;https://github.com/influxdata/telegraf&quot;&gt;Telegraf&lt;/a&gt; 였다. 뭐 이름이 생경하게 들릴 수는 있지만 그래도 나름 모니터링 쪽 동네에서는 방귀좀 뀌는 프로젝트다. 일반적으로 모니터링이라고 하면 서버 모니터링 (IaaS 레벨의 모니터링)과 애플리케이션 모니터링(APM) 정도를 많이 떠올릴 텐데, 이 Telegraf 는 서버 모니터링 쪽에서 활약하고 있는 메트릭 수집 에이전트다.&lt;/p&gt;
&lt;p&gt;모니터링은 일반적으로 &lt;code class=&quot;language-text&quot;&gt;수집&lt;/code&gt; -&gt; &lt;code class=&quot;language-text&quot;&gt;저장&lt;/code&gt; -&gt; &lt;code class=&quot;language-text&quot;&gt;분석&lt;/code&gt; -&gt; &lt;code class=&quot;language-text&quot;&gt;시각화&lt;/code&gt; 정도의 플로우를 타게 된다. (중간에 순서가 조금 바뀌는 경우는 있다.) 여기서 Telegraf 는 &lt;code class=&quot;language-text&quot;&gt;수집&lt;/code&gt;단을 맡고 있다. Elastic stack 의 &lt;code class=&quot;language-text&quot;&gt;metricbeat&lt;/code&gt;와 포지셔닝이 비슷하다고 할 수 있을 것이다.&lt;/p&gt;
&lt;p&gt;말 나온 김에 모니터링 영역에서 Elastic 스택과 TICK 스택을 비교해보자면, &lt;code class=&quot;language-text&quot;&gt;Beat&lt;/code&gt; -&gt; &lt;code class=&quot;language-text&quot;&gt;Logstash&lt;/code&gt; -&gt; &lt;code class=&quot;language-text&quot;&gt;Elastiverseticsearch&lt;/code&gt; -&gt; &lt;code class=&quot;language-text&quot;&gt;Kibana&lt;/code&gt; 의 플로우를 가지고 있는 Elastic 스택은 기본적으로 로그 모니터링에 근간을 두고 있다. 애초에 Elasticsearch 라는 솔루션이 풀 텍스트 인덱싱을 하는 Lucene 으로 만들어진 물건이니. 물론 요즘에는 로그와 메트릭 뿐만 아니라 APM 까지 만들어서 애플리케이션 레벨의 모니터링까지 영역을 넓히고 있긴 하다.&lt;/p&gt;
&lt;p&gt;그에 반해, TICK 스택은 메트릭 기반의 모니터링이라고 볼 수 있다. 여기서 메트릭과 로그의 차이점이라고 하면, 로그는 단순히 문자열 형태의 메시지라면 메트릭은 수치값을 가지는 형태라고 볼 수 있을 것이다. 애초에 Telegraf 자체도 메트릭 수집에 특화되어 있고 데이터 저장소인 InfluxDB 도 시계열 데이터를 저장하는 데이터베이스로 만들어져 있다.&lt;/p&gt;
&lt;p&gt;여기서 TICK 스택이라고 하면 &lt;code class=&quot;language-text&quot;&gt;Telegraf&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;InfluxDB&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;Chronograf&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;Kapacitor&lt;/code&gt; 로 이루어진 스택을 이야기하는데 그런 것 치고 시각화 영역을 Chronograf 로 쓰는 경우는 별로 없다. 사실 &lt;code class=&quot;language-text&quot;&gt;Chronograf&lt;/code&gt; 보다는 &lt;code class=&quot;language-text&quot;&gt;Grafana&lt;/code&gt; 가 시각화 도구로서 기능도 더 많고 기타 여러 데이터 소스와의 접합도 좋아서 &lt;code class=&quot;language-text&quot;&gt;TIG&lt;/code&gt; (&lt;code class=&quot;language-text&quot;&gt;Telegraf&lt;/code&gt; - &lt;code class=&quot;language-text&quot;&gt;InfluxDB&lt;/code&gt; - &lt;code class=&quot;language-text&quot;&gt;Grafana&lt;/code&gt;) 형태의 스택이 더 많이 쓰이는 것 같다. 근데 문제는 &lt;code class=&quot;language-text&quot;&gt;Grafana&lt;/code&gt; 쪽에서는 TICK 스택보다는 &lt;code class=&quot;language-text&quot;&gt;Prometheus&lt;/code&gt; 랑 더 친하고 요즘 container 기반 에코 시스템에서 Prometheus 가 더 잘 나간다는 사실이다. 그리고 둘 다 Go 언어로 만들어져 있다. 사실 요즘 container 기반의 에코 시스템 위의 툴들은 열에 여덟은 Go 언어를 사용하고 있는 것 같다. 이쪽 동네의 de facto 언어가 되어가는 느낌이다.&lt;/p&gt;
&lt;p&gt;아무튼 각설하고, Telegraf 앞서 말했든 메트릭 수집 에이전트다. 하지만 Telegraf 를 설명하는 말에는 항상 수식어가 하나 더 붙는다. “플러그인 기반” 이 그것이다. Telegraf 는 다양한 플러그인을 통해서 다양한 종류의 메트릭들을 수집할 수 있다. 그리고 수집된 메트릭을 꼭 InfluxDB 에만 넣을 수 있는 것도 아니라 다른 Output Plugin 을 통해서 다른 종류의 데이터 저장소에 집어 넣는 것도 가능하다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.influxdata.com/wp-content/uploads/Telegraf-GREY-Diagram.png&quot; alt=&quot;Telegraf&quot;&gt;&lt;/p&gt;
&lt;p&gt;위의 그림은 Telegraf 공식 웹페이지에 있는 그림으로 TICK 스택의 아키텍처를 자세하게 보여준다. 여담으로 작년말에 확인해 봤을 때는 저 그림에 “200개 이상의 플러그인 지원” 관련된 문구가 써있었는데 실제로 확인해봤을 땐 198개 였다. 뭐 그냥 그려려니 했다. 아무튼 Telegraf 에서 지원하는 플러그인 리스트는 Telegraf Github 에 들어가면 README 에서 바로 확인할 수 있는데 오늘 날짜 master 브랜치 기준으로 아래와 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Input Plugins: activemq, aerospike, amqp&lt;em&gt;consumer, apache, aurora, aws cloudwatch, bcache, beanstalkd, bind, bond, burrow, cassandra, ceph, cgroup, chrony, cisco&lt;/em&gt;telemetry&lt;em&gt;gnmi, cisco&lt;/em&gt;telemetry&lt;em&gt;mdt, cloud&lt;/em&gt;pubsub, cloud&lt;em&gt;pubsub&lt;/em&gt;push, conntrack, consul, couchbase, couchdb, cpu, DC/OS, diskio, disk, disque, dmcache, dns query time, docker, docker&lt;em&gt;log, dovecot, ecs, elasticsearch, exec, fail2ban, fibaro, file, filestat, filecount, fireboard, fluentd, github, graylog, haproxy, hddtemp, httpjson, http&lt;/em&gt;listener, http&lt;em&gt;listener&lt;/em&gt;v2, http, http&lt;em&gt;response, icinga2, influxdb, influxdb&lt;/em&gt;listener, internal, interrupts, ipmi&lt;em&gt;sensor, ipset, iptables, ipvs, jenkins, jolokia2, jolokia, jti&lt;/em&gt;openconfig&lt;em&gt;telemetry, kafka&lt;/em&gt;consumer, kapacitor, kinesis, kernel, kernel&lt;em&gt;vmstat, kibana, kubernetes, kube&lt;/em&gt;inventory, leofs, linux&lt;em&gt;sysctl&lt;/em&gt;fs, logparser, lustre2, mailchimp, mcrouter, memcached, mem, mesos, minecraft, mongodb, mqtt&lt;em&gt;consumer, multifile, mysql, nats&lt;/em&gt;consumer, nats, neptune&lt;em&gt;apex, net, net&lt;/em&gt;response, netstat, nginx, nginx&lt;em&gt;plus&lt;/em&gt;api, nginx&lt;em&gt;plus, nginx&lt;/em&gt;upstream&lt;em&gt;check, nginx&lt;/em&gt;vts, nsq&lt;em&gt;consumer, nsq, nstat, ntpq, nvidia&lt;/em&gt;smi, openldap, opensmtpd, openweathermap, pf, pgbouncer, phpfpm, phusion passenger, ping, postfix, postgresql&lt;em&gt;extensible, postgresql, powerdns, powerdns&lt;/em&gt;recursor, processes, procstat, prometheus, puppetagent, rabbitmq, raindrops, redis, rethinkdb, riak, salesforce, sensors, smart, snmp&lt;em&gt;legacy, snmp, socket&lt;/em&gt;listener, solr, sql server, stackdriver, statsd, swap, syslog, sysstat, system, tail, temp, tcp&lt;em&gt;listener, teamspeak, tengine, tomcat, twemproxy, udp&lt;/em&gt;listener, unbound, uswgi, varnish, vsphere VMware vSphere, webhooks, filestack, github, mandrill, papertrail, particle, rollbar, win&lt;em&gt;perf&lt;/em&gt;counters, win&lt;em&gt;services, wireless, x509&lt;/em&gt;cert, zfs, zipkin, zookeeper&lt;/li&gt;
&lt;li&gt;Parsers: InfluxDB Line Protocol, Collectd, CSV, Dropwizard, FormUrlencoded, Graphite, Grok, JSON, Logfmt, Nagios, Value, Wavefront&lt;/li&gt;
&lt;li&gt;Serializers: InfluxDB Line Protocol, JSON, Graphite, ServiceNow, SplunkMetric, Carbon2, Wavefront&lt;/li&gt;
&lt;li&gt;Processor Plugins: converter, date, enum, override, parser, pivot, printer, regex, rename, strings, topk, unpivot&lt;/li&gt;
&lt;li&gt;Aggregator Plugins: basicstats, final, histogram, minmax, valuecounter&lt;/li&gt;
&lt;li&gt;Output Plugins: influxdb, influxdb&lt;em&gt;v2, amon, amqp (rabbitmq), application&lt;/em&gt;insights, aws kinesis, aws cloudwatch, azure&lt;em&gt;monitor, cloud&lt;/em&gt;pubsub, cratedb, datadog, discard, elasticsearch, file, graphite, graylog, health, http, instrumental, kafka, librato, mqtt, nats, nsq, opentsdb, prometheus, riemann, riemann&lt;em&gt;legacy, socket&lt;/em&gt;writer, stackdriver, syslog, tcp, udp, wavefront&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;Telegraf 에 대한 자세한 설명은 생략하기로 하고, 회사에서 업무의 일환으로 Telegraf 를 사용중에 있다. 이전까지는 운영중인 Linux 기반의 서버들에서 메트릭을 수집하기 위한 용도였는데 윈도우 서버도 추가적으로 지원해야 하는 요구사항이 발생되었다. Telegraf 는 윈도우 역시 지원하기 때문에 별 고민없이 설치하고 테스트를 하기 시작했다. 다만 리눅스와 윈도우는 메트릭을 수집하는 방법에 차이가 있어 리눅스 서버와는 다른 윈도우용 기본 설정 파일을 받아서 구성했다.&lt;/p&gt;
&lt;p&gt;헌데 설정파일을 받아놓고 슥 한번 훑어보는데 이상한 부분이 눈에 띄었다.&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/88b387c383230d17a2eb660f470d3f0e/ce9b3/1.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 55.998008959681435%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABcSAAAXEgFnn9JSAAABZklEQVQoz31S2Y6DMBDrLxRKyxGOQkggW+gh9f8/bdbOLlU2rfZhBMo4HtuZXdu24pwTY4yoSklZllIUuRwOB19pmsrxeBTirLEyag1c5c/YY204fncErssiZhwlw0GSJG/ALMtED4MfTHwFwlopyfP8D5knrNBY1qtoECZBI1Y4QNmyrDJNkzRN452wNqUvwq6uZQX463yWKpwWKOSlse9lwlBFVXCR/Nab5RkW7peLz6Y/nSSj3Ygwh+UH+rdpFgcBDaOJXLwUauTxuN3EIh9FNREhYyhAOMHB/fmUvuukpLIPZJ7QIMPVWrmA8JNCTwjLBoOJcXiccr+XPfuRXU/YI+AHgnZBhiGA/ycMMojGwK4F/ozvpxf2hArNier04JVxRVhp9CgzMMS1sMy1ISbeiNceunmWkS8I+wRzHbYLG6FFLNzDDnjeKYrin8Vef/arhlraIzi05NdGj35oB4VdpDK0/Q24Lh38oSubagAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;Duplicated Configuration&quot;
        title=&quot;&quot;
        src=&quot;/static/88b387c383230d17a2eb660f470d3f0e/b9e4f/1.png&quot;
        srcset=&quot;/static/88b387c383230d17a2eb660f470d3f0e/cf440/1.png 148w,
/static/88b387c383230d17a2eb660f470d3f0e/d2d38/1.png 295w,
/static/88b387c383230d17a2eb660f470d3f0e/b9e4f/1.png 590w,
/static/88b387c383230d17a2eb660f470d3f0e/f9b6a/1.png 885w,
/static/88b387c383230d17a2eb660f470d3f0e/2d849/1.png 1180w,
/static/88b387c383230d17a2eb660f470d3f0e/ce9b3/1.png 2009w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;Network 관련된 메트릭을 수집하는 설정을 설정 파일 위쪽에서 한 번 본 것 같은데 아래에서 또 발견되었다. 보통 이런 경우는 “Telegraf 의 기본 설정 파일이 잘못 되었구나” 라고 여기기 보다는 “내가 뭘 잘못 했구나” 라고 생각하기 쉽다. 자연히 나도 붙여넣기하면서 실수 했겠거니 하면서 새롭게 윈도우용 설정 파일을 다시 받았다. 하지만 새로 받은 설정 파일에도 해당 섹션은 중복되어 있었다.&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/bea71d803b581d2cc4ab35a0ab62436b/8e427/2.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 23.75886524822695%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABcSAAAXEgFnn9JSAAAAzElEQVQY05WP2W7CMBRE8///VaRWILGUBIgRi0mz4SAMFQkJPrUd1DceGGk8dx48d26gtSaOY4RYWxVe91JS1zXvwPjHEPzYz8sw8lzM54jVCrndUeY5ZZaRp6mf73bBK7ZN48NcaNAlCfl0ivgYsP38Qg6HyNGIYvZNNpl4puMxVRShwhBl1c2nxbL3toi2Jei6PtA17doWVR7RZ83v9UqlKszjwbsw7mQ33EpFsdlRyQNq39P50yHB6AvmfHmqxjR338Q8T7Ty7x3+ANCNfUt/DUM4AAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;guide&quot;
        title=&quot;&quot;
        src=&quot;/static/bea71d803b581d2cc4ab35a0ab62436b/b9e4f/2.png&quot;
        srcset=&quot;/static/bea71d803b581d2cc4ab35a0ab62436b/cf440/2.png 148w,
/static/bea71d803b581d2cc4ab35a0ab62436b/d2d38/2.png 295w,
/static/bea71d803b581d2cc4ab35a0ab62436b/b9e4f/2.png 590w,
/static/bea71d803b581d2cc4ab35a0ab62436b/f9b6a/2.png 885w,
/static/bea71d803b581d2cc4ab35a0ab62436b/2d849/2.png 1180w,
/static/bea71d803b581d2cc4ab35a0ab62436b/8e427/2.png 1692w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;그제서야 기본 설정 파일이 잘못되어 있는 걸 확인하고는 Telegraf 에 대한 사내 가이드 문서에 위와 같은 내용을 추가하였다. 그러고나서 문득 생각해보니, 이건 PR을 꽁으로 한 번 할 수 있는 기회가 아닌가 하는 생각이 들었다. 나는 곧바로 중복된 설정을 제거하는 내용의 PR을 만들어 올렸고, 명백한 설정 오류였기 때문에 별 문제없이 바로 merge가 되었다. 메인테이너로부터 “Thanks!” 라는 코멘트를 받았다.&lt;/p&gt;
&lt;p&gt;사실 이 코멘트를 보고 기분이 좀 이상했다. 지금껏 밤낮 가리지 않고 열심히 코딩에 매진해오긴 했지만 내가 쓴 코드(사실은 간단한 설정 파일 수정이지만)로 인해 누군가에게 고맙다는 말을 들어본 적이 없었다. 물론 내가 쓴 코드로 회사가 돈을 벌긴 하지만 그렇다고 해서 회사가 내게 고맙다는 말을 해주진 않는다. 대신 월급을 준다. (이 경우엔 당연히 월급이 더 좋다.)&lt;/p&gt;
&lt;p&gt;개인적으로 칭찬에 약한 타입이라 뭔가 Telegraf 프로젝트에 더 기여하고 싶다는 생각이 들었다.&lt;/p&gt;
&lt;p&gt;사실 위에서도 이야기했듯이 이전에도 오픈소스에 대한 기여를 시도해본 적이 몇 번 있었다. 하지만 그 때는 확실히 접근법이 좋지 않았던 것 같다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;오픈소스에 기여를 해보고 싶은데…&lt;/li&gt;
&lt;li&gt;기왕 하는거 좀 크고 유명한 데에 해보고 싶은데…&lt;/li&gt;
&lt;li&gt;크고 유명한 오픈소스 프로젝트를 클론 받는다.&lt;/li&gt;
&lt;li&gt;main 문을 찾아 시작점부터 따라가본다… 3분 후 포기한다.&lt;/li&gt;
&lt;li&gt;공식 문서를 찾아 정독해본다… 30분 후 포기한다.&lt;/li&gt;
&lt;li&gt;해당 프로젝트의 아주 초기 버전을 체크아웃해 다시 소스를 따라가본다… 5분 후 포기한다.&lt;/li&gt;
&lt;li&gt;포기한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;위의 방법은 사실 지금보기에는 오픈소스 기여에 대한 아주 좋지 않은 접근법이라고 생각된다. 사실 기여를 할 오픈소스를 고를 때는 본인이 사용중인 것들 중에서 고르는 것이 제일 유리하다고 생각한다. 나한테는 Telegraf 가 그런 것 중 하나였고, 그 외에도 여러가지로 덤벼볼만한 요소들이 좀 있었다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;실제 사용중인 프로그램&lt;/li&gt;
&lt;li&gt;익숙하게 사용하던 Go 언어로 구현됨&lt;/li&gt;
&lt;li&gt;플러그인 기반이라 코드 파악과 수정이 쉬움&lt;/li&gt;
&lt;li&gt;플로그인 별로 README 문서가 있어 파악에 용이&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이 중에서도 특히 3번이 굉장히 유효했다. 말 그대로 플러그인 기반이기 때문에 Telegraf 의 코어 부분을 손대지 않는 한 다른 코드는 볼 필요없이 내가 고치고 싶은 플러그인의 코드만 보면 됐고 대부분의 경우 플러그인은 하나 내지 두 개의 파일 안에 전부 담겨있다. 게다가 플러그인이 어떤 인터페이스를 가져야 하는지에 대한 부분도 문서에 상세히 설명되어 있으니 코드를 따라가기도 더 쉬웠다.&lt;/p&gt;
&lt;p&gt;게다가 더 좋았던 건, Go 언어를 사용하면서 테스트를 어떻게 작성해야 할 지 고민할 때가 많은데, Telegraf 의 경우에는 테스트 파일들도 잘 구성되어 있어 테스트를 작성하는 요령을 익히기가 좋다는 것이다. (사실 테스트가 없으면 merge 가 안된다.)&lt;/p&gt;
&lt;p&gt;그리고 추가적으로, 새로운 플러그인을 만든 사람의 경우에는 아래와 같이 Release Note에 이름을 박아준다.&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/45e5d1fd578936a3c91ab584ea70f2c5/7b6a0/3.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 101.99456029011786%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAABcSAAAXEgFnn9JSAAACd0lEQVQ4y51UiXLqMAzk/3/vTcuDQC4gl3OR+yDeSgqhobRvOi8zGjtOvN7VSt7UTY0oS5F4F1jWGWnZoKwqibpu0LQt+r6/x4B+GND1I4rmhrLuUdU1xbynbTtstNaYoDG0DfyzC6UiTNOE2+12j0nev8Z40xSf/4080voG96cbRgRJDT9pUNQjrWj8zyMMeXNPgHk9Iau1jAvc/P314eU59CNWgEDTNLAdF4fDEZbtwnFOkrcF9LfxAGy7DkmSIssyARoo+T+xe2b6A2DX9TifLzidyOk0Q1mUBJ4/gtfy/IrrtaC4ysHXong5VExh1/hJ05SkujBNm2Q7VEa2pMDgNFi8ZuN4NLE3DrhcPBQE+JXlDHg/RSkFkzaeiCkDM9skSaDiWA5TkUIQhgiCUBR9Z9pmfQJL8v0AEQGHYYSIAAqSzrFILcsSFRUx/7sGfbi8ZhhFEUk0xW1maJNslsijaVqSBp7PlWBLJ31l+QTIsngTm8M5Y7acp7KsJKTNqnnOYNxq3CVrlpv1Ceys5/mSN84Tz5WKxQAG57VljOOEZOdSvy+Ai8sxAbGDBsn2aOO8ORLgkNLB4J7vC2BI5uSU05ccftZhh5hMSAl0oLm+S3npt28K+4nhstC7LqL3PYLDGdVFoaL3jJKfkxkpjZpKB0kM7XnS52tWzy7zC8/oZy+qYQVX7AwTxtHCn7d3bHcGApIbEPthpFuIFOjlZvjutlkAdazgBwVc1eESUMe4p8dlYRhHuFTk3N+/BySGKq7gpz1iKmw2gsNxHDGhpZtb5LH0H/L5BDiRa+P2L/r9AcNuh57n2y06iubtTUaiCk2H6X8AfgBE8AjmPm+ruwAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;release-note&quot;
        title=&quot;&quot;
        src=&quot;/static/45e5d1fd578936a3c91ab584ea70f2c5/b9e4f/3.png&quot;
        srcset=&quot;/static/45e5d1fd578936a3c91ab584ea70f2c5/cf440/3.png 148w,
/static/45e5d1fd578936a3c91ab584ea70f2c5/d2d38/3.png 295w,
/static/45e5d1fd578936a3c91ab584ea70f2c5/b9e4f/3.png 590w,
/static/45e5d1fd578936a3c91ab584ea70f2c5/f9b6a/3.png 885w,
/static/45e5d1fd578936a3c91ab584ea70f2c5/7b6a0/3.png 1103w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;아직 bugfix 성 밖에 기여를 못해서 여기에 이름을 올리지는 못했지만 조만간 올렸으면 한다.&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;2019-09-04 추가,&lt;/p&gt;
&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/ee140c59e279757c4ed5813e9418053b/04e89/4.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 370px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 22.43243243243243%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsSAAALEgHS3X78AAAAmklEQVQY032O2w6CMBBE+f//I97KtaVUoiVaKEZij0DkQUOcZHb2YXN2ota2nERKVWmyrCBNMqRSPMeREMJfz1pzVdQ5h0hSmuaMkiWJEOja8H22rV/YAlyXuw+YG4wvsNZSG4PWZsrpkaqwV4uUFUUhKaWi93674Tweg0dfBvbK4/oBMzWsP14ApcJMD/K85HAUxPEO57pN4BtyYDQOgxmV4QAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;made-it&quot;
        title=&quot;&quot;
        src=&quot;/static/ee140c59e279757c4ed5813e9418053b/04e89/4.png&quot;
        srcset=&quot;/static/ee140c59e279757c4ed5813e9418053b/cf440/4.png 148w,
/static/ee140c59e279757c4ed5813e9418053b/d2d38/4.png 295w,
/static/ee140c59e279757c4ed5813e9418053b/04e89/4.png 370w&quot;
        sizes=&quot;(max-width: 370px) 100vw, 370px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;됐다.&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[작명의 중요성]]></title><description><![CDATA[개발자들 사이에서 흔히들 하는 농으로 개발하는 시간보다 변수명을 짓는 데 더 시간을 쓴다고들 한다. 변수에 이름 붙이는 게 뭐 그리 어렵겠느냐만 사실 굉장히 어렵기도 하고 또 그만큼 중요하기도 하다. importance of naming…]]></description><link>https://jaeyo.github.io/naming-is-important/</link><guid isPermaLink="false">https://jaeyo.github.io/naming-is-important/</guid><pubDate>Fri, 16 Aug 2019 01:00:08 GMT</pubDate><content:encoded>&lt;p&gt;개발자들 사이에서 흔히들 하는 농으로 개발하는 시간보다 변수명을 짓는 데 더 시간을 쓴다고들 한다. 변수에 이름 붙이는 게 뭐 그리 어렵겠느냐만 사실 굉장히 어렵기도 하고 또 그만큼 중요하기도 하다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://external-preview.redd.it/Vt3LLIlQT7R5a5FS4NV489JWvjcIzOx1Mb2ZTAe_hk0.png?auto=webp&amp;#x26;s=df14a4f3d3aa76c1ea3eea67efd5c1cb7daadbac&quot; alt=&quot;importance of naming variable&quot;&gt;&lt;/p&gt;
&lt;p&gt;얼마전 회사 미팅에서 있었던 일이다. 내부적으로 만든 서비스 중에 Alert Manager 라는 서비스가 있었고, 해당 서비스에 이러이러한 기능을 붙이자는 의견이 나왔다. Alert Manager 에 있음직한 기능이었기 때문에 의견은 받아들여졌고, 그에 대한 논의가 지속되면서 추가하고자 하는 기능의 범위가 넓어졌다. 어느 선부터는 Alert Manager 에 있음직하지 못한, 더 넓은 개념의 기능이었기 때문에 이 기능을 Alert Manager 와 분리시켜서 별도의 서비스를 만들기로 합의했고 그 서비스에 대한 논의를 이어갔다. 하지만 서비스의 이름을 짓지 않은 상태에서 논의하다보니 편의상 새롭게 만들 서비스도 Alert Manager 로 지칭하기 시작했고 나를 포함한 다른 사람들은 혼란을 겪기 시작했다. 지금 논의되고 있는 기능이 원래의 Alert Manager 에 들어가야 하는 건지, 아니면 새롭게 만들 서비스에 들어갈 기능을 이야기하는 건지 헷갈리기 시작했다. 특히 처음부터 논의해 포함되어 있지 않던 사람들의 혼란은 더 컸다. 더이상의 혼란을 방지하기 위해 논의를 잠시 중단시키고 가제라도 이름을 짓고 시작하자고 제의했고, Admin Portal 이라는 이름이 선정되었다. 새로운 이름이 지어진 이후에야 혼란은 줄어들었다. 심지어는 Admin Portal 에 새로 들어감직한 기능들이 더 구체적으로 논의되기 시작했다. 다들 머리속에서 unidentified 상태의 서비스를 구체화시키기 보다는 Admin Portal 이라는 서비스를 구체화시키는 편이 더 쉬운 듯 했다. 문득 작명의 중요성에 대해 다시 한 번 생각해보게 되었다.&lt;/p&gt;
&lt;p&gt;다른 것들과 구별되어야 하는 대상들에는 모두 이름이 붙어 있다. 자동차, 빌딩, 가로등, 거리, 그림, 마우스, 키보드 등등. 그리고 그 이름이라는 것은 그 대상에 대해 이러이러한 이름으로 부르기로 모두와 약속이 된 부분이기 때문에 다른 사람과 소통하기도 쉽다. 자동차라는 이름 없이 “바퀴가 달리고 도로를 달릴 수 있는 교통수단”이라고 부르면 소통 간에 오해의 소지가 생기기 쉽다. 누군가는 오토바이를 상상할지도 모르고, 누군가는 롤러스케이트, 누군가는 리어카를 상상할지도 모르는 일이다. 그것에 대해 “자동차”라고 이름을 붙이기 시작하는 순간 그러한 오해의 소지는 최소화된다. 모두가 같은 대상을 머리속에 그려놓고 이야기를 할 수 있다.&lt;/p&gt;
&lt;p&gt;더욱이 그 “무언가”를 만들어야 하는 사람들에게는 제대로 된 작명이 더 중요하게 된다. “자동차”라는 이름 없이 자동차를 만들어야 하는 조직에서는 자동차를 구체화시키기가 쉽지 않다. 하지만 만들어야 할 대상을 “자동차”로 이름붙이고 나서는 우리가 무엇을 만들어야 하는지가 더욱 분명해진다. 백미러와 사이드 미러가 있어야 하고, 고무로 만들어진 타이어와 사람이 타고 내릴 수 있는 문, 그리고 전방을 볼 수 있는 유리창을 다들 동일하게 머릿속에 떠올릴 것이다.&lt;/p&gt;
&lt;p&gt;하지만 동시에 대상에 이름을 붙이는 것은 그 대상의 범위를 좁혀버리는 일이기도 하다. “자동차”를 만들기로 한 팀은 아마도 엔진과 연료의 효율 등에 자연스레 신경을 더 쓰게 될 것이다. 자동차 안에 무엇이 포함될 지는 더이상 이야기하지 않을 것이다. 자동차 안에 포함된 건 당연히 사용자가 않을 시트와 짐을 싣을 트렁크 뿐이니까. 하지만 “자동차”라는 이름의 한계를 뚫고 그 안에 주방과 화장실과 침대를 넣자는 아이디어가 어쩌면 그들에게는 더 필요한 방향일 수도 있다. (그리고 그 대상은 “캠핑카”라는 새로운 이름을 얻게 될 것이다.) 하지만 “자동차”라는 이름의 한계를 뚫기는 쉽지 않다.&lt;/p&gt;
&lt;p&gt; 대상에 이름을 붙이는 순간 그것이 상상력의 여지를 닫아버리는 효과도 있다는 것을 생각하게 되었다. 그래서 더 이름을 붙이는 문제가 중요하게 느껴졌다. 20대의 대학교 4학년에 재학중인 누군가에게 “대학교 졸업반”이라는 이름을 붙여버리는 그는 어째선가 취업 준비를 해야 할 것만 같다. 하지만 그에게 “청춘”이라는 이름을 붙이는 그는 래퍼가 될 수도 있고, 장사꾼이 될 수 도 있고, 또 다른 무언가가 될 수도 있다. 물론 백수가 될 수도 있다. &lt;/p&gt;
&lt;p&gt;어떤 대상에 이름을 붙이는 건 그 대상의 구체성을 높이는 반면, 그 대상의 한계를 규정지어 버리는 효과도 있다. 똑같이 월급을 받으며 코드를 짜는 개발자들도 그들 자신을 “월급쟁이” 혹은 “샐러리맨”으로 규정짓는 사람들과 “개발자” 혹은 “소프트웨어 엔지니어”로 규정짓는 사람들과는 조금 거리가 있어 보인다. 그래서 이름을 붙이는 데이는 적지 않은 고민이 필요하고, 또 이름이 붙여진 이후에도 그 이름이 주는 한계에 갇히지 않고 가능성의 여지를 계속해서 만들려고 노력해야 한다는 생각을 했다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[새로운 곳으로 이사]]></title><description><![CDATA[약…]]></description><link>https://jaeyo.github.io/move-to-another-place/</link><guid isPermaLink="false">https://jaeyo.github.io/move-to-another-place/</guid><pubDate>Thu, 15 Aug 2019 01:00:00 GMT</pubDate><content:encoded>&lt;p&gt;약 2년간의 관악구 생활을 마치고 용인으로 이사를 가기로 했다.&lt;/p&gt;
&lt;p&gt;애초에 이 곳으로 이사를 오게 되었던 이유는,&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;아무래도 서울 안의 인프라가 더 많으니까&lt;/li&gt;
&lt;li&gt;처가가 가까우니까&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;였는데, 중간에 차를 사고 나니 이런 것들이 크게 의미가 없어져버렸다. 주말이나 휴일에 항상 차를 타고 다니게 되면서 서울 안쪽 보다는 바깥쪽으로 매번 나돌았고, 사람들이 그득그득한 시내보다는 고즈넉하고 여유로운 풍경들을 즐기기 시작했다. 거기다 아무래도 차가 있으니 처가에서 좀 멀어진다고 해도 방문하기에 크게 무리가 없기도 하고.&lt;/p&gt;
&lt;p&gt;다음 이사지로 용인을 고른 것은 아무래도 직장의 영향이 컸다. 내 경우에 지금 직장은 분당, 그리고 이직을 해봤자 판교나 멀어도 강남 정도에 떨어지게 될 것이다. 아내도 강동구로 출퇴근을 하게 될 예정이었기 때문에 용인은 여러모로 괜찮은 선택지였다. 거기다 오히려 경기도라서 더 메리트가 있다고 느껴졌다. 사실 가능하다면 아예 경기도 조차도 벗어나고 싶다는 생각을 했다.&lt;/p&gt;
&lt;p&gt;이런 생각을 가지게 된 건 원주에 사는 처형네를 종종 방문하면서 부터 였다. 서울 근교 지역과 비교해 크게 저렴한 집값과 더불어, 주변에 아이를 데리고 산책을 할 수 있는 공원이 있는 것도 부러웠고, 무엇보다 차를 타게 된다는 가정 하에 주변에 필요한 인프라는 모두 갖추어져 있었다. 사실 개발자라는 직업을 놓기 전까지는 원주 같은 곳으로의 이사는 무리지만 아무래도 용인 정도면 비슷한 메리트들을 누릴 수 있지 않을까 하는 생각이다.&lt;/p&gt;
&lt;p&gt;사실 이러한 생각의 연장선으로 요즘에는 풀 리모트 근무에 대한 희망을 가지고 있기도 하다. 리모트 근무를 하게 된다고 해도 어차피 집에서 일을 하기에는 무리가 있을테니 코워킹 플레이스 같은 곳으로 출근을 하긴 해야 할 것이다. 하지만 매일 아침, 사람들로 그득그득한 지옥철이나 차들이 그득그득한 도로로 향하지 않고 내가 마음에 드는 곳으로 출근을 할 수 있는 생활이 굉장히 매력적으로 느껴졌다. 매일같이 느껴지는 사무실의 갑갑함에서 벗어나는 것 만으로도 삶의 질이 굉장히 오를 것으로 생각한다.&lt;/p&gt;
&lt;p&gt;예전부터 사무실에서 근무를 하다 문득 갑갑함이 느껴질 때는 유튜브에서 오토바이 투어링 영상을 틀어놓곤 했다. 뻥뻥 뚫린 국도를 달리는 오토바이 영상을 보고 있기만 해도 답답한 마음이 조금은 풀어지고는 했다. 하지만 풀 리모트 근무를 하게 된다면 이러한 희망 사항을 현실로 이룰 수 있을 것이다. 아침마다 나는 출근할 사무실을 정할 수 있다. 어느 날에는 홍대의 코워킹 플레이스로, 혹은 가평 근처 어딘가의 적당한 백색 소음이 있는 까페로.&lt;/p&gt;
&lt;p&gt;요즘 많은 기술 기업이나 스타트업들이 풀 리모트들을 하나 둘 씩 받아들이고 있다. 특히 글로벌 테크 기업의 경우에는 우리나라의 경우보다 더 적극적으로 리모트 근무를 적용하고 있다. 사실 리모트 근무 하나만 놓고 보자면 국내 기업 보다는 글로벌 기업들을 노리는 것이 더 확률이 높을 것이다. 하지만 마지막까지 걸리는 것은 언제나 영어였다. 종종 친구들과 ‘영어가 지금까지 내 발목을 잡을 줄은 몰랐다’라고 농을 주고받곤 했는데, 언젠가 넘긴 넘어야 하는 벽이라고 생각한다. 그래서 일주일이 한번씩 지인과 영어 회화 스터디를 하고 있긴 하다. 하지만 어느 순간에는 학원이나 과외같은 전문가의 도움을 받아야 하겠다 라는 생각도 하고 있다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Git - branch 삭제 후 push]]></title><description><![CDATA[git에서 브랜치를 따서 작업을 하고 머지된 이후에는 자연스레 작업 브랜치는 날리게 된다. Github 의 풀 리퀘스트 같은 수단을 이용하게 되면 머지 이후에  버튼을 통해 쉽게 remote…]]></description><link>https://jaeyo.github.io/git-delete-branch-and-push/</link><guid isPermaLink="false">https://jaeyo.github.io/git-delete-branch-and-push/</guid><pubDate>Wed, 14 Aug 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;git에서 브랜치를 따서 작업을 하고 머지된 이후에는 자연스레 작업 브랜치는 날리게 된다. Github 의 풀 리퀘스트 같은 수단을 이용하게 되면 머지 이후에 &lt;code class=&quot;language-text&quot;&gt;Delete Branch&lt;/code&gt; 버튼을 통해 쉽게 remote 상의 브랜치를 제거할 수 있으나 로컬에서 바로 머지한 경우에는 로컬의 브랜치와 remote 의 브랜치를 모두 제거해주어야 한다. 헌데 로컬 브랜치 제거는 괜찮은데 remote 브랜치 제거 명령어를 항상 까먹는다.&lt;/p&gt;
&lt;p&gt;명령어는 아래와 같다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token function&quot;&gt;git&lt;/span&gt; branch -D branch-name  &lt;span class=&quot;token comment&quot;&gt;# local branch 제거&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;git&lt;/span&gt; push origin :branch-name &lt;span class=&quot;token comment&quot;&gt;# remote branch 제거&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;remote 브랜치 제거 명령어를 매번 까먹어서 매번 찾아서 하다가 이걸 그냥 alias 를 걸어놔야 되겠다고 생각했다. 기왕 alias 거는거 local + remote 둘 다 한 번에 제거하게끔 계획했다. 이 과정에서 제거할 브랜치 이름을 argument 로 받아야 하는데 문제는 git alias 에서는 argument 를 지원하고 있지 않다는 것이다. 이 부분을 해결하기 위해 구글링을 해봤지만 뭔가 elegant 한 방법은 찾지 못했고 아래와 같이 구성하였다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;alias&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;dd&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;!f() {  git branch -D &lt;span class=&quot;token variable&quot;&gt;$1&lt;/span&gt; &amp;amp;&amp;amp; git push origin :&lt;span class=&quot;token variable&quot;&gt;$1&lt;/span&gt;; }; f&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[오늘의 삽질 - 괜히 Bash 만 의심했다.]]></title><description><![CDATA[회사에서 만들어놓은 쉘 스크립트가 있었다. 필요한 패키지를 다운로드받아 설치하고 설정파일을 고치고 systemctl 로 띄우는 내용의 스크립트로 대략적인 모양새는 아래와 같다. 위의 스크립트에 따르면 아래의 로직을 타게 된다. curl 로 blabla…]]></description><link>https://jaeyo.github.io/bash-is-not-async/</link><guid isPermaLink="false">https://jaeyo.github.io/bash-is-not-async/</guid><pubDate>Tue, 13 Aug 2019 01:00:00 GMT</pubDate><content:encoded>&lt;p&gt;회사에서 만들어놓은 쉘 스크립트가 있었다. 필요한 패키지를 다운로드받아 설치하고 설정파일을 고치고 systemctl 로 띄우는 내용의 스크립트로 대략적인 모양새는 아래와 같다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token function-name function&quot;&gt;install_blabla&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;token assign-left variable&quot;&gt;dest&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token variable&quot;&gt;&lt;span class=&quot;token variable&quot;&gt;$(&lt;/span&gt;mktemp /tmp/blabla_XXXX.deb&lt;span class=&quot;token variable&quot;&gt;)&lt;/span&gt;&lt;/span&gt;
	&lt;span class=&quot;token function&quot;&gt;curl&lt;/span&gt; -fsSL http://blabla.com/blabla.deb -o &lt;span class=&quot;token variable&quot;&gt;$dest&lt;/span&gt;
	dpkg -i &lt;span class=&quot;token variable&quot;&gt;$dest&lt;/span&gt;
	&lt;span class=&quot;token function&quot;&gt;rm&lt;/span&gt; -f &lt;span class=&quot;token variable&quot;&gt;$dest&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token function-name function&quot;&gt;install_conf&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;token function&quot;&gt;curl&lt;/span&gt; -fsSL http://blabla.com/blabla.conf -o /etc/blabla/blabla.conf
	&lt;span class=&quot;token function&quot;&gt;sed&lt;/span&gt; -i -e &lt;span class=&quot;token string&quot;&gt;&quot;...&quot;&lt;/span&gt; /etc/blabla/blabla.conf
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token function-name function&quot;&gt;start_blabla&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	systemctl start blabla
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token function-name function&quot;&gt;do_install&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	install_blabla
	install_conf
	start_blabla
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

do_install&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 스크립트에 따르면 아래의 로직을 타게 된다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;curl 로 blabla.deb 다운로드&lt;/li&gt;
&lt;li&gt;dpkg 로 blabla.deb 설치&lt;/li&gt;
&lt;li&gt;curl 로 blabla.conf 다운로드&lt;/li&gt;
&lt;li&gt;sed 로 blabla.conf 내용 수정&lt;/li&gt;
&lt;li&gt;systemctl 로 blabla 시작&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이 로직대로 정상 작동 한다면 blabla는 수정된 설정파일을 정상적으로 물고 떠야한다. 하지만 blabla가 이상 동작을 한다는 이슈가 리포팅되었고, 확인 결과 수정된 설정파일이 아니라 기본 설정 파일을 물고 뜨는 것으로 의심이 되는 상황이었다.&lt;/p&gt;
&lt;p&gt;하지만 아무리 확인을 해봐도 설정파일은 정상적으로 수정되어 있었고, 그렇다고 다른 path의 설정 파일을 물고 있는 상황도 아니었다.&lt;/p&gt;
&lt;p&gt;순간 머리속을 스치는 의심 하나,&lt;/p&gt;
&lt;p&gt;“모종의 알 수 없는 이유로 blabla.conf 파일 다운로드가 채 끝나기 전에 다음 구문이 실행되었다면?”&lt;/p&gt;
&lt;p&gt;그래서 blabla를 재기동해보았고 정상적으로 수정된 설정 파일을 잘 물고 뜨는 걸 확인할 수 있었다. 갑작스레 혼란이 밀려왔다.&lt;/p&gt;
&lt;p&gt;“아니, 무슨 bash가 node.js 도 아니고 상황에 따라서 curl 명령이 끝나기 전에 다음 구문으로 넘어갈 수가 있나? 무슨 bash가 async야?”&lt;/p&gt;
&lt;p&gt;혹시나 싶어서 구글링을 해봤지만 걸리는 건 없었고 사건이 터진 이유를 알 수 없어 혼란스러워 하던 즈음, 옆 동료 분이 원인을 정확하게 짚어주셨다.&lt;/p&gt;
&lt;p&gt;“이거 dpkg 로 설치하고 바로 뜨는 것 같은데요.”&lt;/p&gt;
&lt;p&gt;문제는 당연히 bash 가 async 로 동작했다거나 그런게 아니었고 ubuntu 기준으로 dpkg로 설치되는 패키지는 서비스가 포함되어 있으면 자동으로 enabled &amp;#x26;&amp;#x26; started 되는 현상이었다.&lt;/p&gt;
&lt;p&gt;괜히 의심했던 것 같아 bash 에게 사과를…&lt;/p&gt;</content:encoded></item><item><title><![CDATA[No title]]></title><description><![CDATA[회의의 목적과 문맥과 내용과 구성을 도무지 알 수 없는 회의를 두 시간 가까이 하고 들어왔는데 들어보니 어른들의 사정 때문에 생긴 회의. 피곤.]]></description><link>https://jaeyo.github.io/what-the-f-dpkg copy/</link><guid isPermaLink="false">https://jaeyo.github.io/what-the-f-dpkg copy/</guid><pubDate>Tue, 13 Aug 2019 01:00:00 GMT</pubDate><content:encoded>&lt;p&gt;회의의 목적과 문맥과 내용과 구성을 도무지 알 수 없는 회의를 두 시간 가까이 하고 들어왔는데 들어보니 어른들의 사정 때문에 생긴 회의. 피곤.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[연봉과 연차의 무게]]></title><description><![CDATA[“이제는 단순 개발만 하고 기능구현만 하는 것이 아니라 그 이상을 해야 할 시기가 다가온다.” “사람들 관리가 될 수도 있고 어느 한 분야에 전문가가 되어야 할 수도 있고, 선택은 본인의 몫” (from https://taetaetae.github…]]></description><link>https://jaeyo.github.io/better-than-yesterday/</link><guid isPermaLink="false">https://jaeyo.github.io/better-than-yesterday/</guid><pubDate>Tue, 13 Aug 2019 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;“이제는 단순 개발만 하고 기능구현만 하는 것이 아니라 &lt;strong&gt;그 이상&lt;/strong&gt;을 해야 할 시기가 다가온다.”&lt;/p&gt;
&lt;p&gt;“사람들 관리가 될 수도 있고 어느 한 분야에 전문가가 되어야 할 수도 있고, 선택은 본인의 몫”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;(from &lt;a href=&quot;https://taetaetae.github.io/2019/07/07/review-first-half-2019/&quot;&gt;https://taetaetae.github.io/2019/07/07/review-first-half-2019/&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;회사생활을 시작하고나서 이런 생각을 꽤 오랫동안 해왔던 것 같다. 처음은 아마도 개발자 생활을 막 시작했을 신입 무렵이었던 것 같다. 회사에서 내게 요구하는 역량은 나는 한참 못미쳐있었고, 나름 그래도 대학시절 코드 좀 쓴다고 자부했던 내 자존감은 앓는 이처럼 흔들흔들거리고 있었다. 그 시절, 나는 하루에도 몇 번 씩이나 회사에서 내게 요구하는 기대치와 현재 나의 레벨에 대해서 생각했다. 나는 과연 월급값을 하고 있을까, 신입사원에게 실수는 어디까지 용납이 될까, 6개월 정도 되면 신입사원 딱지를 떼고 오롯이 한 사람 몫을 할 수 있어야 하지 않을까, 하는 생각들로 나를 채찍질했다. 그리고 퇴근시간이면 내게 항상 자문했다. “나는 오늘 일급만큼의 일을 했나? 내가 만약 나를 고용했다면, 오늘의 내게 이 정도의 돈을 줄 수 있나?”&lt;/p&gt;
&lt;p&gt;첫 번째 이직을 하던 즈음에는 조금 더 심해졌다. “여기서 나는 어떤 롤을 수행해야 하나, 면접 때 내게 질문을 던지던 CTO 님은 내게 어떤 기대치를 가지고 있으며 나는 거기서 어디까지 충족하고 있을까”. 이러한 고민들이 때로는 내게 비타민이 되기도 했지만 종종 내 자존감을 수렁에 빠뜨리기도 했다. 그러면서도 계속해서 내가 만족시켜야 할 기대치에 대해 생각했다.&lt;/p&gt;
&lt;p&gt;나는 조직에 두 종류의 사람이 있어야 한다고 생각한다. 우리가 어디로, 어떻게 가야 하는지에 대한 물음에 의사결정을 해주는 사람, 그리고 실제로 그 곳으로 다다르기 위해 페달을 밟는 사람. 전자는 일반적으로 “장”의 지위를 가지고 있고, 후자는 실무자 정도가 될 수 있을 것 같다. 그리고 누구나 실무자에서 시작해 대리, 과장, 차장 등의 직급의 계단을 하나씩 넘어가면서 점점 더 중요한 의사결정을 해야하는 권한과 책임을 짊어지게 된다. 요즘들어 나는 그것이 점차로 높아지는 연봉의 무게가 아닐까 하는 생각을 한다.&lt;/p&gt;
&lt;p&gt;대부분의 사람들이 신입 딱지를 떼면 한 사람 분의 일을 오롯이 해낸다. 거기에 2 ~ 3년 정도의 연차가 붙으면 베테랑이라 부를만큼 일을 빠르고 효율적으로 해낸다. 하지만 이러한 업무 효율이 계속해서 선형적으로 증가하지는 않고 해봐야 5년차 정도 이후에는 최대치에 다다르는 것 같다. 그렇다고 해서 회사가 5년차 이후의 직원들에게 연봉을 동결시키지는 않는다. 매년 연봉을 올려주고 더 높은 직급을 달아주는 것은, 단순히 효율 높게 업무를 진행하는 것 이상의 플러스 알파를 개인에게 기대하기 때문이라고 생각한다. 여기서 플러스 알파가 무엇인지는 회사에 따라, 직군에 따라, 팀에 따라 모두 다를 것이다. 심지어는 같은 조직 안에 있는 각 개인 별로도 다를 수 있다. 각자 자신만의 무기를 갈고 닦아서 회사에 자신의 존재 이유를 증명해내야 하기 때문이다.&lt;/p&gt;
&lt;p&gt;이 무기를 계속해서 찾아내고 갈고 닦지 않으면 어느 순간에는 평범하게 영위하던 일상을 손가락 사이의 모래처럼 잃을 수도 있다는 다소의 불안감을 가지고 있다. 일상을 지속시키기 위한 대가가 이다지도 크다는 것이 사회초년생 시절에는 생경하게 느껴지기도 했지만, 그동안 적지 않게 먹은 회사 짬밥 덕분일까 이제는 뭐 크게 이상하지도 않다.&lt;/p&gt;
&lt;p&gt;지금 내가 갈고 닦고 있는 무기는 도메인이다. 단순히 코드를 깔끔하게 잘 뽑아낸다 정도는 이미 이 연차에서는 기본으로 깔고, 특정 도메인에 대한 지식과 경험들을 쌓아놓는 것이 지금 이 시점에 내가 가져볼만한 무기가 될 수 있을 것 같다. 그 도메인을 나는 클라우드와 모니터링으로 잡았고, 그에 따라서 회사도 지금 다니고 있는 곳으로 이직하게 되었다.&lt;/p&gt;
&lt;p&gt;그 다음 무기는 무엇이 될지 아직 고민 중이다. 단순히 생각해서 내게 지금 부족한 면들을 채우면 되지 않나 라는 생각도 들었지만, 단순히 단점을 채우기보다 장점을 갈고 닦는게 정답일 수도 있겠다는 생각도 든다. 이 고민에 대한 나름의 답을 내년 정도에는 가질 수 있으면 하고 희망한다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[No title]]></title><description><![CDATA[ubuntu 에서 dpkg 로 패키지 인스톨 후 설정파일 고치고 systemctl 로 올리는 스크립트를 짰는데 자꾸 고치기 이전 설정을 물고 올라가는 문제 발생. 알고보니 dpkg 에서 설치를 끝내자마자 바로 서비스를 올려버리네…]]></description><link>https://jaeyo.github.io/what-the-f-dpkg/</link><guid isPermaLink="false">https://jaeyo.github.io/what-the-f-dpkg/</guid><pubDate>Tue, 13 Aug 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;ubuntu 에서 dpkg 로 패키지 인스톨 후 설정파일 고치고 systemctl 로 올리는 스크립트를 짰는데 자꾸 고치기 이전 설정을 물고 올라가는 문제 발생. 알고보니 dpkg 에서 설치를 끝내자마자 바로 서비스를 올려버리네…&lt;/p&gt;</content:encoded></item><item><title><![CDATA[No title]]></title><description><![CDATA[요몇일 timeseries 기반의 anomaly detection 을 통해 유의미한 결과물을 만들 수 있지 않을까 해서 찾아보고 있었다. 충분히 검증된 알고리즘들을 가지고 더미데이터를 붙여서 테스트를 해본 결과 확실히 outlier…]]></description><link>https://jaeyo.github.io/log-anomaly-detection/</link><guid isPermaLink="false">https://jaeyo.github.io/log-anomaly-detection/</guid><pubDate>Wed, 07 Aug 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;요몇일 timeseries 기반의 anomaly detection 을 통해 유의미한 결과물을 만들 수 있지 않을까 해서 찾아보고 있었다. 충분히 검증된 알고리즘들을 가지고 더미데이터를 붙여서 테스트를 해본 결과 확실히 outlier 를 잡아내는데는 효과가 있다는 확신을 가질 수 있었다.&lt;/p&gt;
&lt;p&gt;헌데 곰곰히 생각해보니 장애 발생시 정말 크리티컬한 경우를 제외하고는 timeseries 기반의 메트릭으로 표현되지 않는 장애들이 더 많지 않나 하는 생각이 문득 들었다. 거기다 어쩌면 메트릭 기반의 모니터링은 사실 블랙박스 모니터링에 가깝기 때문에 실제 root cause 를 확인하려면 어차피 로그를 까봐야하는 경우들이 많고 그쯤에서 로그 기반의 anomaly detection 도 가능하지 않을까 하는 생각이 들었다. 슬쩍 구글링해보니 이 쪽으로도 찾아볼만한 자료들이 좀 보이는 것 같아 좀 파봐야겠다고 생각했다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[No title]]></title><description><![CDATA[오전까지는 커피 한잔만 마셔주면 날아다닐 정도로 컨디션이 좋은데 점심먹고 오면 퍼포먼스가 급 떨어진다.]]></description><link>https://jaeyo.github.io/one-coffee/</link><guid isPermaLink="false">https://jaeyo.github.io/one-coffee/</guid><pubDate>Mon, 24 Jun 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;오전까지는 커피 한잔만 마셔주면 날아다닐 정도로 컨디션이 좋은데 점심먹고 오면 퍼포먼스가 급 떨어진다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[No title]]></title><description><![CDATA[node.js로 만들어놓은 백엔드를 typescript 로 포팅했다. 기존에 가지고 있던 node.js로 인한 아쉬운 부분들이 전부 해소되었다. 러닝커브가 그리 놓지도 않으니 이젠 ts를 쓰지 않아야 될 이유를 찾는게 더 어려울 것 같다.]]></description><link>https://jaeyo.github.io/ts-is-better-than-js/</link><guid isPermaLink="false">https://jaeyo.github.io/ts-is-better-than-js/</guid><pubDate>Sun, 16 Jun 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;node.js로 만들어놓은 백엔드를 typescript 로 포팅했다. 기존에 가지고 있던 node.js로 인한 아쉬운 부분들이 전부 해소되었다. 러닝커브가 그리 놓지도 않으니 이젠 ts를 쓰지 않아야 될 이유를 찾는게 더 어려울 것 같다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[No title]]></title><description><![CDATA[타입스크립트를 학습하면서 이전에 만들었던 node.js 앱을 포팅해보고있다. 재미있고 걱정했던 .d.ts 작성도 그렇게 까다롭지 않다.]]></description><link>https://jaeyo.github.io/porting-js-to-ts/</link><guid isPermaLink="false">https://jaeyo.github.io/porting-js-to-ts/</guid><pubDate>Mon, 03 Jun 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;타입스크립트를 학습하면서 이전에 만들었던 node.js 앱을 포팅해보고있다. 재미있고 걱정했던 .d.ts 작성도 그렇게 까다롭지 않다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[No title]]></title><description><![CDATA[스프링은 쓸 때마다 쓰기가 싫다.]]></description><link>https://jaeyo.github.io/hate-spring/</link><guid isPermaLink="false">https://jaeyo.github.io/hate-spring/</guid><pubDate>Fri, 26 Apr 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;스프링은 쓸 때마다 쓰기가 싫다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[No title]]></title><description><![CDATA[snmp로 네트워크 장비의 상태를 수집하고 있다. 인프라를 클라우드로 배워서 vyatta 니 snmp니 하는 것들은 영 생소하다.]]></description><link>https://jaeyo.github.io/collecting-snmp-metrics/</link><guid isPermaLink="false">https://jaeyo.github.io/collecting-snmp-metrics/</guid><pubDate>Wed, 24 Apr 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;snmp로 네트워크 장비의 상태를 수집하고 있다. 인프라를 클라우드로 배워서 vyatta 니 snmp니 하는 것들은 영 생소하다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[No title]]></title><description><![CDATA[…]]></description><link>https://jaeyo.github.io/hate-multitasking/</link><guid isPermaLink="false">https://jaeyo.github.io/hate-multitasking/</guid><pubDate>Sat, 13 Apr 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;개발 외적인 일들 때문에 하루종일 정신없이 매달려있어 아직 오늘 하고자 했던 걸 하나도 하지 못했다. 월급쟁이 입장에서 개발이던 아니던 어쨌든 일은 일이니 불평은 할 수 없겠다만 한 번에 하나의 일만 신경쓰고 싶다. 여러개이 이슈를 동시에 신경쓰고 있어야 하니 집중력이 너무 떨어진다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[No title]]></title><description><![CDATA[모니터링 솔루션으로 와탭을 검토하고 있다. 외산 뒤지지 않는 퀄리티에 한번 놀랬고 굉장히 적은 인원이라는데 두번 놀랬다. 그리고 자사 서비스에 대한 자신감에 굉장히 높다고 느껴지는데 이런 부분들이 좀 부러웠다.]]></description><link>https://jaeyo.github.io/whatap/</link><guid isPermaLink="false">https://jaeyo.github.io/whatap/</guid><pubDate>Fri, 05 Apr 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;모니터링 솔루션으로 와탭을 검토하고 있다. 외산 뒤지지 않는 퀄리티에 한번 놀랬고 굉장히 적은 인원이라는데 두번 놀랬다. 그리고 자사 서비스에 대한 자신감에 굉장히 높다고 느껴지는데 이런 부분들이 좀 부러웠다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[No title]]></title><description><![CDATA[기존에 작성된 리액트앱에서 ie11도 지원하기 위해 바벨 플러그인을 덕지덕지 붙이는 중. 그동안 운이 좋았는지  ie 지원은 이번에 처음 해보는데 ie11이면 ie…]]></description><link>https://jaeyo.github.io/react-on-ie11/</link><guid isPermaLink="false">https://jaeyo.github.io/react-on-ie11/</guid><pubDate>Thu, 04 Apr 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;기존에 작성된 리액트앱에서 ie11도 지원하기 위해 바벨 플러그인을 덕지덕지 붙이는 중. 그동안 운이 좋았는지  ie 지원은 이번에 처음 해보는데 ie11이면 ie 중에는 비교적 최신 버전임에도 불구하고 생각보다 안돌아가는 기능이 많아서 놀랬다.&lt;/p&gt;
&lt;p&gt;async await 은 기대도 안했건만 promise도 없다니. 근데 다른 분들도 이런식으로 바벨 플러그인 덕지덕지 펴바르는 방식으로 해결보는지 궁금하다.&lt;/p&gt;
&lt;p&gt;더불어 앞으로도 계속 코드는 앵간하면 백엔드쪽만 짜고 프론트엔드는 백오피스 정도만 손대는게 정신건강에 좋겠다고 생각했다.&lt;/p&gt;
&lt;p&gt;이 모든건 사실 폴리필을 붙이면 대부분 해결되는 문제지만 환경상 폴리필을 쓸 수가 없어서..&lt;/p&gt;</content:encoded></item><item><title><![CDATA[No title]]></title><description><![CDATA[on prem 으로 직접 서버를 운영하는데에서 cloud(IaaS)를 거쳐서 container 기반의 환경까지 왔는데 다음은 뭘까 새삼 궁금해진다.]]></description><link>https://jaeyo.github.io/what-is-next-over-container/</link><guid isPermaLink="false">https://jaeyo.github.io/what-is-next-over-container/</guid><pubDate>Mon, 11 Mar 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;on prem 으로 직접 서버를 운영하는데에서 cloud(IaaS)를 거쳐서 container 기반의 환경까지 왔는데 다음은 뭘까 새삼 궁금해진다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[No title]]></title><description><![CDATA[요즘 고민중인거. 다수의 telegraf 를 관리하기 위한 방안으로 원래는 커스텀 input plugin 을 짜는 방향을 생각했었는데 telegraf…]]></description><link>https://jaeyo.github.io/manage-telegraf/</link><guid isPermaLink="false">https://jaeyo.github.io/manage-telegraf/</guid><pubDate>Mon, 04 Mar 2019 01:00:00 GMT</pubDate><content:encoded>&lt;p&gt;요즘 고민중인거. 다수의 telegraf 를 관리하기 위한 방안으로 원래는 커스텀 input plugin 을 짜는 방향을 생각했었는데 telegraf  메인 소스에 내 코드를 추가하는 건 아무래도 관리부담이 있으므로 별도로 에이전트를 짜고 이를 exec input plugin 으로 구동시키는 방향으로 고민중&lt;/p&gt;</content:encoded></item><item><title><![CDATA[No title]]></title><description><![CDATA[go 언어로 데몬을 짤땐 DI패턴을 적용하기 위해서 별도의 instance container 를 습관처럼 만드는데 너무 verbose 해져서 고민. 하지만 쓸만한 DI 라이브러리를 찾지도 못해서 아직 대안이 없다. go2 에서 generic…]]></description><link>https://jaeyo.github.io/golang-di/</link><guid isPermaLink="false">https://jaeyo.github.io/golang-di/</guid><pubDate>Mon, 04 Mar 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;go 언어로 데몬을 짤땐 DI패턴을 적용하기 위해서 별도의 instance container 를 습관처럼 만드는데 너무 verbose 해져서 고민. 하지만 쓸만한 DI 라이브러리를 찾지도 못해서 아직 대안이 없다. go2 에서 generic이 나올 때 까지는 버텨봐야할 것 같나.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[qmk_firmware 빌드 시에 chibios 관련 에러 발생]]></title><description><![CDATA[는 programmable한 여러 키보드들을 지원하는 오픈소스 펌웨어다. 이 펌웨어가 지원하는 대표적인 키보드는 planck, ergodox 등이 있다.
documentation 및 자세한 정보는 https://qmk.fm…]]></description><link>https://jaeyo.github.io/error-while-building-qmk_firmware/</link><guid isPermaLink="false">https://jaeyo.github.io/error-while-building-qmk_firmware/</guid><pubDate>Tue, 16 Oct 2018 10:34:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;qmk_firmware&lt;/code&gt;는 programmable한 여러 키보드들을 지원하는 오픈소스 펌웨어다. 이 펌웨어가 지원하는 대표적인 키보드는 planck, ergodox 등이 있다.
documentation 및 자세한 정보는 &lt;a href=&quot;https://qmk.fm/&quot;&gt;https://qmk.fm/&lt;/a&gt; 에서 확인할 수 있다.
처음 이 소스를 clone 받아서 빌드를 하기 위해서 documentation을 보면 아래와 같이 가이드를 해준다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;$ make &amp;lt;my_keyboard&amp;gt;:&amp;lt;my_keymap&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;하지만 그대로 따라치면 아래와 같은 에러를 볼 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;$ make ergodo_infinity:default

tmk_core/chibios.mk:38: lib/chibios-contrib/os/common/startup/ARMCMx/compilers/GCC/mk/startup_k20x7.mk: No such file or directory
tmk_core/chibios.mk:40: lib/chibios/os/hal/hal.mk: No such file or directory
tmk_core/chibios.mk:46: lib/chibios-contrib/os/hal/ports/KINETIS/K20x/platform.mk: No such file or directory
tmk_core/chibios.mk:78: lib/chibios-contrib/os/hal/boards/PJRC_TEENSY_3_1/board.mk: No such file or directory
tmk_core/chibios.mk:79: lib/chibios/os/hal/osal/rt/osal.mk: No such file or directory
tmk_core/chibios.mk:81: lib/chibios/os/rt/rt.mk: No such file or directory
tmk_core/chibios.mk:87: lib/chibios/os/common/ports/ARMCMx/compilers/GCC/mk/port_v7m.mk: No such file or directory
tmk_core/chibios.mk:89: lib/chibios/os/hal/lib/streams/streams.mk: No such file or directory
quantum/visualizer/visualizer.mk:77: lib/ugfx/gfx.mk: No such file or directory
make[1]: *** No rule to make target `lib/ugfx/gfx.mk&amp;#39;.  Stop.
make: *** [ergodox_infinity:default] Error 1&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이는 submodule이 적절히 업데이트 되지 않아 발생하는 문제다.
따라서 아래의 명령어로 submodule을 업데이트 시켜주면 정상적으로 다시 빌드를 할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;$ make git-submodule&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;혹은 아래의 두 명령어도 같은 역할을 한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;$ git submodule sync --recursive
$ git submodule update --init --recursive --progress&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[reselect]]></title><description><![CDATA[https://github.com/reactjs/reselect reselect는 redux에 붙여서 쓸 수 있는 selector 라이브러리로 역할은 아래의 두 가지로 정리된다. 컴포넌트를 redux에 connect 시킬 때 store…]]></description><link>https://jaeyo.github.io/reselect/</link><guid isPermaLink="false">https://jaeyo.github.io/reselect/</guid><pubDate>Sat, 06 Oct 2018 11:44:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;reselect&quot;&gt;https://github.com/reactjs/reselect&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;reselect는 redux에 붙여서 쓸 수 있는 selector 라이브러리로 역할은 아래의 두 가지로 정리된다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;컴포넌트를 redux에 connect 시킬 때 store로부터 데이터를 꺼내와서 매핑시키는 부분 추상화&lt;/li&gt;
&lt;li&gt;selector 함수에서 반환되는 값을 캐싱하여 성능 향상&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;가령 아래와 같은 코드가 있다고 가정하면,&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;mapStateToProps&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;state&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; ownProps&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; contentIds &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; state&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;userContent&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
		contentIds&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;reselect를 붙여 아래와 같은 형태로 정리할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// selector&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;getUserContent&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; state&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;userContent&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; selectUserContentIds &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;createSelector&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt; getUserContent &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// input selector&lt;/span&gt;
	&lt;span class=&quot;token parameter&quot;&gt;userContent&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; userContent&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;contentIds
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;//component&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;mapStateToProps&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;state&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; ownProps&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	contentIds&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;selectUserContentIds&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;state&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이러한 형태에서 먼저 눈에 띄는 장점은 컴포넌트 단에서 redux store의 구조를 알 필요없이 selector 만 호출할 수 있다는 점이다.
이외에도 reselect는 memoized selector 를 통해서 성능 향상을 꾀할 수 있다.&lt;/p&gt;
&lt;p&gt;여기서 주의할 점은, 만약 리스트 형태의 컴포넌트에서 selector를 사용할 경우 각 리스트 아이템마다 필요로 하는 데이터가 다르게 되기 떄문에 정상적으로 memoized 되지 않는다는 점이다. 이 경우에는 selector를 생성하는 로직을 함수로 한번 래핑하여 각 리스트 아이템들마다 다른 selector를 사용하도록 해야 한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// selector&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;getUserContent&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; state&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;favoriteContent&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;selectTitleByContentId&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;state&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; contentId&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;createSelector&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt; getUserContent &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;token parameter&quot;&gt;userContent&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; userContent&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;titles&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;contentId&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;state&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// list item component&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;mapStateToProps&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;state&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; ownProps&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	title&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;selectTitleByContentId&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;state&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; ownProps&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;contentId&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;reselect의 또다른 특징으로는 composable 하다는 점이다.
아래의 경우처럼 미리 만들어놓은 selector가 다른 selector의 input selector가 될 수 있어 selector들을 조합하는 것이 가능하다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// selector&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;getUserContent&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; state&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;userContent&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;getEntities&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; state&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;entities&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; selectUserContentIds &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;createSelector&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt; getUserContent &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// input selector&lt;/span&gt;
	&lt;span class=&quot;token parameter&quot;&gt;userContent&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; userContent&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;contentIds
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; selectUserContents &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;createSelector&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt; selectUserContentIds&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; getEntities &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;userContentIds&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; entities&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; userContentIds&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;contentId&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; entities&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;contents&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;contentId&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;data&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;//component&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;mapStateToProps&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;state&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; ownProps&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	contents&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;selectUserContents&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;state&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[AWS API, IP 기반으로 접근 제한하기]]></title><description><![CDATA[EC2 상의 인스턴스나 로드밸런서에 특정 IP 대역만 접근 가능하도록 설정하고 싶다면 Security Group 혹은 ACL을 이용하면 된다. 하지만 그 외의 AWS에서 제공하는 API 들에 대해서 IP 기반으로 접근제한을 걸고 싶다면 Security…]]></description><link>https://jaeyo.github.io/aws-api-ip-based-access-control/</link><guid isPermaLink="false">https://jaeyo.github.io/aws-api-ip-based-access-control/</guid><pubDate>Tue, 30 Jan 2018 17:19:00 GMT</pubDate><content:encoded>&lt;p&gt;EC2 상의 인스턴스나 로드밸런서에 특정 IP 대역만 접근 가능하도록 설정하고 싶다면 Security Group 혹은 ACL을 이용하면 된다. 하지만 그 외의 AWS에서 제공하는 API 들에 대해서 IP 기반으로 접근제한을 걸고 싶다면 Security Group, ACL 로는 불가능하다. 이 부분은 IAM의 Policy로 해결을 봐야 한다.&lt;/p&gt;
&lt;p&gt;예를 들어, AWS System Manager의 Parameter Store에 접근해서 데이터를 읽어오는 API를 IP 기반으로 제한하고 싶다고 가정하자.
그럼 일단 Parameter Store에 대한 기본 Policy 부터 확인해보자.
“AWS IAM -&gt; 정책” 로 들어가서 찾아볼 수 있다.&lt;/p&gt;
&lt;p&gt;확인해본 결과 &lt;code class=&quot;language-text&quot;&gt;AmazonSSMReadOnlyAccess&lt;/code&gt; 라는 정책이 있다. 정책 상세값은 아래와 같다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;json&quot;&gt;&lt;pre class=&quot;language-json&quot;&gt;&lt;code class=&quot;language-json&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;Version&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;2012-10-17&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;Statement&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token property&quot;&gt;&quot;Effect&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Allow&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;token property&quot;&gt;&quot;Action&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
                &lt;span class=&quot;token string&quot;&gt;&quot;ssm:Describe*&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;token string&quot;&gt;&quot;ssm:Get*&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;token string&quot;&gt;&quot;ssm:List*&quot;&lt;/span&gt;
            &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;token property&quot;&gt;&quot;Resource&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;*&quot;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;우리는 여기서 IP 기반 조건만 넣어주면 된다.
일단 기본 정책 &lt;code class=&quot;language-text&quot;&gt;AmazonSSMReadOnlyAccess&lt;/code&gt;의 상세 JSON 값을 복사한 후에 새로운 정책을 생성해보자.&lt;/p&gt;
&lt;p&gt;“AWS IAM -&gt; 정책 -&gt; 정책 생성”으로 들어가면 정책을 생성하기 위한 도구로써 시각적 편집기와 JSON 입력창이 제공되는데 JSON 입력창을 이용하여 다음의 내용을 입력한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;json&quot;&gt;&lt;pre class=&quot;language-json&quot;&gt;&lt;code class=&quot;language-json&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;Version&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;2012-10-17&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;&quot;Statement&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token property&quot;&gt;&quot;Effect&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Allow&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;token property&quot;&gt;&quot;Action&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
                &lt;span class=&quot;token string&quot;&gt;&quot;ssm:Describe*&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;token string&quot;&gt;&quot;ssm:Get*&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;token string&quot;&gt;&quot;ssm:List*&quot;&lt;/span&gt;
            &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;token property&quot;&gt;&quot;Resource&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;*&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;token property&quot;&gt;&quot;Condition&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;token property&quot;&gt;&quot;IpAddress&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;token property&quot;&gt;&quot;aws:SourceIp&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
                        &lt;span class=&quot;token string&quot;&gt;&quot;{IP_ADDRESS_TO_ALLOW}&quot;&lt;/span&gt;
                    &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
                &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;처음봤던 기본 조건에 비교하여 달라진 점은 “Condition” 부분이 추가되었다는 것이다. &lt;code class=&quot;language-text&quot;&gt;{IP_ADDRESS_TO_ALLOW}&lt;/code&gt; 부분을 적절하게 Allow 할 IP로 대체하면 된다.
단, aws api를 요청하는 경우에는 대부분의 경우 source ip가 외부 ip로 찍히게 되므로 사설 ip 대역은 설정해놓으면 안된다.&lt;/p&gt;
&lt;p&gt;이런식으로 정책을 설정한 뒤에 특정 계정에게 적용해놓으면 해당 계정을 통해서는 기 설정해놓은 IP 대역대에서만 접근할 수 있다. &lt;/p&gt;
&lt;p&gt;본문에는 “Allow” 기반으로 했는데 “Allow” 대신 “Deny”로 바꾸고 “IpAddress”를 “NotIpAddress”로 바꿔도 동일하게 동작 할 것이다.&lt;/p&gt;
&lt;p&gt;IAM 정책상에서 동일 리소스 및 동작에 대해 Allow와 Deny가 같이 존재한다면 Deny가 우선순위를 가진다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[조중균의 세계를 읽었다.]]></title><description><![CDATA[…]]></description><link>https://jaeyo.github.io/shame/</link><guid isPermaLink="false">https://jaeyo.github.io/shame/</guid><pubDate>Tue, 21 Nov 2017 13:31:00 GMT</pubDate><content:encoded>&lt;p&gt;그는 “지나간 세계” 라는 시를 쓰고 또 동명의 술집에서 형수라는 친구와 함께 산다.
대학생 무렵에는 운동권에 몸담았다. 운동권 학생들이 마음에 안들었던 한 교수는 역사 시험에서 시험지에 이름만 쓰면 점수를 주겠다고 했다. 다른 친구들은 아무렇지 않게 그 시험을 받아들일 때 그는 부끄러움을 생각했다. “아무것도 하지 않음으로써 이득을 취하는 일”에 그는 동조하지 않고 시험지에는 이름과 함께 시를 썼다.
이후 회사에 다니면서도 점심을 안먹고 점심 식대를 월급에서 제하지 않는 그에게 누군가 “몰래 점심을 먹을 수도 있지 않냐”라는 의심을 하자 그는 다시 부끄럽지 않기 위해서 매일 점심을 먹지 않았다는 확인 서명을 받았다. 일정대로 일이 진행되지 않자 상사는 그가 나태하게 일한다는 의심을 했고 그는 다시 그 의심 앞에서 부끄럽지 않기 위해서 매 시간 조카뻘되는 동료에게 찾아가 나태하게 일하지 않았다는 확인 서명을 받았다.
왼손 약지가 두 마디 정도 없던 그의 삶은 무엇을 가지고 있는지보다 무엇을 가지고 있지 못한지를 찾는 것이 편했다. 부끄럽지 않기 위한 대가였다.&lt;/p&gt;
&lt;p&gt;신념 이라는 단어를 내뱉으면 어쩐지 고리타분한 냄새가 난다. 돈이 신념이 되버린 시대다. 내게 이득이 되도록 우리는 무수히도 부끄러운 순간들을 눈감아왔다. 신념 같은 것들은 국어사전 속에나 존재했고, 이득을 위해 어느 선까지 부끄러울 수 있는가를 저울질하는 정도의 차이만 있을 뿐이지 우리는 전부 부끄러움 앞에서 발가벗은 것처럼 무력하다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[2006년의 서울과학기술대학교 (3)]]></title><description><![CDATA[…]]></description><link>https://jaeyo.github.io/snut-2006-3/</link><guid isPermaLink="false">https://jaeyo.github.io/snut-2006-3/</guid><pubDate>Thu, 09 Nov 2017 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;종종 마음이 시끄러우면 나는 학교를 찾는다. 내비에 공릉동을 찍으면 집에서 대략 한 시간 정도의 거리가 나온다. 쉽게 올만한 거리는 아니다. 그럼에도 한 번씩 사는 게 버겁게 느껴질 때면 공릉동 이곳저곳을 기웃거린다. 어릴 적 소풍 가서 보물 찾기를 하는 마음으로 공릉동 구석구석에 묻어있는 기억들을 캐낸다. 어쩐지 매번 새롭다. 이십 대의 대부분을 보낸 내게 공릉동은 왠지 고향집 같은 느낌을 준다.&lt;/p&gt;
&lt;p&gt;오늘도 다시 찾았다. 어의관 엘리베이터 앞에 비치된 러비 12월호를 챙겨 로비 소파에 앉아 정독했다. 글을 읽고 쓰는 걸 좋아했기 때문에 대학생 때는 러비에서 직접 글을 써보고 싶다는 생각도 했지만 당시에는 도저히 짬을 낼 수 없을 것 같아 마음을 접었다. 그래도 아쉬운 마음에 종종 후기 엽서를 써 보냈는데 당첨된 적이 있다. 상품권을 준다길래 부리나케 달려갔던 러비 동아리방은 제1학생회관 옥상층에 홀로 떨어져 자리 잡고 있었다. 지금 생각해보면 옥탑방이나 마찬가진데 이 추운 겨울에 어찌 버티고 있는지 문득 궁금해진다.&lt;/p&gt;
&lt;p&gt;지난번에 썼던 “2006년의 서울과학기술대학교” 1편과 2편을 뒤적이다 보니 시계탑 이야기가 빠져있었다. 2006년의 서울과학기술대학교 이야기를 풀어내겠다고 해놓고 시계탑 이야기를 빼놓았다니. 지금 재학생들에게 “시계탑”이라고 하면 알런지 모르겠다. 이미 철거된 지 꽤 되었으니까. 정확히 시기는 기억나지 않지만 아마도 2008년도쯤이었던 걸로 기억한다. 그러니 아직 학교를 다니고 있는 고학번들이나 겨우 얘기만 들어봤을까.&lt;/p&gt;
&lt;p&gt;사실 시계탑은 학교의 상징과도 같은 구조물이었다. 처음 입학하던 날 조우했던 우스꽝스러운 “凸” 모양의 교문도 사실은 다산관의 모양을 본 딴 것이고 다산관 머리 위에는 멋들어진 시계가 얹어 있었다. 사실 이 시계탑은 이미 예전부터 제 기능을 하지 못하고 있었다. 4면의 시곗바늘은 언제나 다른 시간을 가리키고 있었다. 그 시계탑이 유명한 것은 사실 신입생을 놀려먹는 유명한 레퍼토리 중 하나였기 때문이다. 새내기들이 학교에 대해 알아가기 시작하는 3, 4월쯤, 짓궂은 선배들은 새내기들에게 “다산관 시계탑은 사실 안에서 사람이 자전거 페달을 돌려 작동이 되는 거다”라는 거짓말로 골리곤 했다. 심지어는 “일이 고되기 때문에 시급이 짭짤하다”, “알바 신청은 어의관 행정학과 과사무실에서 하면 된다”는 식의 구체적인 거짓부렁들이 추가되기도 했다. 그 장난 섞인 거짓말들에 누군가는 진짜로 속아 행정학과 과사무실을 들렀다던가 하는 이야깃거리들이 축제 술자리 안주 위로 떠다녔다. &lt;/p&gt;
&lt;p&gt;교명이 변경되던 때의 이야기도 기억이 난다. 군대 가기 전까지는 “서울산업대학교”였는데 전역하고 복학할 시기가 다가오니 학교는 교명 변경으로 한창 시끄러웠다. 학생들 대부분은 산업대라는 어감을 별로 마음에 들어하지 않았다. 따라서 교명 변경 자체는 대부분 찬성했지만 변경될 교명에 대해 의견이 분분했다. 당시 여러 가지 교명 후보들이 사람들 사이에서 오르내렸는데 특히 현재의 교명인 서울과학기술대학교에 대해서 말이 많았다. 공대야 그렇다 쳐도 인문대와 조형대 학생들의 반발이 컸다. 과학기술대학교 문예창작학과라니 마치 하버드대학교 감귤학과 같다며 반대하는 이들이 있었지만 결국 현재의 교명으로 변경되고 말았다. 당시 후보로 사람들 사이에서 이야기되었던 다른 교명들로는 다산관의 이름을 따서 다산대학교도 있었지만 국립대 티가 별로 안 난다는 의견이었다. 누군가는 장난스레 “우리 학교의 모체인 공립어의동실업보습학교가 고종황제의 칙령으로 만들어졌으니 서울 왕립대가 어떠냐”라고 제안하기도 했다. 개인적으로 가장 간지가 풀풀 날리는 이름이 아닌가 싶다. &lt;/p&gt;
&lt;p&gt;마음이 시끄러울 때마다 학교를 찾게 되는 이유를 생각해본다. 공릉동 여기저기에 묻어있는 추억들이 괜히 특별하게 여겨지는 이유가 뭘까 고민해본다. 이 곳에는 20대의 어설픈 내 모습들이 묻어있다. 꼴에 대학생이라고 뭐라도 된 마냥 어설픈 몸짓으로 뭔가 일을 벌여보겠다고 설치기도 많이 설쳤고 괜스레 미간 사이에 주름을 잡고는 후배들에게 덜 익은 조언을 건네기도 했다. 모자란 실력들을 가지고 과방에서 밤을 새워가며 공모전 준비를 하던 날들도 기억난다. 참 어설퍼서 좋았다. 실수가 용납되고 이해되는 날이라 좋았다. 동료가 아닌 진짜 친구를 만들 수 있는 마지막 기회라 좋았고 나이가 부담감이 아니라 당당함을 주는 시기라서 좋았던 것 같다. &lt;/p&gt;</content:encoded></item><item><title><![CDATA[No title]]></title><description><![CDATA[golang으로 js를 돌리는 프로젝튼데.. 이름이 좀…. https://github.com/dop251/goja]]></description><link>https://jaeyo.github.io/weird-repo-name/</link><guid isPermaLink="false">https://jaeyo.github.io/weird-repo-name/</guid><pubDate>Tue, 31 Oct 2017 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;golang으로 js를 돌리는 프로젝튼데.. 이름이 좀….&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dop251/goja&quot;&gt;https://github.com/dop251/goja&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[2006년의 서울과학기술대학교 (2)]]></title><description><![CDATA[새 학기가 시작되면 자주 보이는 모습이 있었다. 바로 교내 잔디밭에서 자장면을 시켜먹는 모습이었다. 정문 근처 잔디밭, 붕어방 근처 잔디밭, 제…]]></description><link>https://jaeyo.github.io/snut-2006-2/</link><guid isPermaLink="false">https://jaeyo.github.io/snut-2006-2/</guid><pubDate>Tue, 24 Oct 2017 01:00:00 GMT</pubDate><content:encoded>&lt;p&gt;새 학기가 시작되면 자주 보이는 모습이 있었다. 바로 교내 잔디밭에서 자장면을 시켜먹는 모습이었다. 정문 근처 잔디밭, 붕어방 근처 잔디밭, 제1학생회관 옆 잔디밭 등등 너른 땅에 잔디밭이 수도 없이 깔려 있었고 당시에는 잔디밭에 출입을 통제하지도 않았기 때문에 친구들끼리 혹은 선후배들과 동그랗게 모여 앉아 자장면을 시켜먹는 모습은 자연스러운 광경이었다. 그러다 흥이 오르면 즉석에서 막걸리 잔이 돌아갔고 얼굴에 불콰한 빛을 띤 신입생들은 수업 시간을 외면한 채 2차 장소로 향하는 선배의 뒤를 쫄래쫄래 쫓곤 했다. 자장면 배달은 주로 서울대반점에 시켰었다. 저렴한 가격도 가격이었지만 무엇보다 배달시간이 비상식적으로 빨랐다. 교내 어디에서 시키던 최대 5분 컷을 넘어본 적이 없다. 맛이야 뭐 학교 앞 중국집들이 다 그러하듯 그냥 먹을만한 정도였던 걸로 기억한다. 서울대반점의 “스피드” 전략은 비단 배달에만 해당하지 않았다. 공간 시간에 서울대반점에 들러 카운터 앞에서 자장면 주문을 하면 채 자리에 앉기도 전에 자장면이 먼저 놓였다는 도시전설 같은 이야기가 떠돌았고 누구도 그 진위를 의심하지 않았다. 지금 생각해보면 그 너른 잔디밭에서 하루에 몇 번이고 “자장면 시키신 분?”을 외쳐야 했던 배달 요원들의 노고가 새삼 대단하다 싶다.&lt;/p&gt;
&lt;p&gt;서울대반점 하니 학교 앞 핫 플레이스들이 몇 군데 떠오른다. 산업대의 메인 스트리트라고 하면 단연 술집 “술쟁이”가 있던 골목이었다. 누군가는 “술쟁이 골목”이라고 불렀고 누군가는 “공릉동 로데오”라고 불렀던 그 골목에는 보석 같은 가게들이 몇 군데 있다. 대표적으로는 “술쟁이”와 “나루터”가 있었다. 두 술집은 정 반대로 대비되는 분위기였다. 술쟁이는 저학번들이 주로 찾던 술집이었다. 실내에는 시끌시끌하게 최신가요가 나오고 벽 한편에는 빔 프로젝터로 뮤직비디오나 라이브 무대들을 틀어주었다. 술집에 들어서면 사방에서 “랜덤게임”을 하는 소리로 귀가 먹먹할 정도였다. 안주는 대략 5000원 대에서 형성되어 있었고 감자그라탕 같은 메뉴들이 잘 팔렸다. 술쟁이 앞에는 술을 들이붓다 지친 이들이 모여 쪼그려 앉아 있곤 했다. 그리고 그 옆에 토사물도 심심치 않게 눈에 띄었다.&lt;/p&gt;
&lt;p&gt;술쟁이 맞은편에는 나루터가 있었다. 술쟁이의 반 정도 되는 공간이었는데 “응답하라 1997”에나 나올 법한 술집이었다. 사방 벽에는 선배 동문들이 휘갈긴 글귀들이 세월의 바람을 맞아 누렇게 변색되어 붙어 있었고 주력 메뉴는 전통적인(?) 반도리탕이나 두부김치 같은 것들이었다. 분위기가 이러하니 이 술집은 주로 고학번들이 찾았다. 단골인 선배를 따라 처음 나루터를 갔을 때 선배는 사장님을 아버지라 불렀고 사장님은 “니들만 먹냐”며 냉장고에서 소주 한 병을 꺼내와 우리와 함께 잔을 나누셨다. 그런 사장님 뒤로 뭔가 불만이신 사모님의 얼굴도 보였다. 사장님 이야기를 해보자면 원래는 교직 생활을 하셨다가 은퇴 후 나루터를 차리셨다고 했다. 집안이 어려운 친구들을 위해 학기마다 장학금을 주셨는데 이걸 우리는 나루터 장학금이라고 불렀다. 듣자 하니 지금은 안타깝게도 문을 닫았다고 한다. 언젠가는 술에 취해 나루터 벽에다 “무슨무슨 동아리 누구누구 일동” 같은 낙서를 남겼는데 그 낙서를 다시 볼 수 없다는 게 조금 아쉽기도 하다. &lt;/p&gt;
&lt;p&gt;신입생 시절 내 공간 시간의 대부분은 동아리방과 당구장에서 보냈다. 당구장은 특히 학교 앞 에버그린 당구장을 많이 갔는데 음료수뿐만 아니라 달짝지근한 토스트를 줘서 친구들과 에버그린 토스트를 먹으러 가자며 자주 발길을 향하곤 했다. 하지만 내 또래 중 당구장을 다니는 친구는 일부였고 대부분은 플스방을 갔다. 내 선배들까지는 당구가 그 또래의 소셜 스포츠 급은 되었을 정도로 대중적이었는데 06학번부터는 당구를 많이 치지 않았다. 그래서 주로 형들과 많이 치러 다녔다.&lt;/p&gt;
&lt;p&gt;당구장 외에 공간 시간은 물론 수업이 끝나고 나서도 주로 동아리방에 많이 붙어있었다. 당시 내가 속해있던 동아리는 역사가 20년쯤 되었는데 그러다 보니 동아리방 캐비닛을 열면 케케묵은 노트와 사진첩들이 가득 들어차 있었다. 가끔 심심하면 그것들을 꺼내어 한참을 들여다보곤 했다. 사진첩 속에는 유행이 지나도 한참 지난 스노우진을 입고 연갈색으로 머리를 물들인 선배들이 학교 여기저기와 동아리방을 배경으로 찍혀있었다. 제일 오래된 사진은 80년대 것도 있었고 90년대에 찍힌 사진들이 제일 많았다. 사진첩 위로는 수많은 스프링 노트들이 있었는데 전부 “날적이”였다. 날적이의 뜻이 “날 적어주세요”라고 해서 날적이라는 사람도 있었고 “날마다 적는 것”이라서 날적이라는 사람도 있었다. 주로 시답잖은 낙서부터 손발 오그라드는 시 같은 것들도 적혀있었다. 인터넷 문체에 익숙한 우리 또래의 글들과는 확연히 글의 색깔이 달랐지만 대개 그때의 내가 느꼈던 불안, 지루함, 설렘, 즐거움 같은 것들이 적혀 있었다. 아직도 날적이가 이어져 내려오는지는 모르겠다. &lt;/p&gt;
&lt;p&gt;동방에서 혼자 시간을 죽이고 있으면 할 일 없는 친구들이 하나둘씩 동방으로 모여들곤 했다. 그러다 어느 정도 인원이 모이면 소운동장에 드럼통 위에 네트를 걸어놓고 족구도 자주 했다. 공은 FC SNUT에 가서 학생증을 맡기면 빌려줬다. 이래저래 자잘한 추억이 많이 담긴 소운동장은 아쉽게도 2008년도쯤에 프론티어관이 들어서면서 없어지게 됐다. 새로 들어선 프론티어관의 연구실들은 밤늦게까지 학구열을 불태우는 친구들로 인해 불이 꺼지지 않았다. 우리는 그 불빛 아래서 밤늦게까지 노닥거리며 보쌈을 시켜 소주를 마시고 그러다 술에 취하면 그대로 동방에서 잠들기 일쑤였다. 그렇게 학점 대신 즐거운 추억들을 많이 쌓았는데 지나고 보니 대학생활 그래도 재밌게 잘 보냈다 싶은 생각이 든다. 그렇게 허구한 날 덮고 잤던 동방의 이불과 베개는 볕이 좋은 날 하루를 잡고 동방 화장실에 있는 세탁기를 이용해서 세탁을 하고 소운동장 벤치 위에 널어놓곤 했다. &lt;/p&gt;
&lt;p&gt;1학기 중간고사를 어찌어찌 지나고 나면 축제 준비가 시작된다. 산업대는 1년에 두 번, 학기 별로 축제가 있었는데 1학기 축제는 총학생회가, 2학기 축제는 동아리 연합회에서 준비를 했던 걸로 기억한다. 대체로 1학기 축제가 규모 면으로나 내용 면으로나 더 재미있었다. 축제 준비 시즌에 신입생들이 겪는 경험들은 각 신입생들이 속한 집단마다 판이하게 달랐다. 학생회에 속해 있는 친구들은 주점 준비에 여념이 없었다. 대단치 못한 과 학생회 재정으로 1년 행사들을 잘 치러나가려면 축제 주점에서 이익을 많이 내야 했다. 하지만 대부분의 경우 겨우 적자를 면하는 정도였다. 학생회장들은 연이어 방문하는 선배들의 술잔을 받아내느라 파장 쯔음에는 대부분 취해 쓰러지기 일쑤였고 그 뒤처리는 부학생회장들의 몫이었다. 중앙동아리에 속한 신입생들은 축제 부스나 축제 공연 준비로 시간을 보내게 된다. 특히 공연분과들이 바쁜데 교내에서 치르게 되는 행사 중 정기공연 다음으로 비중이 있는 행사임과 동시에 다른 공연분과 동아리와 비교를 당할 수 있는 자리였기 때문에 연습이 특히 빡셌다. 무대에 올라가기 전까지는 축제도 제대로 즐기지 못하고 동방에 틀어박혀 연습을 해야 했다. 학생회에도, 동아리에도 속해 있지 않은 친구들은 우리 학교 축제보다는 다른 학교 축제에 더 관심이 많았다. 그럴 수밖에 없는 것이 산업대 축제는 재미없기로 소문이 자자했다. 지금이야 어떤지 모르겠지만 당시만 해도 다른 사립대들과 규모 면에서 차이가 많이 났다. 특히 다른 학교 축제에는 외부 기업 들에서도 참여를 많이 했는데 우리 학교는 순수하게 학생들의 힘만으로 준비된 행사들 밖에 없었다. 남자인 친구들은 서울여대 축제가 가까워서 많이들 갔다. &lt;/p&gt;
&lt;p&gt;축제 주점은 주로 대운동장에 세워졌다. 지금은 잔디밭이 깔려 있으니 대운동장에는 주점이 들어서질 못할 텐데 어디에 세워지는지 궁금하다. 아예 교내 주점을 제제하기 시작했다는 이야기도 얼핏 들은 것 같다. 당시에는 그 넓은 대운동장의 이쪽 끝부터 저쪽 끝까지 모두 과 학생회들의 주점으로 가득 찼다. 대부분 분위기는 비슷비슷했지만 유독 조형대 주점들이 눈길을 자주 끌었던 걸로 기억한다. 특히 차이나 드레스를 입고 서빙을 했던 주점은 늦은 밤까지 빈자리가 나질 않았다. 대운동장만으로 자리가 부족하니 붕어방 쪽으로 세워진 주점도 몇몇 있었다. 특히 다산관 바로 뒤편에 커다란 나무 아래 세워진 주점도 하나 있었는데 운치가 제법이었다. 일본에서는 봄이 되면 벚꽃나무 아래서 자리를 깔아놓고 술을 마시는 문화가 있다고 하는데 아마 비슷한 기분이지 않을까 싶다. &lt;/p&gt;
&lt;p&gt;붕어방도 신입생 때와 비교해서 극적으로 변화한 장소 중 한 곳이다. 2006년도까지만 해도 붕어방은 그냥 늪이었다. 지금처럼 나무데크나 벤치 같은 건 있지도 않았고 가까이 가면 꾸리꾸리 한 냄새에 코를 틀어막을 정도였다. 우스갯소리로 붕어방에 빠지면 에이즈 빼고 다 걸린다고들 했다. 다른 호수가 있는 학교들은 술 취한 학생들이 으레 호수에 빠지고 하는 사고들이 종종 있다고 하는데 당시의 붕어방은 빠지면 정말 죽을 것 같아서 그랬는지 아무도 가까이하지 않았다. 그랬던 것이 군대를 다녀오고 보니 교내 CC들의 데이트 명소가 되어 있었다. 불투명하고 탁한 수면과 쾌쾌한 냄새는 온데간데없고 가끔 한 번씩 난데없는 분수쇼까지 등장했다. 놀랄 일이다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[2006년의 서울과학기술대학교 (1)]]></title><description><![CDATA[오랜만에 모교인 서울과학기술대학교에 들렀다. 한밤 중이라 어두워 제대로 보이진 않았지만 못 보던 건물들이 꽤 들어서있었다. 심지어는 아직 공사 중인 곳도 있어서 포크레인이 부지 한가운데 덩그러니 서있었다. 1…]]></description><link>https://jaeyo.github.io/snut-2006-1/</link><guid isPermaLink="false">https://jaeyo.github.io/snut-2006-1/</guid><pubDate>Tue, 24 Oct 2017 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;오랜만에 모교인 서울과학기술대학교에 들렀다. 한밤 중이라 어두워 제대로 보이진 않았지만 못 보던 건물들이 꽤 들어서있었다. 심지어는 아직 공사 중인 곳도 있어서 포크레인이 부지 한가운데 덩그러니 서있었다. 10여 년 전에는 잔디밭이었던 곳에 번쩍번쩍 거리는 건물이 웅장하게 들어서 있었다. 귀신이 자주 출몰했다던 다빈치관은 온데간데 없어지고 대신 또 새로운 건물이 그 자리를 차지하고 있었다. 학교는 계속해서 더 나아지고 있지만 어쩐지 내 기억 속의 모습들과 조금씩 빗겨나가고 있는 것이 아쉬웠다. 그래서 2006년의 서울과학기술대학교의 모습을 늦기 전에 기억을 되새겨 남겨놓으려 한다.&lt;/p&gt;
&lt;p&gt;정확히는 서울산업대학교였다. 아직 일반대학교 전환이 되기 전이었다. 덕분에 정시로 지원할 때는 ‘라’군으로 분류되어 가, 나, 다 군을 다른 학교에 쓰고 안전빵으로 우리 학교를 많이 쓰곤 했던 걸로 기억한다. 친구들끼리 학교를 부를 때는 주로 산업대라고 줄여 불렀다. 하루는 자취방에서 늦잠을 잔 덕에 택시를 타고 “산업대로 가주세요”라고 하고 한숨 자고 일어났는데 근처 삼육대학교로 가있었던 우습던 기억도 난다. &lt;/p&gt;
&lt;p&gt;어른들로부터의 평판은 좋지 못했다. 우리 아버지도 그랬다. 서울산업대로의 지망 의사를 밝혔을 때 아버지는 왜 그렇게 열심히 공부해놓고 고작 산업대를 가냐고 했다. 산업대라는 이름 속에는 어쩐지 직업전문학교의 냄새가 풀풀 풍겼고 심지어는 입시를 준비하는 학생들 사이에서의 인지도도 그리 좋지 못했다. 하지만 이상하게 고3들에게만은 인지도가 괜찮았다.&lt;/p&gt;
&lt;p&gt;그러고 보니 동기들 중에 실업계 출신도 있었다. 당시 서울산업대는 서울 내에서 실업계전형이 있는 몇 안 되는 대학교 중 하나였고, 그 문턱이 결코 낮지 않았기 때문에 많은 실업계 친구들이 우리 학교를 지망했다. 조금 과장하자면 실업계 전형의 서울대학교였다. 어디 무슨 도대회 대상 정도의 타이틀은 달고 있어야 합격 가능권에 발끝이라도 디뎌볼 수 있었다. 그래서인지 실업계 전형으로 온 친구들은 이래저래 재주가 많았다. 웹디자인 비슷한 걸로 대회 준비를 해서 온 친구 하나는 학과 홈페이지 리뉴얼 같은 알바를 종종 맡으면서 부족했던 생활비를 충당했다.&lt;/p&gt;
&lt;p&gt;처음 입학했을 쯤의 가장 인상적인 기억은 어의관이었다. 지금도 어의관이라고 부르는지 모르겠다. 내 한 학년 선배들은 어의관을 인문대, 그리고 다산관을 1공대 뭐 이런 식으로 불렀었다. 모든 교양과목들은 어의관에서 진행되었기 때문에 전공을 불문하고 학생들 사이에서 어의관은 익숙한 건물이었다. 어의관 내부 구조는 로비를 가운데로 두고 복도가 양쪽 끝으로 늘어서있는 모양새였는데 쉬는 시간이면 다들 담배를 물고 로비로 모여들었다. 그리고 로비에서 흡연을 했다. 지금이야 올바른 흡연 문화가 자리 잡혀가는 과정에서 흡연자들이 입지가 많이 줄어들었지만 그때 당시의 시선으로도 그건 충격이었다. 건물 한가운데서 담배를 폈다. 심지어 흡연장소는 자판기 옆이라 비흡연자인 친구들도 음료수를 뽑으려면 흡연자를 사이로 들어가야 했다. 그런 곳에 재떨이가 있었다는 것이 지금으로는 상상도 못 할 일이다. 나중에는 강의실 문을 열고 나오자마자 담배에 불을 붙이는 친구들도 있었다.&lt;/p&gt;
&lt;p&gt;어의관 1층 뒤편에도 역시 음료수 자판기와 흡연장소가 있었다. 그리고 그 뒤로는 불암 학사가 있었다. 그때 당시 기숙사라고는 불암 학사 밖에 없었다. 수용인원 역시 택도 없이 적었기 때문에 웬만해서는 기숙사 생활을 꿈꾸지 못했다. 지금 기억으로는 학점이 중요한 커트라인 중 하나였던 걸로 기억을 하는데 기숙사에 사는 대부분의 친구들의 평점이 모두 4.0을 넘었다. 나는 학교를 다니는 내내 기숙사를 들어가 보려는 엄두도 못 냈다. &lt;/p&gt;
&lt;p&gt;기숙사 뒤편으로는 창의문이라고 부르던 학교 후문이 있다. 아마 지금도 있을 것이다. 말이 후문이지 사실상 개구멍이라고 불러도 어색하지 않을 정도로 초라했다. 그 후문을 통하면 하계역까지 갈 수 있는 루트가 있는데 이 루트를 통하면 공릉역에서부터 걸어오는 것보다 더 빨리 학교에 도착할 수 있다고 했다. 특히 어의관에서 수업을 많이 듣는 인문대 친구들은 하계역 - 창의문 코스를 많이 이용했다. 나는 많이 갈 일이 없었다.&lt;/p&gt;
&lt;p&gt;어의관 옆 쪽에는 구 다빈치관이 있었다. 일제시대 건물 양식으로 앞에서 보면 3층 건물이었지만 내부는 2층까지 밖에 없어서 온갖 출처를 알 수 없는 낭설들이 떠돌았던 곳이다. 2층으로 올라가면 계단은 끊겨있었고 2층 복도에는 성인 남성이 손을 뻗어도 닿을까 말까 한 곳에 조그마한 창문들이 있었다. 용감한 친구 하나가 그 창문을 통해 다빈치관 3층으로의 진입을 시도했다던가 하는 이야기를 들은 적이 있었던 것 같은데 결과는 기억이 나지 않는다. 아마도 시덥지 않은 결론 때문에 금방 잊어버린 듯하다.&lt;/p&gt;
&lt;p&gt;다빈치관 앞쪽으로 가면 제1학생회관이 있었다. 1층에는 학생식당과 휴게실이 있었고 2층부터는 동아리방들이 둥지를 트고 있었다. 동아리 연합회는 2층에, 총학생회는 3층에 있었던 걸로 기억한다. 동아리나 총학생회에서 행사를 위해 플랜카드 (PC라고 불렀다)를 만들 땐 제1학생회관 옥상을 자주 이용했다. 신나는 2층 문구점에서 팔았다. 덕분에 지금도 제1학생회관 옥상 바닥에는 플랜카드의 흔적들이 새겨져 있다. 아직도 그런 식으로 플랜카드를 쓰는지 모르겠다. &lt;/p&gt;
&lt;p&gt;내가 입학했던 2006년도에는 중앙동아리의 활동들이 시들해지던 때였다. 취업난이 점차 심해지면서 학생들은 동아리에서 눈을 돌리기 시작했고 그나마도 취업에 조금이나마 도움이 될 수 있는 과동아리들을 위주로 가입했다. 중앙동아리에 있던 선배들은 신입생들의 동아리 가입이 예전 같지 않다며 아쉬워했다. 그래도 동아리에 들어가 있던 친구들은 활발하게 활동했다. &lt;/p&gt;
&lt;p&gt;당시 학교에 밴드 동아리는 세마치와 그레이무드 두 곳이 있었다. 백송이라는 동아리도 있었지만 이 동아리는 밴드 동아리라기보다는 민중가요를 밴드로 공연하는 느낌이었기 때문에 결을 약간 달리했다. 세마치와 그레이무드의 동아리방은 중앙 운동장 구석에 있었다. 지금처럼 잔디로 예쁘게 깔린 운동장이 아니라 흙먼지가 날리는 운동장이었고 그 구석에 조그마한 건물 한동을 세마치와 그레이무드가 나눠 썼다. 듣기로는 원래 세마치라는 동아리만 있었다가 그 안에서 음악적 견해 차이를 이유로 일부 인원이 뛰쳐나왔고 그렇게 만들어진 동아리가 그레이무드 였다고 들었는데 그 두 동아리들이 나란히 같은 지붕 아래 있으니 그것도 참 우스운 일이었다. 역시 소문대로 세마치의 공연은 굉장히 빡세고 하드한 곡들 위주였고 그레이무드의 곡들은 좀 더 말랑말랑하거나 하는 분위기의 곡들이었다. 세마치 공연에 갔을 때 전체 선곡의 80% 이상이 그로울링을 하는 보컬이었던 기억이 난다. 당시 세마치는 규율이 빡세기로도 소문이 자자했다. 가끔 지나가다 보면 세마치 동아리방 옆에서 몇 명인가가 엎드려있고 선배로 보이는 친구가 빠따(?)를 치고 있는 모습을 보기도 했다. 요즘 잊을만하면 나오는 선후배 간의 강압적인 군기잡기 같은 것들이 당시 산업대에는 아예 없다시피 했기 때문에 인상적이었다. 듣기로는 공연을 앞두고 공연곡이 완성되지 않으면 수업도 들여보내지 않는다고 했다. 그레이무드의 독립은 음악적인 견해 차이뿐만 아니라 이런 강압적인 분위기도 한몫했을 것 같다는 추측도 해본다.&lt;/p&gt;
&lt;p&gt;입학하고 한 달 정도가 지나면 제1학생회관 앞에서 재미있는 행사가 하나 벌어졌다. 교내 통기타 동아리인 소리사랑에서 교내 훈련이라는 이름으로 유동인구가 많은 제1학생회관 앞에서 무반주 공연을 했다. 말이 공연이지 그 모습은 담력 훈련과 비슷한 모양새였다. 아무것도 모르는 신입생들을 연습시켜서 공연을 세워야 하나 막상 신입생들이 사람들 앞에서 노래하는 것을 어렵게 여기니 그를 타파하기 위한 선배들의 고육지책이 아니었나 싶다. &lt;/p&gt;</content:encoded></item><item><title><![CDATA[리디스토리 프론트엔드 개발기]]></title><description><![CDATA[본 포스팅은 회사 블로그에 올려놓았던 글을 옮겨놓은 것입니다. 몬타나 존스 라는 만화영화가 있었습니다. 199…]]></description><link>https://jaeyo.github.io/how-to-develop-ridistory-frontend/</link><guid isPermaLink="false">https://jaeyo.github.io/how-to-develop-ridistory-frontend/</guid><pubDate>Sun, 08 Oct 2017 14:57:00 GMT</pubDate><content:encoded>&lt;p&gt;본 포스팅은 &lt;a href=&quot;https://www.ridicorp.com/blog/2017/09/13/how-to-develop-ridistory-front/&quot;&gt;회사 블로그에 올려놓았던 글&lt;/a&gt;을 옮겨놓은 것입니다.&lt;/p&gt;
&lt;br /&gt;
&lt;hr&gt;
&lt;br /&gt;
&lt;p&gt;몬타나 존스 라는 만화영화가 있었습니다. 1990년대 중반쯤에 방영되었던 것으로 기억이 나네요. 에피소드마다 의인화된 사자와 호랑이가 유적지를 탐험하다 제로경으로 대표되는 악의 무리와 부딪힙니다. 제로경은 니트로 박사라는 부하가 만들어준 로봇을 타고 주인공의 앞길을 막고, 쫓고 쫓기는 아슬아슬한 활극 끝에 결국 정의의 편인 주인공이 승리하곤 합니다. 여기서 제로경과 니트로 박사가 주고받는 대화가 일품입니다. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;제로경: 니트로 박사, 사정을 설명해보실까? &lt;br /&gt;
니트로 박사: 지금이라도 시간과 예산을 조금만 더 주신다면… &lt;br /&gt;
제로경: &lt;strong&gt;변명은 죄악이란 걸 모르나!&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;오래된 기억 상자 속에서 몬타나 존스라는 만화영화 이야기를 꺼낸 이유는 신규 서비스를 개발하는 입장에서 니트로 박사에게 어쩐지 묘하게 공감했기 때문입니다. 스타트업에서 개발을 하는 많은 개발자분들도 공감할 수 있는 이야기라는 생각이 듭니다. &lt;/p&gt;
&lt;p&gt;우리에게 시간이 좀 더 있다면! 예산이 더 있다면! 인력이 더 있다면! &lt;/p&gt;
&lt;br&gt;
&lt;h2&gt;가장 큰 문제는 시간&lt;/h2&gt;
&lt;p&gt;아, 시간! 콘텐츠 플랫폼의 비즈니스 가치는 유료 회원수와 콘텐츠의 질에 따라 결정됩니다. 그렇기 때문에 초기 시장을 선점하는 일은 굉장히 중요합니다. 이미 사용자는 기존 플랫폼이 제공하는 UX에 익숙해져 있습니다. 특별한 이유가 없다면 다른 제품을 사용하지 않습니다. 또한 콘텐츠 제공자는 시장에 영향력을 가진 플랫폼을 선호하기 때문에, 신생 플랫폼 입장에서 콘텐츠를 확보하려면 많은 노력이 필요합니다.&lt;/p&gt;
&lt;p&gt;하지만 리디스토리 개발이 시작될 당시 이미 굳건한 위치를 잡고 있는 플랫폼들이 많이 있었습니다. 따라서 리디스토리는 골리앗에게 도전하는 다윗의 심정으로 조금이라도 더 누구보다 빠르게 남들과는 다르게 출시해야 했습니다.&lt;/p&gt;
&lt;p&gt;이러한 사정은 비단 리디스토리 만의 이야기는 아닙니다. 많은 스타트업들이 빠르게 시장에 진입하기 위해 기반기술 같은 부분들은 가능하면 매니지드 서비스를 이용하고 생산성이 좋은 언어와 프레임워크를 이용하는 것이 요즘 트렌드인 것 같습니다.&lt;/p&gt;
&lt;br&gt;
&lt;h2&gt;웹앱, 그리고 더 빠르게&lt;/h2&gt;
&lt;p&gt;그래서 웹앱이었습니다. 서비스 론칭까지 4개월, 선택지는 그리 많지 않았습니다. 사실 개발 초기에는 서버 개발자 2명밖에 없었습니다. 팀 내에 네이티브 앱 개발 경험을 가진 개발자가 있더라도 빠른 서비스 론칭을 위해서는 결국 웹앱 쪽으로 방향을 잡을 수밖에 없었습니다. 동일한 서비스를 구현하는 코드를 Android, iOS 각각의 플랫폼별로 두 벌을 만들어 유지하고 각각의 코드에서 발생할 이슈들까지 잡아나가기엔 시간과 인력의 효율 면에서 좋지 못했습니다.&lt;/p&gt;
&lt;p&gt;방향이 웹앱으로 정해지고 나서부터 리디스토리 개발팀은 익숙하고 빠르게 결과물을 낼 수 있는 방식으로 작업을 하기 시작했습니다. 서비스에 필요한 UI를 HTML로 구성하고 그 안에서 동적으로 변경되는 부분들은 &lt;a href=&quot;https://www.djangoproject.com/&quot;&gt;Django&lt;/a&gt;에서 지원하는 &lt;a href=&quot;http://jinja.pocoo.org/&quot;&gt;Jinja2&lt;/a&gt;라는 템플릿을 통해서 구성하는 전통적인(?) 방식이었습니다. 그렇게 서비스의 얼개가 대강 잡혔을 때쯤 우리는 그동안 우리 안에서 가지고 있던 불안에 대해 꺼내놓고 이야기하기 시작했습니다. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;이거 너무 느린데요?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;네, 너무 느렸습니다. 느릴 수밖에 없었습니다. 스마트폰에 앱이라는 형태로 인스톨된 이상 사용자는 여타 다른 네이티브 애플리케이션과 비슷한 반응성을 기대하며 리디스토리 앱을 이용하게 됩니다. 하지만 리디스토리 앱의 내부는 웹과 동일한 형태로 구현이 되었으니 사용자 입장에서는 어딘가 모르게 굼뜨다는 인상을 받게 됩니다. 매 화면 이동마다 흰 화면이 순간적으로 노출되고 인터랙션도 어딘가 모르게 답답합니다. &lt;/p&gt;
&lt;p&gt;개발팀은 하던 일을 모두 중지하고 회의실에 모여 머리를 맞대고 대책을 강구하기 시작했습니다. 길고 긴 회의 끝에 기존의 방법을 버리고 Single Page Application(이하  SPA)으로 전면 개편이라는 선택지로 겁도 없이 손을 뻗었습니다. SPA 개발을 도와줄 도구로서 &lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;React&lt;/a&gt;와 &lt;code class=&quot;language-text&quot;&gt;Angular&lt;/code&gt;를 비교했고, 학습곡선이 낮고 좀 더 자유로운 방식으로 사용 가능한 &lt;code class=&quot;language-text&quot;&gt;React&lt;/code&gt;에 &lt;code class=&quot;language-text&quot;&gt;React-router&lt;/code&gt;를 곁들여 사용하기로 했습니다. 그때부터 이른바 고난의 행군이 시작되었습니다. &lt;/p&gt;
&lt;p&gt;개발팀 태스크보드에는 서비스 화면의 이름이 쓰인 태스크들이 무더기로 등장했습니다. 개발자들은 그 태스크들을 하나씩 가져와 기존에 Jinja2 템플릿으로 되어 있던 화면을 &lt;code class=&quot;language-text&quot;&gt;React&lt;/code&gt; 기반으로 옮기기 시작했습니다. 단순 포팅을 넘어서 화면의 각 구성요소를 적절하게 컴포넌트화하여 재사용성을 높이고, 각 화면들의 시나리오들을 &lt;code class=&quot;language-text&quot;&gt;React&lt;/code&gt; 라이프사이클에 적절하게 녹여내야 했습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.ridicorp.com/blog/img/2017-09-13/code_deleted_added.png&quot; alt=&quot;git commit graph&quot;&gt;&lt;/p&gt;
&lt;figcaption&gt;어마어마한 양의 코드들이 삭제되고 또 추가되었습니다. &lt;/figcaption&gt;
&lt;br&gt;
&lt;h2&gt;그냥 Redux 쓸 걸&lt;/h2&gt;
&lt;p&gt;우리가 겪은 기술적인 문제들은 대부분 &lt;strong&gt;웹이면서 웹이 아닌 척해야 하는 웹앱&lt;/strong&gt;의 숙명으로부터 비롯된 것이었습니다. 순조롭게 진행되는가 싶던 SPA로의 전환 작업의 첫 번째 고난은 댓글 화면에서 시작되었습니다. 사용자는 댓글 목록 화면에서 새로운 댓글을 쓰기 위해 댓글 작성 화면으로 이동하게 됩니다. 새로운 댓글을 성공적으로 올리고 댓글 목록 화면으로 돌아왔을 때, 사용자는 자신이 방금 작성한 댓글이 댓글 목록에 없는 것을 발견하게 됩니다. 댓글 목록에 있는 댓글은 새로운 댓글을 적기 전에 받아온 데이터니까요. 그리고 이는 용납하기 어려운 사용자 경험입니다.&lt;/p&gt;
&lt;p&gt;이 문제를 해결하기 위해 우리는 클라이언트에서 상태와 데이터를 저장하고 관리하는 코드들을 추가하기 시작했습니다. 서버로부터 받아온 댓글 목록 데이터를 변수에 저장하고 사용자가 새로운 댓글을 작성하면 서버로 전송됨과 동시에 그 변수에도 추가하게 됩니다. 이제 댓글 목록 화면으로 돌아오더라도 이 저장소에 있는 데이터를 기반으로 화면을 그리기 때문에 방금 작성한 댓글도 댓글 목록에 볼 수 있습니다. 댓글 외에도 클라이언트에서 유지해야 하는 데이터의 종류들은 상당히 많았습니다. 예를 들어, 로그인된 사용자의 정보는 많은 화면에서 공통으로 사용하기 때문에 매번 서버에서 받아오는 것은 비효율적이었습니다. &lt;/p&gt;
&lt;p&gt;게다가 문제는 또 있었습니다. &lt;code class=&quot;language-text&quot;&gt;React&lt;/code&gt;로 코딩하다 보면 화면의 구성요소들을 컴포넌트 단위로 잘게 나누고 그 컴포넌트들을 조합하는 방식을 사용하게 됩니다. 따라서 화면이 복잡한 경우에는 A 컴포넌트가 B 컴포넌트를 포함하고, B 컴포넌트는 또 다른 C 컴포넌트를 포함하는 식으로 depth가 깊어지기에 십상인데요, 이때 A 컴포넌트에서 가지고 있는 데이터를 C 컴포넌트까지 내려주려면 B 컴포넌트를 통해서 props라는 형태로 내려주어야 합니다. depth가 깊어질수록 문제가 커지죠. 개발팀은 다시 회의실에 모여 이야기합니다. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;그냥 Redux 쓸 걸 그랬네요.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;네, 사실 &lt;code class=&quot;language-text&quot;&gt;React&lt;/code&gt; 도입 단계에서 &lt;code class=&quot;language-text&quot;&gt;Redux&lt;/code&gt;까지 고려했으나 당시 필요 이상의 엔지니어링이라는 판단이 들어 배제했었고 나중에야 그것이 잘못된 판단이라는 것을 깨달았습니다. 클라이언트에서 상태를 유지하는 문제, 컴포넌트 depth를 따라서 데이터를 내려줘야 하는 문제 모두 &lt;code class=&quot;language-text&quot;&gt;Redux&lt;/code&gt;를 도입함으로써 깔끔하게 해결할 수 있는 문제였습니다. 잠깐 후회했지만 빠르게 &lt;code class=&quot;language-text&quot;&gt;Redux&lt;/code&gt;를 서비스에 적용했습니다. 더불어 &lt;code class=&quot;language-text&quot;&gt;Redux-thunk&lt;/code&gt; 라던가 &lt;code class=&quot;language-text&quot;&gt;Reselect&lt;/code&gt; 같은 &lt;code class=&quot;language-text&quot;&gt;Redux&lt;/code&gt;와 함께 묶어서 사용할 수 있는 라이브러리들까지 도입하면서 프론트엔드 코드를 좀 더 깔끔하게 작성할 수 있었습니다. &lt;/p&gt;
&lt;br&gt;
&lt;h2&gt;Entity의 등장&lt;/h2&gt;
&lt;p&gt;앞서 언급한 사용자 정보에 대한 데이터 외에도 여러 화면에서 공통으로 사용되는 데이터는 또 있었습니다. 바로 작품에 대한 메타데이터였습니다. 작품의 Primary Key(이하 pk)와 제목, 저자 정보 등으로 구성된 이 데이터는 여러 화면에서 공통으로 사용되고 있었고 매화면 이동 시마다 중복해서 서버에서 내려주고 있었습니다. 예를 들면 아래와 같은 시나리오입니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;럭키박스 발급 화면에서 작품 이용권 당첨&lt;br /&gt;
→ 작품의 제목을 표시하기 위해 작품 메타데이터를 서버에서 전달&lt;/li&gt;
&lt;li&gt;해당 작품을 터치해 작품 상세 화면으로 이동&lt;br /&gt;
→ 작품의 상세 정보들을 표시하기 위해 작품 메타데이터를 &lt;strong&gt;또&lt;/strong&gt; 서버에서 전달 &lt;/li&gt;
&lt;li&gt;해당 작품을 읽기 위해 뷰어 화면으로 이동&lt;br /&gt;
→ 작품의 제목을 표시하기 위해 작품 메타데이터를 &lt;strong&gt;또다시&lt;/strong&gt; 서버에서 전달 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;클라이언트에서 데이터가 중복으로 저장되어 메모리 사용량이 늘어나는 것은 차치하더라도 전송 시마다 트래픽을 과하게 소비하면서 화면 로딩을 늦추는 것을 우리는 용서할 수 없었습니다.
이 적폐를 청산하기 위해서 작품 메타데이터를 조금 특별하게 취급하기로 했습니다. &lt;code class=&quot;language-text&quot;&gt;Redux&lt;/code&gt; store에 &lt;code class=&quot;language-text&quot;&gt;Entity&lt;/code&gt; 라는 개념을 만들고 메타데이터들을 저장하고 관리하기로 했습니다.&lt;/p&gt;
&lt;p&gt;기존에 메타데이터를 내려주던 API들에서는 메타데이터에 대한 pk만을 내려줍니다.
클라이언트에서는 이 pk를 이용해 가지고 있지 않은 pk들만 별도의 메타데이터 API에 요청하도록 하였습니다.
이렇게 받아온 메타데이터는 &lt;code class=&quot;language-text&quot;&gt;Entity&lt;/code&gt;에서 관리하면서 다른 화면에서 재사용할 수 있도록 했고요. &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.ridicorp.com/blog/img/2017-09-13/entity.png&quot; alt=&quot;Entity 설명 이미지&quot;&gt;&lt;/p&gt;
&lt;figcaption&gt;Entity는 이렇게 동작합니다.&lt;/figcaption&gt;
&lt;p&gt;이렇게 구조를 변경하고 나니 각 API의 응답 데이터 사이즈가 눈에 띄게 줄었고 결과적으로 좀 더 빠르게 화면을 그려줄 수 있게 되었습니다. 어쩌면 수십 ms 정도의 차이겠지만 티끌 모아 태산이니까요. &lt;/p&gt;
&lt;br&gt;
&lt;h2&gt;웹 같은 앱, 앱 같은 웹 그리고 앞으로는?&lt;/h2&gt;
&lt;p&gt;리디스토리는 웹앱으로 개발되었습니다. 웹앱으로 하면 하나의 코드로 모든 플랫폼에 대응할 수 있으며, 개발 편의성도 높습니다. 또한, 버그 수정 및 기능추가를 빠르게 실 서비스에 적용할 수 있습니다. &lt;/p&gt;
&lt;p&gt;하지만 그에 따른 단점들도 있습니다. 네이티브에 비해 속도도 느리고 사용성도 좋지 않습니다.
개발팀은 네이티브앱 처럼 보이기 위해 많은 노력을 했습니다. 특히 성능 개선 측면에서 많은 시도를 했습니다. 여러 화면에서 데이터를 최신으로 유지하기 위해 &lt;code class=&quot;language-text&quot;&gt;Redux&lt;/code&gt;를 도입한다던가, &lt;code class=&quot;language-text&quot;&gt;Entity&lt;/code&gt;라는 개념을 만들어 중복 데이터 및 서버 응답의 용량을 줄이는 것도 이런 노력의 일환이었죠. 저사양 안드로이드 기기들을 위해 커스텀 웹뷰를 어플에 내장하기도 했습니다. 물론 이것 외에도 필연적으로 느릴 수 밖에 없는 실행속도를 UX를 통해 개선하는 것들도 있었습니다. 그렇지만 아무리 최적화를 해도 개선에는 한계가 있고, 최적화를 하는 시간이 예상보다 많이 소요되었습니다. &lt;/p&gt;
&lt;p&gt;여전히 팀에서는 “지금이라도 네이티브로 가야 할까?” 혹은 “리액트 네이티브라도 도입을 해볼까?”라는 이야기가 종종 나오는 편입니다. 이렇듯 적은 인원으로 빠르게 개발하면서 높은 사용성을 추구하는 것은 매우 도전적인 일입니다. 하지만 그만큼 기술적인 문제를 해결했을 때의 보람이 있다고 생각합니다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[삶은 무지개 색이어야 한다.]]></title><description><![CDATA[…]]></description><link>https://jaeyo.github.io/life-with-rainbow-colors/</link><guid isPermaLink="false">https://jaeyo.github.io/life-with-rainbow-colors/</guid><pubDate>Sat, 08 Jul 2017 06:21:00 GMT</pubDate><content:encoded>&lt;p&gt;아침부터 찌는 듯이 덥다가도 오후가 되니 거짓말처럼 폭우가 들이닥친다. 더운 공기가 사라진 것은 다행이지 싶지만 여전히 끈덕진걸 보니 여름은 여름인 모양이다.&lt;/p&gt;
&lt;p&gt;사실 “여름”이라는 단어를 곱씹고 있자면 어쩐지 그리운 느낌이 스물스물 든다. 꼬맹이 시절 방학숙제는 내팽게쳐놓고 하루종일 산으로 들로 뛰댕기던 모습들, 열대야에 잠못이룰때 티비에서 보던 공포영화 같은 것들이 생각난다. 친구들과 자전거 한 대에 둘씩 타고는 30분을 걸려 계곡으로 물놀이를 가던 장면들, 근처 실내 수영장에서 입술이 파래지도록 놀고 나온 후 수영장 옆 문구사에서 사먹었던 컵라면 같은 것들이 스쳐간다. &lt;/p&gt;
&lt;p&gt;그로부터 약 십여년이 지났고 내 삶은 많이도 변했다. 민증이 나오고 술, 담배를 합법적으로 하게 되었을 때도 어른이라는 자각은 그다지 없었지만 매달 내 통장을 스쳐 지나가는 대출이자를 보고 있자니 어른이란게 무언지 어렴풋이 알 것 같은 기분이다. 어느새 집에서 독립을 하니 주민등록등본 상에 엄마 아버지 이름이 없고 내가 세대주란다. 거기다 어찌어찌 결혼을 하고 나니 친구들은 나보고 이제 가장이란다. 삶이 참 많이도 변했다.&lt;/p&gt;
&lt;p&gt;나이를 한 살 두 살 먹을 때마다 “산다”는 것에 대해 새롭게 생각하게 된다. 입시란 걸 진지하게 준비하기 시작했던 시절부터 였을까, 당시의 나는 “산다”는 것은 무엇을 이루기 위해 준비해야 하는 과정 쯤으로 생각했던 것 같다. 어릴 때 엄마가 사주셨던 위인전 세트 때문 이었을까, 인서울을 했다던 학교 선배 이야기 때문 이었을까. 아니면 티비에 나오던 성공한 사람들의 화려한 삶의 단면 때문 이었을까. &lt;/p&gt;
&lt;p&gt;아침 8시까지 등교를 하고나면 밤 12시는 되어야 그 교문을 다시 나올 수는 있었다. 지겹고 답답했지만 버틸 만 했다. 끝이 분명히 있었고, 학교를 다니는 것 외에 삶을 즐겁게 만들 만한 취미도 딱히 없었으니까. 한달에 한번씩 치루는 모의고사 점수표가 일종의 당근과 채찍이 되어주었다. 원하는 대학에 진학을 하기 위한 “과정”을 그렇게 어찌어찌 버텨내었고 다행스럽게도 고3 겨울 수능날을 기점으로 그 길고 길었던 인내의 끝에 무사히 도달할 수 있었다. &lt;/p&gt;
&lt;p&gt;문득 지금의 삶과 비교를 해보게 된다. 지금도 나는 어딘가의 종착지에 닿기 위한 “과정”의 삶을 살고 있는걸까. 종착지로 삼기 좋은 것들은 차고 넘친다. 좋은 직장, 높은 연봉, 사회적인 명예나 좋은 차 같은 것들. 다소 속물스러운 늬앙스를 풍긴다는 점만 빼면 아주 매력적인 종착지 들이다. 고생스럽겠지만 페달을 밟아볼만 하다. 그 곳에 닿고 나면 삶은 행복해질테니까.&lt;/p&gt;
&lt;p&gt;아니, 삶은 행복해지지 않을 것이다.&lt;/p&gt;
&lt;p&gt;내일의 무언가를 위해 오늘을 희생하는 삶의 태도를 견지하는 이상, 내일도 다른 내일을 위해 희생될 수 밖에 없다. 목표했던 종착지에 닿았다고 생각했을 때에도 어느샌가 생겨버린 다른 종착지에 다시 닿기 위해 자전거에서 내릴 수 없을 것이다. 쉬지 않고 페달을 밟아야 한다. 아주 쉬운 이야기다. 삶이 행복해지기를 원한다면 그 시점은 내일이 아닌 오늘 이어야 한다.&lt;/p&gt;
&lt;p&gt;사실 이런 논리는 일과 삶의 균형에 대한 주제에 대해 이야기할 때 자주 나오는 흔한 클리셰다. 삶이 일이라는 괴물에 잡아먹히기 직전의 마지막 순간에서 모두가 하나같이 외치는 절규다. 또한 이런 외침을 반박하기 위한 논리 역시 어렵지 않게 찾아볼 수 있다. 사실 이 글을 쓰기 시작한 이유도 이와 관련이 있다.&lt;/p&gt;
&lt;p&gt;일이 삶이고 삶이 일인 사람들이 분명 있다. 그들에게 있어서 삶은 일에 잡아먹히는 성질의 것이 아니며 삶과 일이 자연스럽게 섞여있다. 특히 개발자들 사이에도 그런 사람들을 쉽게 찾아볼 수 있다. “좋아하는 일 = 잘 하는 일 = 돈이 되는 일” 정도가 되면 흔히들 덕업일치의 축복을 받았다고들 한다. 개인적으로 나는 이게 굉장히 큰 행운이라고 생각한다. 덕업일치가 안 되었더라면 나는 일찍히 개발자를 때려쳤겠지. 그렇게 되었다면 장사를 하고 있었을까. 그건 잘 모르겠다.&lt;/p&gt;
&lt;p&gt;현데 사람 산다는 게 또 참 어려운 것이, 덕업일치가 되는 단 몇가지의 즐거움 만으로 인생을 색칠해나가기에는 물감의 종류가 너무도 많다. 단 하나의 물감으로 인생을 색칠해나가는 것이 나쁘다는 이야기는 아니다. 오히려 위대해진 사람들은 대부분이 몇가지 안되는 물감에 선택과 집중을 한 사람들 일 것이다. 페이스북을 만든 주커버그 라던가, 만유인력을 발견한 뉴턴이라던가 뭐 그런 위인 격에 드는 사람들 말이다. &lt;/p&gt;
&lt;p&gt;하지만 나를 포함하여 대부분의 사람들은 단색으로 인생을 칠해나가는 것이 잘 되지도 않고, 또 그렇게 할 필요도 없다. 재미있는 일들, 하고 싶은 일들은 64색 크레파스 보다도 많다. 뷔페라도 온 마냥 그것들을 하나씩 물고 뜯고 즐기다보면 그 일들이 내가 잘하는 일이 아니기도 하고, 돈이 안되는 일이기도 하다. 그때부터 어른의 삶은 고달파진다.&lt;/p&gt;
&lt;p&gt;기타를 아주 그럴듯하게 치는 친구를 하나 알고 있다. 스쿨밴드로 시작해서 이제는 제법 난이도가 높은 곡들도 착착 연주해내고 언젠가부터는 자작곡을 만들어 페이스북에 간간히 올리곤 한다. 물론 프로 지향은 아니다. 단순히 연주를 하고 곡을 쓰는 것이 재미있는 것이다. 단지 그것만으로도 그의 삶에는 색깔이 하나 더해졌고 더 행복해졌을 것이다. 기타를 집었다고 해서 기타로 위대해질 필요는 없다. 인생은 그렇게 치열하게 사는 것이 아니라고 내 아버지는 말하셨다. 누군가는 기타로 세기의 클래식을 내면서 위대해지겠지만 내 친구에게 기타는 여가시간을 즐겁게 보내기 위한 수단일 뿐이다. &lt;/p&gt;
&lt;p&gt;졸릴 눈을 비비며 오랜만에 주저리 주저리 떠들다보니 글이 두서가 없다. 하고 싶은 말은 삶을 가능한 무지개 색으로 칠하면서 살자는 것이다. 여러 분야에 아마추어로 부담없이 걸치며 오늘을 좀 더 다채롭게 만들자는 이야기다. 위대해지기 위해서 오늘을 희생하지 말고 바로 오늘 행복하자는 이야기다. 사실 이 이야기들은 내 자신에게 해주고 싶은 이야기 이기도 하다. 위대해지기 위해서 거리낌없이 오늘들을 희생했던 어린날의 나에게 몇년을 더 산 지금의 내가 해주고 싶은 충고같은 이야기이기도 하다. &lt;/p&gt;</content:encoded></item><item><title><![CDATA[운전을 하고 싶다]]></title><description><![CDATA[운전을 하고 싶다. 틈 날때마다 생각한다. 참 희안한 것이, 운전면허를 따기전까지는 운전을 하고 싶다는 생각을 단 한번도 해본 적이 없다. 오히려 최대한 늦게 따야겠다고 다짐까지 했을 정도니까. 고…]]></description><link>https://jaeyo.github.io/drive/</link><guid isPermaLink="false">https://jaeyo.github.io/drive/</guid><pubDate>Thu, 18 May 2017 00:31:01 GMT</pubDate><content:encoded>&lt;p&gt;운전을 하고 싶다. 틈 날때마다 생각한다. 참 희안한 것이, 운전면허를 따기전까지는 운전을 하고 싶다는 생각을 단 한번도 해본 적이 없다. 오히려 최대한 늦게 따야겠다고 다짐까지 했을 정도니까. 고3 수능이 끝나고 친구들이 하나 둘씩 운전면허 학원에 등록을 할때도, “저것들은 차도 없는 것들이 왜 벌써부터 면허를 따려고 하나” 생각하며 알바 하기에 바빴고, 친구들과 여행을 가면 장거리 운전으로 피곤해 하는 친구에겐 미안하지만 (빈말이다. 사실 별로 미안하지도 않았다.) 뒷자리에서 편히 쉬면서 갈 수 있음을 즐기기도 했다. 지금 가지고 있는 운전면허도 아내와 제주도 여행을 앞두고 급하게 딴 것이다. 제주도에선 차가 없으면 불편하다는 아내의 성화가 없었다면 아마 높은 확률로 지금도 무면허였을 것이다.&lt;/p&gt;
&lt;p&gt;헌데 운전이 하고 싶다. 참으로 이상스런 일이 아닐 수 없다. 택시 앞자리에 앉으면 전방의 차들과 차선을 째려보며 마치 내가 운전을 하는 양 몰입을 하게 된다. 어쩌다 한번씩 고향에 내려가 엄마 차를 몰게 되기라도 하면 몇 시간이고 지치지 않고 여기, 또 저기로 쏘다니기 바쁘다. 이전까지는 몰랐다. 마음만 먹으면 언제든, 또 어디로든 갈 수 있다는 말이 주는 설렘을 전혀 알지 못했다. 아주 설레다 못해 명치께가 간질거리기까지 한다. &lt;/p&gt;
&lt;p&gt;2주 후에 계획된 제주도 여행에서도 관광 명소라던가, 맛집이라던가, 여행지에서의 멋진 숙소 같은 건 머릿 속에 들어오지도 않는다. 그저 운전할 일을 생각하며 설렌다. 해안 도로를 달리고, 그러다 배가 고파지면 맛집을 찾아다가 네비에 찍고 그대로 달린다. 그런 것들을 상상하게 된다. 참으로 이상한 일이 아닐 수 없다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[mariadb multi source replication]]></title><description><![CDATA[multi source replication 절차 slave가 될 mysql 인스턴스의 설정에 아래의 부분을 추가한다. master 데이터베이스에서 replication 용 계정 생성 후 권한을 부여한다 mysqldump 를 이용해서 master…]]></description><link>https://jaeyo.github.io/mariadb-multi-source-replication/</link><guid isPermaLink="false">https://jaeyo.github.io/mariadb-multi-source-replication/</guid><pubDate>Fri, 28 Apr 2017 17:51:00 GMT</pubDate><content:encoded>&lt;h2&gt;multi source replication 절차&lt;/h2&gt;
&lt;p&gt;slave가 될 mysql 인스턴스의 설정에 아래의 부분을 추가한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;# /etc/mysql/maridb.conf.d/50-server.cnf&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;mysqld&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token assign-left variable&quot;&gt;server_id&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;19823759&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;# master와 겹치지 않게&lt;/span&gt;
replicate-ignore-db&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;mysql &lt;span class=&quot;token comment&quot;&gt;# mysql 데이터베이스는 복제하지 않음&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;master 데이터베이스에서 replication 용 계정 생성 후 권한을 부여한다&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;grant replication slave on *.* to ‘repl’@‘%’ identified by ‘&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;repl123’&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;mysqldump 를 이용해서 master가 될 데이터베이스에서 덤프를 받는다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;mysqldump --databases database_1 database_2 --single_transaction --master-data&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; -h host_path -u account -p &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; dump.sql&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;락이 걸리는 걸 방지하기 위해 &lt;code class=&quot;language-text&quot;&gt;—single-transaction&lt;/code&gt; 옵션 추가해야 하며, 덤프를 받은 시점의 binlog 파일과 포지션을 확인하기 위해 &lt;code class=&quot;language-text&quot;&gt;—master-data=1&lt;/code&gt; 옵션 추가한다. 그러면 덤프 파일 상단에 &lt;code class=&quot;language-text&quot;&gt;change master …&lt;/code&gt; 구문이 생성되는데 multi source 로부터 replication 을 받아야 하기 때문에 아래와 같이 수정해준다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;CHANGE MASTER &lt;span class=&quot;token string&quot;&gt;&apos;master_name&apos;&lt;/span&gt; TO
&lt;span class=&quot;token assign-left variable&quot;&gt;master_host&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;host_path&apos;&lt;/span&gt;,
&lt;span class=&quot;token assign-left variable&quot;&gt;master_user&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;account&apos;&lt;/span&gt;,
&lt;span class=&quot;token assign-left variable&quot;&gt;master_password&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;password&apos;&lt;/span&gt;,
&lt;span class=&quot;token assign-left variable&quot;&gt;master_port&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3306&lt;/span&gt;,
&lt;span class=&quot;token assign-left variable&quot;&gt;MASTER_LOG_FILE&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;mysql-bin-changelog.052616&apos;&lt;/span&gt;, &lt;span class=&quot;token assign-left variable&quot;&gt;MASTER_LOG_POS&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;886626&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;# dump에 기록된 그대로 유지&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;만약 덤프 파일이 너무 커서 수정하기가 힘든 경우 아래와 같이 파일을 잘라서 수정한 후에 합치는 방법을 사용할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token function&quot;&gt;head&lt;/span&gt; -n &lt;span class=&quot;token number&quot;&gt;30&lt;/span&gt; dump.sql &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; new_dump.sql
&lt;span class=&quot;token function&quot;&gt;vim&lt;/span&gt; new_dump.sql
&lt;span class=&quot;token function&quot;&gt;tail&lt;/span&gt; -n +30 dump.sql &lt;span class=&quot;token operator&quot;&gt;&gt;&gt;&lt;/span&gt; new_dump.sql&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;slave가 될 데이터베이스에 덤프를 밀어넣는다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;mysql -h hostpath -u account -p database_name &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; dump.sql&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;여기서 database_name은 덤프 내 여러개의 데이터베이스가 담겨 있다고 해도 그 중 하나만 지정해도 되지만 지정된 데이터베이스는 미리 생성되어 있어야 한다.&lt;/p&gt;
&lt;p&gt;replication 스레드를 시작시킨다: &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;sql&quot;&gt;&lt;pre class=&quot;language-sql&quot;&gt;&lt;code class=&quot;language-sql&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;start&lt;/span&gt; slave &lt;span class=&quot;token string&quot;&gt;&apos;master_name&apos;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;기타 유의사항&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;replication 설정을 위해서는 super previleges가 필요한데 aws rds를 이용하면 일반 사용자가 super previleges를 가질 수 없다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;binary log가 너무 빨리 rotate 되는 경우에는 아래와 같이 retention 값을 확인 및 조정할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;call mysql.rds_show_configuration()&lt;/code&gt; 으로 &lt;code class=&quot;language-text&quot;&gt;binlog retention hours&lt;/code&gt; 값 확인&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;call mysql.rds_set_configuration(‘binlog retention hours’, 1);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[Too many open files]]></title><description><![CDATA[…]]></description><link>https://jaeyo.github.io/too-many-open-files/</link><guid isPermaLink="false">https://jaeyo.github.io/too-many-open-files/</guid><pubDate>Tue, 25 Apr 2017 19:25:01 GMT</pubDate><content:encoded>&lt;p&gt;집에서 기타치면서 놀고 있었는데 외출했던 아내가 귀가중이라는 메시지를 받았다. 집 앞 지하척 역으로 마중나가려고 핸드폰을 챙겨서 나가려는데 슬랙 메시지가 뭐가 많이 와있다. 평소 팀에서 커뮤니케이션을 슬랙으로 하기 때문에 별 생각없이 슬랙 메시지들을 확인해보고 있는데 서버쪽에 장애가 날 때 메시지가 오는 채널에 몇개의 메시지가 와있다. 순간 심장이 덜컹하며 확인해보니 몇가지 종류의 에러메시지가 꽤 여러번 발생한 형태다.&lt;/p&gt;
&lt;p&gt;첫번째 에러는 too many open files
두번째 에러는 unable to find server blabla&lt;/p&gt;
&lt;p&gt;두번째 에러로그는 심지어 디비서버를 못찾는다는 에러메시지!
디비 서버를 못찾았다면 서비스 자체가 안될텐데.
마음을 졸이며 우리 서비스에 들어가보니 일단 접속도 잘 되고 데이터 로딩도 문제없이 된다. 그렇다면 사태는 일단락 되었다는 이야긴데..&lt;/p&gt;
&lt;p&gt;그렇다고 손놓고 다시 기타나 뚱기뚱기할 수는 없으니 다시 로그를 뒤진다. was 로그와 syslog 등등을 종합적으로 뒤지고 수상해보이는 놈들은 죄 구글링을 해봤지만 별게 안나왔다.
할 수 없이 에러로그에 집중해보니, 일단 too many open files가 먼저 나고 그 다음에 디비서버를 못찾았다. 혹시나 싶어 로드밸런서에 물려있는 다른 서버를 확인해봤는데 다른 서버는 문제가 없었다. 그렇다면 실제 디비서버가 나가리가 되었다거나 한 문제는 아니라고 볼 수 있겠다고 생각했다. &lt;/p&gt;
&lt;p&gt;일단 too many open files가 떠있으니 ulimit 을 확인해주는데, 어라? 1024? 왜 이렇게 값이 작지?&lt;/p&gt;
&lt;p&gt;찬찬히 머리속에서 히스토리들을 뒤져보는데 한달전쯤 was를 변경했고 was가 변경되면서 리눅스 계정이 바꼈고 바뀐 리눅스 계정에 대해서 ulimit 값을 변경…을 안해줬구나. 아…&lt;/p&gt;</content:encoded></item><item><title><![CDATA[아닌 밤중에 리퀘스트가 튄다?]]></title><description><![CDATA[신규 서비스를 오픈하면서 서버 모니터링을 위해 aws cloudwatch를 사용하게 되었다. 원래는 cloudwatch와 newrelic 을 모두 선택지에 올려놓고 마지막까지 고민을 했다. newrelic…]]></description><link>https://jaeyo.github.io/weird-requests/</link><guid isPermaLink="false">https://jaeyo.github.io/weird-requests/</guid><pubDate>Tue, 25 Apr 2017 12:00:01 GMT</pubDate><content:encoded>&lt;p&gt;신규 서비스를 오픈하면서 서버 모니터링을 위해 aws cloudwatch를 사용하게 되었다. 원래는 cloudwatch와 newrelic 을 모두 선택지에 올려놓고 마지막까지 고민을 했다. newrelic 쪽이 기능도 많고 레퍼런스도 확실했지만 일부 서버에서 agent의 설치가 안되는 문제가 있었다. 사실 agent 설치 안되는 문제야 조금 더 시간을 들여서 파보면 해결할 수 있는 문제였겠지만 당장에 서비스 오픈을 코앞에 둔 상황에서 시간적인 여유가 부족했고, cloudwatch도 우리가 필요한 기능을 대부분 제공하고 있었기 때문에 cloudwatch로 가기로 했다.&lt;/p&gt;
&lt;p&gt;cpu, 메모리, 디스크 사용량 등의 지표를 대시보드로 구성해놓고 며칠 모니터링하고 있으려니까 좀 이상한 현상이 눈에 띄었다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/H99gBeu.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;일부 서버에서 주기적으로 network out이 튀고 있었다. 시간도 정확하게 6시 반쯤에 시작해서 11시에는 정상으로 돌아왔다. 제일 먼저 해당 서버에서 주기적으로 스케쥴링되어 돌고 있는 태스크가 있는지 확인했다. 하지만 스케쥴이 걸려있는 태스크라고는 cloudwatch 메트릭 값을 수집하는 agent 뿐이었고 이 에이전트도 5분마다 한번씩 실행되도록 구성되어 있었기 때문에 용의선상에서 벗어났다. 그외에 여러 의심되는 부분들을 샅샅이 뒤져봤으나 애초에 해당 서버는 aws s3에 있는 데이터들을 변환해 던져주는 역할만 하는 심플한 서버였기 때문에 원인을 진단하기가 어려웠다. network out이 튀는 정도가 분당 평균 5mb 근처였기 때문에 당장 서비스 운영에 문제를 줄만한 사안이 아니었고 이 문제 말고도 긴급을 요하는 태스크들이 많았기 때문에 자연히 칸반 보드의 todo list 어딘가로 해당 이슈는 쳐박히게 되었다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/RPkrl0O.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;문제는 다른 부분에서 다시 일어났다. 이 서버의 메모리 사용량이 슬금슬금 눈치채지 못할 정도로 느리게 증가하고 있었다. 최초 기동시에는 6퍼센트 정도에서 머물던 것이 시간이 지남에 따라 50%를 넘어 70%를 넘보는 수준까지 도달한 것이었다. 그때 팀원 중 한명이 s3fs를 의심하기 시작했다. 이 서버는 s3에 있는 데이터를 서빙하기 위해서 s3fs 라는 오픈소스를 이용해서 s3 특정 버킷을 가상으로 마운트 시켜놓고 쓰고 있었다. s3fs 프로젝트의 issue란을 뒤져보니 memory leak이 있다는 issue가 유난히 많았다. 팀 내부에서도 s3fs의 memory leak bug로 인한 현상으로 추정하고 옵션값 튜닝을 더 해보고 안되면 s3fs 대신 goofys 라는 솔루션으로 넘어가기로 했다. 하지만 그대로 s3fs의 memory leak bug 라고 단정해버리기엔 좀 찜찜한 것이, github issue에 올라온 memory leak 리포트들은 대부분 수십분에서 수 시간 내로 서버의 메모리를 모두 잡아먹고 뻗어버리는 현상이 발생했던 것과는 달리 우리 서버는 2주째 메모리 사용량을 야금야금 먹으면서 올라오긴 했지만 서버의 메모리를 모두 잡아먹진 않았다. 조금 더 살펴보기로 했다.&lt;/p&gt;
&lt;p&gt;일단 좀 더 정확한 정황을 확인하기 위해 s3fs의 디버그 로그 옵션을 켜고 다시 재기동하였다. syslog에 어마어마한 양의 로그가 쌓이기 시작했다. 양 자체가 워낙에 많에 전수조사를 할 수는 없었지만 일단 일부 확인한 내용으로는 이상해보이는 로그는 보이지 않았다. 그렇게 주말을 보내고 월요일 아침 다시 로그를 확인해보았다. 이 때 였다. 의심스러운 로그가 눈에 들어오기 시작했다.&lt;/p&gt;
&lt;p&gt;매일 아침 6시 25분마다 s3fs에 의해서 가상 마운트되어 있는 폴더 아래 모든 오브젝트들을 하나씩 순회하는 로그들이 찍혀있었다. 해당 s3 bucket에는 수만개 이상의 오브젝트들이 존재하고 있기 때문에 이 순회 작업은 수시간 후에야 끝났다. 그 때 잊고 있었던 네트워크 튐 현상이 떠올랐다. network out 지표에도 매일 아침 6시 반부터 11시 까지 그래프가 튀어 있었고 s3fs 로그에서는 그 시간대에 bucket내 모든 오브젝트들을 순회하는 로그가 찍혀있었다. 즉, s3fs 마운트 폴더에서의 순회요청은 그대로 디스크를 뒤지는 것이 아니라 network를 타고 나가 s3 서버로 요청을 던지게 되므로 network out 그래프가 튀게 된 것이다. 범인은 꼬리가 보이기 시작했다. 우리는 이 단서를 조금 더 파보기 시작했다.&lt;/p&gt;
&lt;p&gt;한가지 더 이상했던 것은 s3fs 마운트 폴더를 순회하는 로그가 정확히 각 syslog의 가장 첫부분부터 시작이 되고 있었다는 것이다. syslog는 logrotate에 의해서 롤링되고 있었기 때문에 logrotate가 실행되는 시점에 어떤 명령에 의해서 s3fs 마운트 폴더 순회 명령이 걸렸다고 추정할 수 있었다. 범인의 몽타주가 얼핏 보이는 듯 했다. logrotate 실행 스크립트가 담겨있는 cron.daily 폴더를 조회해보았다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/t2dXBN8.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;운좋게 몇놈 없었다. 이 놈들 중 범인이 있다고 확신한 나는 각 스크립트들을 하나씩 취조하기 시작했고 마침내 mlocate가 범인임을 확인할 수 있었다. mlocate는 빠른 파일 접근을 위해 디스크 내용을 인덱싱하는 역할을 하고 있었는데, 그 인덱싱 작업을 매일 아침마다 돌고 있었고 그 대상에는 안타깝게도 s3fs 마운트 폴더도 존재했던 것이다. mlocate가 인덱싱을 위해서 해당 폴더 내 모든 하위 플더들을 순회하면서 인덱싱을 했고, 순회하면서 발생하는 모든 요청들은 모두 s3 서버로의 요청이 되어 network out 지표를 튀게 만들었던 것이다. 메모리 사용량 증가도 자세한 경과까지는 확인하지 못했지만 짧은 시간내에 감당하기 힘든 네트워크 요청들로 인해서 발생한 것이라고 이해하기에 어려움이 없었다. &lt;/p&gt;
&lt;p&gt;조치는 간단했다. mlocate가 인덱싱을 하는 폴더들 중 s3fs 마운트 폴더를 예외로 넣은 후에 s3fs를 재기동해주었다. 메모리 사용량은 정상으로 돌아왔고 며칠이 지난 지금까지도 정상 범주를 벗어나지 않고 있다. network out 그래프 역시 정상의 범주로 돌아왔다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[겹겹의 공간들]]></title><description><![CDATA[…]]></description><link>https://jaeyo.github.io/spaces/</link><guid isPermaLink="false">https://jaeyo.github.io/spaces/</guid><pubDate>Tue, 25 Apr 2017 11:00:01 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;일상에서 우리가 기억이라고 부르는 것도 공간화한 기억이다. 프루스프가 “읽어버신 시간을 찾아서”에서 끊임없이 유년의 마을과 길과 집과 방들을 소환하는 까닭도, 추억이란 게 벌집 같은 공간 속에 특정의 시간들을 압축-공간화하고 있기 때문이다. 바슐라르가 “공감의 시학”에서 한 말처럼 “기억을 생생하게 하는 것은 시간이 아니라 공간이다. 우리들이 오랜 머무름에 의해 구체화된 지속의 아름다운 화석들을 발견하는 것은, 공간에 의해서, 공간 가운데서인 것이다”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;그러고보니, 추억이라는 것들을 하나둘씩 들여다보면 시간과 사람들, 그때 했던 생각이나 가졌던 감정들, 표정과 분위기같은 것들은 희끄무레하니 기억이 잘 나지 않는 반면에 공간만큼은 선명하게 기억이 난다. 생각보다 공간이라는 의미는 인간에게 이리도 푸대접받을 만한 작은 의미가 아닌걸까. 우리의 공간에 대한 인식이 이리 뚜렷한 이유가 뭘까.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[이직 면접 이야기]]></title><description><![CDATA[…]]></description><link>https://jaeyo.github.io/job-interview/</link><guid isPermaLink="false">https://jaeyo.github.io/job-interview/</guid><pubDate>Thu, 25 Aug 2016 14:40:55 GMT</pubDate><content:encoded>&lt;p&gt;직장인이 이직 면접을 준비하면서 받는 스트레스가 이혼을 할 때 받는 스트레스와 비슷하다는 이야기를 들은 적이 있다. 글쎄, 내 경우에 비추어보면 조금 과장되다 싶게 느껴지는 이야기긴 하지만, 그만치 감당해야 할 부담이 상당하다는 점에서는 공감을 하게 된다. 면접이 거듭될 때마다 자존감이 손바닥 위 모래처럼 사그러들고, 나는 지금까지 뭐하고 살아왔나 하는 인생 전반에 대한 후회를 하게 되는 것이, 이거 오래 준비하다간 내 명에 못살지 싶었다. 회사 입장에서는 심플하게 &lt;strong&gt;충원하려는 자리에 맞지 않아서&lt;/strong&gt; 퇴짜를 놓았다지만 지원자는 &lt;strong&gt;난 역시 이 정도밖에 안되는 인간인가&lt;/strong&gt; 하는 자괴감을 느끼게 되는 것이다.&lt;/p&gt;
&lt;p&gt;개인적인 경험에 빗대어 봤을 때, 긴장이 풀리면 면접이 잘 풀렸었다. 어느 순간부터 “지금 면접관이 날 어떻게 생각하고 있을까”하는 생각이 머릿 속에서 사라지고, “말빨”이 터져 진짜 내가 누군지를 여실히 떠들고나면 면접관들 입가에서 만족스런 미소를 여볼 수 있었다. 반대로 시작부터 긴장된 상태로 면접에 돌입하고, 지금 내가 긴장을 하고 있다는 사실을 수시로 확인하며 긴장은 더욱 더 증폭이 되고, 이쯤되면 면접관의 간단한 질문도 도저히 한국말로는 안들리게 되는 것이다. 질문을 듣고 고심하는 척 미간을 찌푸리지만 이미 머릿속은 백지다. 그리고 “지금 머릿속이 백지구나”라고 한번 더 되뇌이는 순간 사고는 정지되고 등 뒤로는 식은 땀이 흐른다.&lt;/p&gt;
&lt;p&gt;그래도 면접은 내게 대부분 즐거운 경험이었다. 실패에 대한 리스크가 작지 않다는 점에서 뭔가 위험천만한 스릴 같은 것들이 느껴지기도 했다. 면접을 준비하면서 “나는 이렇게 이런걸 쌓아왔어. 난 괜찮은 놈이야”라고 자기 최면을 걸고, 면접 당일에는 내 자신에 대한 이야기를 한시간에서 두시간 가량 마음껏 늘어놓을 수 있으니 두려움만 떨치면 이건 즐거운 경험이었다. 나는 말이 많은 편은 아니지만 자기 표현에 대한 욕구는 많은 사람이었다. “나는 이런 사람입니다, 이렇게 살아왔구요, 이런 것들을 중요하게 생각합니다.” 하고 떠들고 있다 보면 오랜 친구와 술에 거나하게 취해 인생이 어쩌고 하는 개똥철학을 주고 받는 장면을 떠올리게 한다.&lt;/p&gt;
&lt;p&gt;아쉬운 것은, 신입으로 경력을 쌓고 경력직으로 면접을 준비하게 되면 더이상 내 자신에 대한 의야기 보다는 내가 쌓아온 경험에 대해 이야기해야 하는 시간이 더 많았다. 하지만 이것 또한 나쁘지 않은 것이, 신입 시절 운좋게 내가 좋아할 수 있는 직무를 맡게 되면서 즐겁게 공부하고 경험해온 것들을 떠들 수 있어서 좋았다. &lt;/p&gt;
&lt;p&gt;면접 준비를 하고 면접에 떨어지고 나면 내가 가야할 길들이 좀 더 명확하게 느껴지곤 한다. 내가 가고싶은 회사, 가고싶은 직무의 구직공고에 붙어 있는 기본 요건과 우대 사항들을 보면서 앞으로 내가 공부해 나가야 될 청사진들을 대략적으로 잡을 수 있었고, 면접을 거친 후 내가 대답할 수 있었던 질문과, 대답하지 못했던 질문들을 다시 헤아리며 내가 지금 서있는 위치와 부족한 부분들을 객관적으로 알 수 있었다. &lt;/p&gt;
&lt;p&gt;그렇게 면접 준비와 면접 과정을 거쳐 지금 회사로 이직을 하게 되었고 꽤 만족스럽다고 생각하고 있다. 결과적으로 가고 싶은 회사, 하고 싶은 직무를 맡을 수 있었고, 원하는 조직 문화를 체험하게 됐으며, 똑똑한 사람들과 더 재미있는 일들을 할 수 있게 되었다. 이 회사에 평생 몸담을 수 있다면 그것도 그것 나름대로 좋겠지만 나는 아마 또 이직 준비를 해야 할 시기를 맞게 될 것이다. 하지만 이직을 준비하고 이직을 하게 되는 경험들이 크게 보면 나를 계속해서 채찍질하여 성장하게 만든다고 생각한다.&lt;/p&gt;</content:encoded></item></channel></rss>