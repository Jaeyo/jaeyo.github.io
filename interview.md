---
layout: page
title: interview
subtitle: 
permalink: /interview/
---


> [기술 면접 준비 (공개용)](https://docs.google.com/document/d/1wF7cNM13ge4LgIxO9NRYEkR7IuEvXHoBDKJvkgXk1gc/edit)

# 정리해야 할 개념들

* general
  - [ ] 알고리즘 / 데이터베이스 / 운영체제 / 네트워크 / 소프트웨어 공학
  - [ ] TCP, UDP 어느 서비스에 적합한지
* Java 개발 관련
  - [ ] JVM
  - [ ] GC
  - [ ] String & StringBuffer & StringBuilder
  - [ ] Synchronized
  - [ ] OOP
  - [ ] Dependency Injection
  - [ ] MVC
  - [ ] AOP
  - [ ] Process & Thread
  - [ ] Thread Pool
  - [X] List 관련 (LinkedList, ArrayList) (Quip에 정리되어 있음)
* 자료구조나 알고리즘
  - [X] 연결리스트
  - [X] 트리
  - [ ] 그래프 (Quip에 정리되어 있음)
  - [ ] 배열과 문자열
  - [ ] 재귀호출
  - [ ] 정렬
  - [ ] 기타 또 필요한 거
* 개념
  - [X] 객체지향 원칙
  - [X] 각Database Join Query (Quip에 정리되어 있음)
  - [ ] group by
* 기타
  - [ ] 해시 테이블과 이진 검색 트리를 비교해보고 각각의 장단점을 논하라. 메모리가 제한된 모바일 기기용 주소록에 사용할 자료구조로 설계한다면 어느 쪽을 쓰는 것이 좋을까?
  - [ ] ICPC 기출문제 찾아보기
  - [ ] 요즘 핫한 플랫폼이나 기술에 대한 대략적인 정리 해놓기 (ex. Kubernate)
  - [ ] 업무 성과 정리해놓기
* 기술과 무관한 질문
  * “무엇을 하고 싶습니까?”
    1. 훌륭한 팀의 멤버가 되는 것을 중요하게 여긴다는 것을 강조해야 함
  * “어떤 프로그래밍 언어를 가장 좋아하나요?”
    1. 다양한 언어에 익숙하고 한 언어로 세상 모든 일을 할 수 있는 것은 아니라고 생각한다.
    2. 일에 따라 가장 적합한 연장을 골라 쓰는 것이 중요
  * “업무 스타일이 어떻습니까?”
    1. 보통 업무 스타일이 딱 부러지게 정해져 있지 않은 회사에서 주로 나오는 질문
  * “자신의 경력에 대해 얘기해보세요.”
    1. 주요 업적을 분명하게 대답하고 자신이 맡았던 프로젝트에 대해 설명할 때 열의를 보여야
    2. 사실적인 내용만 열거하는 것 보다는 어떤 것을 배웠는지 설명
    3. 경험한 긍정적인 / 부정적인 면 모두 이야기하자
    4. 30 - 60초 정도가 적당
    5. 미리 연습해두고 면접에 임하자
  * “왜 이직을 하려고 하나요?”
    1. 환경 변화
    2. 어쩔 수 없는 요인 때문에 이직하는 경우
    3. 면접관이 이미 알고 있는 약점
    4. 위 세가지 위주로 답변하는 것이 좋다.
  * “왜 이 회사에서 당신을 고용해야 할까요?”
    1. 당신을 그 자리에서 합격시킬 만한 이유가 분명치 않다는 뜻이 담겨 있다.
    2. 왜 그 회사에서 일하고 싶은지, 그리고 왜 그 자리가 자기가 가지고 있는 능력에 잘 맞는 자리인지를 설명하면서 분위기를 긍정적으로 끌고 가자.
  * “이 회사에서 일하고 싶은 이유를 말씀해주세요.”
    1. “이 회사에 대해 어떤 걸 알고 있습니까?”와 동일한 질문
  * “혹시 질문 있습니까?”
    1. 꼭 어떤 질문을 해서 자신이 열의를 가지고 있음을 보일 것
    2. 사려 깊고 조리 있는 질문을 해서 좋은 정보도 얻고 면접관에게 좋은 인상

---

# 자료구조

## LinkedList, ArrayList

LinkedList는 ArrayList에 비해서 몇 개의 참조자만 바꿈으로써 새로운 자료의 삽입이나 기존 자료의 삭제를 위치에 관계없이 빠른 시간안에 수행하래 수 있다. ArrayList 같은 경우는 O(N) 만큼의 연산 속도가 걸리기 때문에 자료의 최대 개수에 영향을 받지만 LinkedList는 그런 제약을 받지 않는다. 또한 LinkedList는 무한 개수의 자료를 삽입할 수 있는 반면에(메모리의 용량이 무한하다고 가정할 때) ArrayList는 크기가 한정되어 있기 때문에 결국 포화상태에 이르게 된다. ArrayList의 크기를 재조정하는 연산을 수행하여 크기를 늘릴 수도 잇지만, 상당한 연산량이 요구된다.

ArrayList는 사이즈가 고정되어 있기 때문에 삽입 시 사이즈를 늘려주는 연산이 추가되어야 하고, 삭제 시에는 순차적인 인덱스 구조로 인해서 삭제된 빈 엔덱스를 채워야 하기 때문에 채워주는 연산이 추가된다. 이런 부가적인 연산은 시스템 성능 저하로 이어져 삽입 / 삭제가 빈번하게 발생하는 프로세스의 경우 치명적이다. 따라서 추가 / 삭제가 ArrayList 보다 빠르고 용이하다.

단, ArrayList는 무작위 접근이 가능하지만, LinkedList는 순차 접근만이 가능하다. 따라서 인덱스를 이용하여 자료를 검색하는 어플리케이션에는 적합하지 않다. 사실 순차 접근도 참조의 지역성 (한번 참조한 데이터는 다시 참조될 가능성이 높고 참조된 데이터의 주변의 데이터 역시 같이 참조될 가능성이 높다는 이론) 때문에 LinkedList 보다는 ArrayList가 훨씬 빠르다. n개의 자료를 저장할 때, ArrayList는 자료들을 하나의 연속적인 묶음으로 묶어 자료를 저장하는 반면, LinkedList는 자료를 저장하는 공간에 불연속적인 단위로 젖아하게 된다. 그렇기 때문에 LinkedList는 메모리 이곳저곳에 산재해 저장되어 있는 노드들을 접근하는데 ArrayList 보다 긴 지연시간이 소모된다. LinkedList의 똬 다른 단점은 참조자를 위해 추가적인 메모리를 할당해야 한다는 점이다. 자료들의 크기가 작은 리스트의 경우 참조자를 위한 추가적인 메로리 할당이 비효율적일 수 있다.

LinkedList의 장/단점을 정리하면 아래와 같다.

* 장점
  * 자료의 삽입 / 삭제가 용이
  * 리스트 내에서 자료의 이동이 필요치 않음
  * 사용 후 기억장소의 재사용이 가능
  * 연속적인 기억장소 할당이 필요치 않음
* 단점
  * 포인터의 사용으로 인해 저장공간 낭비
  * 알고리즘이 복잡
  * 특정 자료의 탐색 시간이 많이 소요됨

## Tree

### 이진 탐색 트리

1. 각 노드에 값이 존재
2. 값이 중복된 노드가 없음
3. 노드의 왼쪽 서브트리에는 해당 노드의 값보다 작은 값들을 지닌 노드로 구성
4. 반대로 노드의 오른쪽 서브트리에는 해동 노드의 값보다 큰 값들을 가진 노드로 구성
5. 좌우의 서브 트리는 다시 각각 이진 탐색 트리이어야 함

### AVL 트리

일반 이진 탐색 트리의 경우 한쪽 방향으로만 뻗어나가는 형태가 될 수 있으며 이렇게 되면 탐색 효율이 나빠진다. 따라서 노드의 삽입 / 삭제 시 회전을 통해 균형을 맞춰나가는 트리가 AVL 트리이다.

* 특징
  * 모든 노드의 서브트리 높이 차이가 1 이하이다. 만약 높이 차이가 2 이상 된다면 노드들은 스스로를 재배치하여 균형 상태를 유지한다.
  * 탐색은 이진 트리 탐색과 동일하다.
* 장점
  * 탐색속도가 빠르다.
  * 트리 전체를 재배열하지 않아도 트리의 균형이 유지된다

## Hashtable

Hashtable은 key / value 쌍을 젖아하는 자료구조로써 DB의 기초가 되는 매우 중요한 자료구조이다. 내부에 bucket 이라는 공간이 배열 형태로 존재하고, 이 bucket에는 linked list 가 주렁주렁 달려있다. Hashtable의 가장 큰 장점은 검색이 매우 빠르다는 것이다.

저장시에는 key 값을 hash function 을 통해 특정 값으로 변환한 후에 이 값을 가지고 해당 값을 저장할 bucket 의 index를 찾아 linked list 형태로 저장한다. linked list를 사용하는 이유는 hash 값 충돌을 피하기 위해서 쓰인다.

검색 / 삭제도 마찬가지로, key의 hash 값을 계산한 뒤, 원하는 bucket으로 가서 bucket에 달려있는 데이터 노드와 비교를 하여(선형 탐색) 원하는 데이터를 찾는다.

검색에 필요한 시간 중 bucket까지 찾아가는 시간은 Hashtable의 크기가 얼마가 되었든 동일하다. 그러나 Hashtable에 너무 많은 데이터가 있어서 충돌이 일어나는 경우, 탐색하는 데 추가적인 시간이 소요되게 된다.

주의할 것은, Hashtable에 저장된 데이터는 순서를 예측할 수 없다.

# Database

## Inner Join

Inner 조인은 우리가 생각하는 일반적인 용도에 사용한다.

```
SELECT gg._id, gg.name, s.title
FROM girl_group AS gg
JOIN song AS s
on s._id = gg.hit_song_id;
```

## Left Join, Right Joint

히트곡이 저장되어 있지 않은 경우 곡이 표시되지 않더라도 보이고 싶을 때는 하나의 테이블 기준으로 합치는 조인을 사용할 수 있다.

```
SELECT gg._id, gg.name, s.title
FROM girl_group AS gg
LEFT JOIN song AS s
on s._id = gg.hit_song_id;
```

마찬가지로 Right Join도 사용할 수 있다.

```
SELECT gg._id, gg.name, s.title
FROM girl_group AS gg
RIGHT JOIN song AS s
ON s._id = gg.hit_song_id;
```

# OOP 원칙

## 1. SRP(Single Responsibility Principle), 단일 책임 원칙

객체는 오직 하나의 책임을 가져야 한다. 즉, 객체는 오직 하나의 변경의 이유만을 가져야 한다.

사칙연산 함수를 가지고 있는 계산 클래스가 있다고 치자. 이 상태의 클래스는 오직 사칙연산 기능만을 책임진다. 만일 프로그램이 대대적으로 공사를 하게 되더라도 계산 클래스가 수정될만한 사유는 누가 봐도 사칙연산 함수와 관련된 문제 뿐이다. 이처럼 단일 책임 원칙은 클래스의 목적을 명확히 함으로써 구조가 난잡해지거나 수정사항이 불필요하게 넓어지는 것을 예방하고 기능을 명확히 분리할 수 있게 한다.

위의 원칙이 제대로 지켜지지 않으면 어떻게 될까? 어떤 프로그래머가 위의 계산 클래스를 통해 GUI를 가지는 계산기 프로그램을 개발하고 있다. 그런데 중간에 귀차니즘이 발동해 GUI 관련 코드를 계산 클래스에 때려박아 버렸다. 이렇게 되면 계산 클래스는 계산과 GUI라는 두 가지의 책임을 지니게 되는데 만일 GUI 관련 수정사항이 발생하게 되면 별 상관도 없어보이는 계산 클래스를 고치게 된다. 이처럼 하나의 클래스가 두 가지 이상의 책임을 지니게 되면 클래스의 목적이 모호해지고 기능을 수정할 때 영향을 받는 범위도 커져서 유지보수가 힘들어지며 결국 작성한 본인도 이게 정확히 뭐하는 클래스인지 명확히 설명할 수 없는 오징어 짬뽕같은 코드가 되어버린다.

## 2. OCP(Open Closed Principle), 개방 - 폐쇄 원칙

객체는 확장에 대해서는 개방적이고 수정에 대해서는 폐쇄적이어야 한다는 원칙이다. 즉, 객체 기능의 확장을 허용하고 스스로의 변경은 피해야 한다.

예를 들자면, 스타크래프트의 유닛을 만든다고 치자. 당신은 이런저런 공통 사항을 생각하며 메소드와 필드를 정의한다. 이 중엔 이동 메소드도 있다. 이동 메소드는 대상 위치를 인수로 받아 속도에 따라 대상 위치까지 유닛을 길찾기 인공지능을 사용해 이동한다. 하지만 잠깐 곰곰히 생각해보니 이러면 브루들링은 유닛의 기묘한 움직임을 구현할 때 애로사항이 꽃필 것 같다. 당신은 고민하다가 이동 함수에서 이동 패턴을 나타내는 함수 (혹은 클래스) 를 분리해서 구현을 하위 클래스에 맡긴다. 그러면 부르들링 클래스에선 이것만 재정의 / 설정하면 유닛 클래스의 변경 없이 색다른 움직임을 보여줄 수 있다. 이 '유닛' 클래스의 '이동' 메소드를 수정할 필요조차 없다. (수정에 대해선 폐쇄). 그냥 브루들링 클래스의 이동 패턴만 재정의하면 그만인 것이다. (확장에 대해선 개방)

## 3. LSP(Liskov Substitution Principle), 리스코프 치환 법칙

자식 클래스는 언제나 자신의 부모 클래스를 대체할 수 있다는 원칙이다. 즉, 부모 클래스가 들어갈 자리에 자식 클래스를 넣어도 계획대로 잘 작동해야 한다는 것. 상속의 본질인데 이를 지키지 않으면 부모 클래스 본래의 의미가 변해서 is a 관계가 박살나며, 그로 인해 다형성 불구자가 된다.

또다시 예를 들면, 컴퓨터용 '마우스' 클래스가 있다고 치자. 이 컴퓨터용 '마우스'는 어떤 마우스를 사오던 컴퓨터에 있는 ps/2 포트나 usb 포트에 연결할 수 있을 것이다. 사용 면에서는 왼쪽과 오른쪽 버튼, 그리고 휠이 있어 사용자가 누르거나 굴릴 수 있을 것이다. 또한 무언가 바닥에 대고 움직이면 컴퓨터가 이를 받아들인다는 것도 안다. 마우스가 볼마우스던 광마우스던 간에 암튼 사용자는 바닥에 착 붙여 움직일 것이고, 모든 마우스는 예상대로 신호를 보내 줄 것이다. 또한 만약 추가적인 특별한 버튼이 있는 마우스(상속)라도 그 버튼의 사용을 제외한 다른 부분은 보통의 마우스와 다를 바 없으므로 사용자는 그 마우스의 버튼이 뭔 역할을 하던간에 아무 문제없이 잘 사용한다. 하지만 오른쪽 / 왼쪽 버튼 대신 뒷쪽 / 앞쪽 버튼을 사용하는 기묘한 마우스가 나왔다고 치자. 사용자는 평소 보던 버튼을 누를 수 없으므로 이상을 호소할 것이다. 위의 볼마우스나 광마우스는 LSP를 훌륭하게 지키지만 바로 위의 예제는 전혀 그렇지 못하다고 볼 수 있다. 

## 4. ISP(Interface Segregation Principle), 인터페이스 분리 원칙

클라이언트에서 사용하지 않는 메소드는 사용해선 안된다. 그러므로 인터페이스를 다시 작게 나누어 만든다. OCP와 비슷한 느낌도 들지만 엄연히 다른 원칙이다. 하지만 ISP를 잘 지키면 OCP도 잘 지키게 될 확률이 비약적으로 증가한다.

예를 들어보자. 게임을 만드는데 충돌 처리와 이펙트 처리를 하는 서버를 각각 두고 이 처리 결과를 모두 클라이언트에게 보내야 한다고 가정하자. 그러면 아마 Client 라는 인터페이스를 정의하고 그 안에 충돌전달() 과 이펙트전달(이펙트)를 넣어놓을 것이다. 그리고 충돌 서버와 이펙트 서버에서 이 인터페이스를 구현하는 객체들을 모아두고 있으며 때에 따라 적절히 신호를 보낸다. 하지만 이렇게 해두면 충돌 서버에겐 쓸모없는 이펙트 전달 인터페이스가 제공되며, 이펙트 서버에겐 쓸모없는 충돌전달 인터페이스가 전달된다. 이를 막기 위해선 Client 인터페이스를 쪼개 이펙트 전달 가능 인터페이스와 충돌 전달 가능 인터페이스로 나눈 뒤, 충돌에는 충돌만, 이펙트에는 이펙트만 전달하면 될 것이다. 또한 Client 인터페이스는 남겨두되 이펙트 전달 가능과 충돌 전달 가능 이 둘을 상속하면 된다.

## 5. DIP(Dependency Inversion Principle), 의존성 역전 원칙

추상성이 높고 안정적인 고수준의 클래스는 구체적이고 불안정한 저수준의 클래스에 의존해서는 안된다는 원칙으로서, 일반적으로 객체지향의 인터페이스를 통해서 이 원칙을 준수할 수 있게 된다. (상대적으로 고수준인) 클라이언트는 저수준의 클래스에서 추상화한 인터페이스만을 바라보기 때문에, 이 인터페이스를 구현한 클래스는 클라이언트에 어떤 변경도 없이 얼마든지 나중에 교체될 수 있다. 

---

# 면접 질문

## 기술 부문 질문

### String, StringBuilder, StringBuffer의 차이점?

String은 기본적인 문자열을 다루기 위한 클래스. 하지만 concat을 할 때에는 성능에 좋지 않아 StringBuilder나 StringBuffer 등을 사용하게 된다. concat을 할 때마다 매번 String 인스턴스를 생성하는 방식이기 때문이다. jdk 1.5 버전 이후부터는 컴파일 단계에서 StringBuilder로 컴파일 되도록 변경되었다고 한다. 따라서 1.5 버전 이후부터는 그냥 String으로 concat을 해도 상관없다.

StringBuilder와 StringBuffer의 차이점은 동기화 지원 여부다. 두 클래스가 제공하는 함수들은 동일하지만 StringBuffer는 각 함수 별로 synchronized 키워드가 존재한다. 즉, 멀티스레드 상태에서 동기화를 지원한다는 것이다.

### stack과 queue에 대해 설명

stack은 후입선출(Last In First Out), queue는 선입선출(First In First Out)

queue의 문제점은 Linked List가 아닌 배열 형태로 구현한다면 pop된 이후에 나머지 요소들을 전부 한자리씩 땡겨주어야 한다는 것이다. 이를 해결하기 위해 나온 것이 원형큐이다. 원형큐에서는 pop을 하더라도 나머지 요소들을 재배열하지 않고 다만 요소들의 head와 tail만 포인터로 가르키는 방법으로 구현한다.

### 다형성에 대해 설명

일반적으로 "여러가지 형태를 가질 수 있는 능력"을 의미한다. 즉 하나의 타입으로 여러 타입으로 선언할 수 있다는 뜻이다.

Java에서는 상속과 인터페이스를 통해서 이루어진다. 예를 들어, 마우스에는 볼마우스, 광마우스, 트랙볼 등 여러가지 구현체가 있을 수 있지만 그 모든 것들을 마우스 하나의 타입으로 다룰 수 있도록 하는 성질이다.

### 데드락이란? 데드락을 피하는 방법

무한 교착 상태를 의미한다. 즉, A는 B가 가진 자원이 반납되기를 기다리고 있는데, B는 A가 가진 자원이 반납되기를 기다리는 상태.

데드락을 방지하는 방법으로는 아래와 같다.

* hold and wait. 한 번에 필요한 모든 자원을 모두 가지도록 하는 방법. 자원의 활용도가 떨어진다.
* no preemption. 하나의 작업이라도 실패하면 모든 자원을 release 한다.
* circular wait. 자원에 고유한 순서를 할당하고 순서대로 자원을 요구하도록 한다.

### DB에서 index란?

데이터베이스 내의 테이블에서 원하는 데이터를 좀더 빨리 찾을 수 있게 데이터의 위치 정보를 모아놓은 데이터베이스 내의 개체. 

생성 지침: where 절의 조회 조건이나 조인 조건으로 자주 사용되는 경우, 컬럼값이 unique한 경우, update가 자주 발생하지 않는 경우, 해당 컬럼을 통한 select 연산의 결과가 전체 데이터 수의 5% 이내인 큰 테이블

단, 데이터의 변경 작업(insert, update, delete)가 자주 일어날 경우 성능이 저하될 수 있다.

### RESTful의 의미는?

client - server 간의 통신에 사용되는 아키텍처의 일종으로 몇 가지 특징들이 있다.

stateless 하다. 세션 등으로 클라이언트와 서버의 상호작용에 따라 다른 동작을 해서는 안된다. 똑같은 요청은 똑같은 자원을 반환한다.

자원은 URI를 바탕으로 이해하기 쉬운 디레곹리 형 구조로 노출되어야 한다. 즉 URI만 보고 이게 어떤 자원인지 알 수 있어야 한다.

자원은 JSON이나 XML로 표현되어야 한다.

POST, GET, PUT, DELETE 4개의 HTTP 메소드들을 고려하여 동일한 URL일 경우라도 메소드마다 다르게 구현한다.

cache를 사용할 수 있다. cache는 http 표준에서 사용하는 last-modified나 e-tag 헤더를 이용하여 구현할 수 있다.

### 정렬 알고리즘 중 가장 빠른 방식은?

평균적인 상황에서는 quick sort가 가장 좋다.

### bubble sort란?

1번째와 2번째를 비교하여 정렬하고, 2번째와 3번째를 비교하여 정렬하고 ... 를 반복.

구현하기 제일 쉽지만 대부분의 경우 가장 최악의 성능을 보여준다.

### quick sort란?

적절한 하나의 피봇을 잡아 그보다 작은것은 앞으로 빼고 그 뒤에 피봇을 옮겨 피봇보다 작은 것, 큰 것으로 나눈 뒤 나누어진 각각에서 다시 피봇을 잡고 반복.

평균적인 상황에서 가장 좋은 성능을 낸다.

### js의 event delegation에 대해 설명

event를 listening해야하는 요소들이 많은 경우에 각 요소들에 전부 event listener를 달지 않고 요소들의 단일 부모에만 event listener를 달아서 bubbling되어 올라오는 event를 부모 단에서 처리해주는 패턴. 성능에 좋다.

### js의 hoisting에 대해 설명

특정 스코프 안에서 선언된 변수가 있다면 해당 변수는 인터프리터 엔진에 의해서 해당 스코프의 최상위단으로 끌어올려진다. 예를 들어 아래와 같이 작성한 코드는,

```javascript
function test() {
	console.log(value);
    var value = 'hello';
    console.log(value);
}
```

아래와 같이 실행되어 오류가 발생하지 않는다.

```javascript
function test() {
	var value;
    console.log(value);
    value = 'hello';
    console.log(value);
}
```

### js의 ==와 ===의 차이점

`==` 는 타입과 상관없이 비교하고 `===` 는 타입까지 비교한다.

```javascript
'185.3' == 185.3 // true
'153.3' === 185.3 // false
undefined == null // true
undefined === null // false
```

### js의 use strict의 의미

ECMA5 부터 적용되는 키워드인데 쉽게 말해 안전한 코딩을 위한 가이드 라인이라 할 수 있다.

strict 모드를 사용하게 되면 암시적으로 선언한 변수를 사용하거나 읽기 전용 속성에 값을 할당하거나 확장할 수 없는 개체에 속성을 추가할 수 없다.

### js의 let, var, const의 차이점

var는 function-scoped이고 let, const는 block-scoped 이다.

예를 들어, for문 안에서 i를 var로 선언했다면 for문이 종료된 이후에도 i를 참조할 수 있다.

let, const는 ECMA6부터 추가된 키워드로 var와 다르게 재선언이 불가능하다.

let은 변수에 재할당이 가능하지만, const는 변수 재선언, 재할당 모두 불가능하다.

### 뮤텍스와 세마포어에 대해 설명

Mutex는 일종의 Locking 메커니즘으로 lock을 가지고 있을 때만 공유 데이터에 접근 가낭하다는 개념. 화장실 갈 때 키를 가진 사람만 갈 수 있고 일을 다 본 후에 키를 반납하면 그 다음 사람이 이용 가능한 메커니즘. lock에 대한 소유권이 있다.

Semaphore는 동시에 리소스에 접근할 수 있는 허용 가능한 counter의 개수를 의미한다. 어느 병실에 최대 5명 까지 수용가능하다면 5명 까지 counting을 하고 그 이후는 밖에서 기다렸다가 한 사람이 나오면 다음 사람이 들어오는 메커니즘.

Mutex는 lock을 한개만 가질 수 있고 Semaphore는 여러 개를 가질 수 있다.

### thread에 대해 설명

하나의 프로세스 내에서 복수개로 실행될 수 있는 실행 흐름의 단위. 여러 스레드가 메모리를 공유하며 작동할 수 있으며, 너무 많이 생성되는 경우 context switching 부하가 생길 수 있다. 데드락 관련된 부분을 조심해야 한다.

### TDD의 의미

자신이 작성한 함수 단위에 대해 테스트를 수행하여 이후에 발생하는 테스트 단계에서의 결함 발생 비용을 줄여준다.

일반적인 소프트웨어 개발은 기능을 구현하고 테스트를 수행하는 형태이나 TDD는 이와 반대. 목표 이미지를 먼저 세우고 자동화된 테스트 케이스를 작성하고 만족시키는 로직을 작성하는 형태.

올 그린 상태는 만족감과 성취감을 제공한다.

복잡한 함수의 경우 테스트 케이스만 보고도 함수의 역할을 유추할 수 있는 경우가 있다.

결과적으로 지속적인 테스트 가능. 프로그램 안정성에 크게 기여.

### NoSQL이란?

Not Only SQL의 약자로 기존의 관계형 데이터베이스가 아닌 다른 형태의 데이터 저장 기술을 의미한다. 제품에 따라 각기 그 특성이 매우 달라서 하나의 제품군으로 정의할 수 없다.

일반적인 특징으로는,

테이블 스키마가 고정되지 않는다. 

분산형 구조를 가지는 경우가 많다.

대용량 데이터를 저장할 수 있도록 지원하는 경우가 많다.

보통 CAP 이론과 함께 많이 거론되는데, CAP 이론이란 Consistency, Availability, Partitioning 세가지의 요소 중 보통 2가지의 요소에 집중한다는 의미.

Consistency: 분산된 어느 노드를 접근하더라도 데이터의 값이 같아야 한다.

Availability: 하나 이상의 노드가 Fail 되더라도 정상적으로 요청을 처리할 수 있어야 한다.

Partitioning: 물리적 네트워크 분산 환경에서 시스템이 잘 작동한다.

### OS의 페이징 개념

페이징이란 사용되지 않고 있는 메모리 영역을 디스크에 일시적으로 저장하는 과정을 말한다. 이 테크닉을 이용하면 애플리케이션은 실제 물리 메모리 용량보다 더 많이 사용할 수 있다.

## 경험 부문 질문

### 최근에 공부한 기술이 있다면?

이벤트 소싱에 대한 개념을 근래에 공부한 적이 있습니다. 이벤트 소싱 개념을 들여다보게 된 이유는 기존 레거시 서비스를 MSA 형태로 분리해서 별도의 팀들이 관리하게끔 하는 일을 하게 되었는데 이때 서비스 별 동기화되어야 하는 데이터를 처리하기 위한 방법 중 하나로 고려되었기 때문입니다.

이벤트 소싱이 일반적인 개발 방법과 다른 부분은, 일반적으로는 어떠한 로직을 수행한 결과값만을 저장해왔다면 이벤트 소싱은 순차적으로 발생한 이벤트들을 모두 저장한다는 점입니다. 예를 들어 사용자가 데이터 A, B를 추가했다가 A를 삭제한 경우 데이터베이스에는 B만 남아있게 되지만 이벤트 소싱을 사용하면 A, B를 추가한 이벤트와 A를 삭제한 이벤트가 모두 남게 되는 것입니다.

이러한 방법을 고려하게 되었던 이유는, 팀간 데이터 불일치가 일어나거나 데이터가 깨졌을 경우 쌓인 이벤트들을 전부 다시 훑어서 데이터를 복구할 수 있다는 점 때문이었습니다.

결과적으로 현업에는 적용하지 못했는데 그 이유는, 레거시를 다루는 팀 쪽에서 발생되는 모든 이벤트들을 저희팀으로 넘겨줘야 하는 상황이었는데 레거시의 규모가 크고 오래되다보니 모든 이벤트들을 빠짐없이 넘겨주는 것을 보장하기가 힘들다는 것이 이유였습니다.

이벤트소싱을 사용하다보면 조회 요청시에 조회 대상 데이터의 모든 이벤트 이력을 훑어야 하기 때문에 성능이 좋지 않습니다. 이러한 부분을 해결하기 위해 특정 시점마다 스냅샷을 떠놓는 방법이 있습니다.

하지만 스냅샷으로도 성능을 필요한 만큼 끌어올리기는 쉽지 않습니다. 따라서 CQRS 형태로 사용하는 것이 일반적입니다. CQRS란 명령을 처리하는 책임과 조회를 처리하는 책임을 분리하는 패턴입니다. 이 패턴을 이벤트소싱과 조합하면, 명령을 처리하는 데이터 저장소와 조회를 처리하는 데이터 저장소를 분리합니다. 이후에 데이터 변경 요청을 포함하는 명령이 실행되면 해당 명령은 이벤트로써 이벤트 소싱 데이터 저장소에 기록되고 그렇게 쌓인 이벤트 데이터들을 가지고 조회를 책임지는 데이터 저장소에 반영을 해줍니다. 이후에 조회 요청이 날아오면 조회를 책임지는 저장소에서 처리를 합니다.

또한 Operational Transformation 알고리즘에 대해서도 얼마전에 공부를 한 적이 있습니다. OT 알고리즘은 실시간 문서 편집기 등에서 데이터 동기화를 수행하기 위해 만들어진 알고리즘입니다. 실시간 편집기를 구현하다보면 사용자별로 네트워크 단에서 발생되는 지연 때문에 서로 다른 데이터를 가지게 되는 시점에서 서로 다른 액션들이 취해지게 되는데 이를 해결하기 위한 방법입니다.

이 알고리즘에 관심을 가지게 되었던 이유는 당시 팀이 부여받았던 미션이 디바이스별 동기화였기 때문입니다. 디바이스 특성상 오프라인 상태인 시간이 굉장히 긴 경우가 많았기 때문에 동기화 설계를 꼼꼼하게 해야 했습니다. 전 직장에서 OT 알고리즘을 응용하여 동기화 설계를 수행했습니다.

OT 알고리즘을 응용한 방법은, 동기화가 되어야 하는 각 디바이스들이 어떤 디렉토리 구조와 비슷한 데이터를 들고 있어야 하는 상황이었습니다. 이때 A 디바이스에서는 root에 있는 파일을 지웠고 B 디바이스에서는 같은 파일을 특정 하위 폴더 아래로 이동시켜는 액션을 취했다고 하면, OT 알고리즘을 적용시키지 않으면 A 디바이스에서 취한 오퍼레이션이 B 디바이스에 동기화되었을 때 파일은 삭제되지 않게 됩니다.

### 최근 본 기술서적 중 기억에 남는 부분

Immutable Infrastructure 와 관련된 부분을 읽은 기억이 제일 최근에 인상 깊었던 부분입니다. 특정 책을 읽다가 II과 관련된 내용을 읽은게 아니라 II와 관련된 내용을 찾아보려고 여러 책을 뒤진거라 정확히 책 제목은 기억이 나질 않습니다만 클라우드에서 인프라를 구성하는 방법을 설명해주는 책과 인프라 실전 구축 가이드 같은 책들에서 본 것 같습니다.

II가 해결하고자 하는 상황은 II의 반대인 Mutable Infrastructure 입니다. 의미 그대로 보통 전통적으로 인프라를 다룰 때는 처음 구축을 해놓고 필요시마다 애플리케이션을 설치한다던지 패키지를 업데이트하거나 OS 버전을 올려준다던지 하는 변경 동작들을 하게 되는데요, 다루게 되는 서버의 대수가 많아지거나 중간에 관리 인원이 변경되거나 하면 이 히스토리에 대해서 알기 어려워지는 문제들이 많이 발생합니다. 이러한 변경사항에 대해서는 철저하게 기록이 되고 관리가 되어야 하는데 현실적으로 그러리가 쉽지 않은 점이 있습니다.

II는 그러한 상황을 해결하고자 나온 패러다임인데, 말이 좀 거창하지 사실 요즘 많이 하는 Docker를 이용한 컨테이너 기반 배포나 Ansible 같은 툴을 이용해서 서버 구성을 자동화하고 클라우드 상에서 하는 VM 기반의 배포 시스템을 추상적으로 설명하는 개념입니다. 서버에 변경사항 있는 경우에는 운영중인 서버에 변경을 가하는 것이 아니라, 별도의 서버에 변경 사항을 반영시켜놓고 해당 서버로 갈아치는 개념을 이야기합니다. 여기에 이런 서버/컨테이너의 추가/삭제같은 작업들이 API를 통해서 지원이 되어야 하고 이를 통해서 자동화가 가능해야 한다 뭐 이런 부분들이 II의 패러다임이라고 볼 수 있을 것 같습니다.

이렇게 II를 도입하게 되면 서버 별로 변경사항이 다르게 적용되는 문제나 스케일 아웃시에 수월해지고 서버 변경이 단순해지고 이력을 관리할 수 있다 정도가 될 수 있을 것 같습니다.

반대로 단점으로는 간단한 설정 변경도 새로 서버/컨테이너를 기동해야 하기 때문에 상태 변경 비용의 증가가 일어난다는 점이 있구요, 결과적으로 서버/컨테이너의 생성 및 파기 작업이 자주 일어나기 때문에 이에 따른 비용 문제도 있을 수 있습니다. 또한 웹서버 같은 stateless 서버들만 이런 방식으로 다룰 수 있고 stateful 한 서버는 II로는 다룰 수 없다는 점도 있습니다.

### 기억에 남는 트러블슈팅 경험이 있다면

리디스토리 서비스 런칭 후 모니터링 중에 이상한 지표를 발견한 적이 있습니다. 일부 서버들에서 network out 트래픽이 튀고 있었습니다. 차트를 자세히 살펴보니 정확히 6시 반쯤 시작해서 11시 경에는 정상 수치로 돌아왔습니다. 제일 먼저 해당 서버에서 주기적으로 스케쥴링 되어있는 태스크들을 확인했으나 해당 서버에 걸려있는 태스크라고는 CloudWatch 지표값들을 수집하는 Agent 뿐이었고 해당 태스크도 5분마다 실행되도록 되어있어서 용의선상에서 벗어났습니다. 

문제는 다른 부분에서도 일어나고 있었습니다. 메모리 사용량이 조금씩 증가하고 있었습니다. 소스코드를 비롯하여 의심될만한 부분들을 샅샅이 뒤져봤으나 애초에 해당 서버는 AWS S3에 있는 데이터를 변환해서 던져주는 심플한 역할만 하는 서버였기 때문에 원인을 진단하기 어려웠습니다.

그러던 중 서버에 설치되어 있는 s3fs가 눈에 들어왔습니다. 당시 해당 서버는 S3에 있는 데이터를 서빙하기 위해 s3fs라는 오픈소스를 사용하여 S3의 특정 버킷을 가상으로 마운트 시켜놓고 있었습니다. s3fs 프로젝트의 issue 들을 뒤져보니 memory leak 있다는 issue가 유난히 많았습니다. 이에 팀 내부에서 s3fs 버그 현상으로 진단하고 s3fs 의 대용으로 쓸 수 있는 goofys 로 넘어가자는 이야기가 나왔으나 그렇게 단정해버리기엔 찜찜한 부분이 있었습니다. s3fs 의 memory leak bug 라고 올라온 리포트들은 대부분 수십 분에서 길어야 수 시간 내에 서버의 메모리를 모두 잡아먹고 뻗어버리는 현상이 있다고 올라와 있었습니다. 하지만 우리의 증상은 일주일 동안 전체 메모리의 20% 정도를 추가 점유하는 현상만 보였을 뿐이었습니다.

좀 더 정확한 정황을 확인하기 위해 s3fs의 디버그 로그 옵션을 켜고 재기동 후 다음날 로그를 확인하니 확실히 이상한 부분이 눈에 띄었습니다. network out 트래픽 지표가 튀기 시작했던 6시 반 경에 s3fs에 의해서 가상 마운트되어 있는 폴더의 모든 오브젝트들을 하나씩 순회하는 로그들이 찍혀있었습니다. S3 버킷에 있는 수만개의 오브젝트들을 전부 순회하고 마친 시간은 network out 트래픽 지표에서 튀는 차트가 정상으로 돌아온 시간과 일치했습니다. 슬슬 꼬리가 보이기 시작했습니다. 무언가로 인해서 매일 아침 6시 반경에 s3fs 마운트 폴더로 순회 요청이 던져지고, 마운트 폴더로의 순회 요청은 그대로 디스크를 뒤지는 것이 아니라 네트워크를 타고 S3 서버로 요청을 던지게 되면서 network out 트래픽 지표가 튀게 되는 것이었습니다. 

또 한가지 이상했던 점은 s3fs를 순회하는 로그가 정확히 syslog의 가장 첫줄부터 시작되고 있었다는 점입니다. syslog는 logrotate에 의해서 롤링되고 있었기 때문에 logrotate가 실행되는 시점에 어떤 명령에 의해서 s3fs 마운트 폴더를 순회하는 명령이 발생되었다고 추정할 수 있었습니다. 그렇게 logrotate 실행 스크립트가 담겨있는 cron.daily 폴더를 확인해보았고 mlocate 라는 프로세스를 찾아낼 수 있었습니다. mlocate는 빠른 파일 접근을 위해 디스크 내용을 인덱싱하는 역할을 하고 있었는데, 그 인덱싱 작업은 매일 아침마다 돌고 있었고 그 대상에는 s3fs 마운트 폴더로 포함되어 있었습니다. mlocate가 인덱싱을 위해서 매일 아침매다 해당 폴더를 순회하였고, 이로인해 S3에 요청이 날아가면서 network out 트래픽 지표가 튀게 되었던 것이었습니다. 메모리 사용량 증가도 정확한 원인까지는 확인할 수 없었지만 짧은 시간 내 감당하기 힘든 네트워크 요청들로 인해서 발생한 것이라고 이해하기에 어려움이 없었습니다.

이에 mlocate가 인덱싱을 하는 대상 폴더에서 s3fs를 제외 처리 하였고, 그 결과 network out 트래픽 지표와 메모리 사용량 지표 모두 정상으로 돌아왔습니다.

### 팀원들간의 의견 불일치를 해결하는 당신만의 방법이 있다면? 팀원 중 의견이 안맞는 직원이 있다면?

우선적으로 팀의 판단 기준을 정해야 할 것 같습니다. 일의 방향을 결정함에 있어서 우선순위 따라서 고려해야 하는 기준들을 미리 정해두면 불필요한 충돌이 많이 없어질 것 같습니다. 그래도 충돌하는 부분이 있다면 상충하는 각 의견들을 구체화시켜서 팀원 모두와 함께 공유해놓고 이야기를 해야 할 것 같습니다. 말로만 이야기를 주고받다보면 같은 것을 놓고도 서로 다르게 이야기를 하는 경우가 많으므로 일단 그 생각의 형태 자체를 통일시켜놓고 거기서 각 의견을 부분별로 쪼개서 타협안을 만들어 나가는 것이 합리적이라고 생각합니다.

### 진행했던 프로젝트를 기술적인 측면에서 설명

### 이전 업무에서 기능을 개선한 사례에 대해 설명

### 프로젝트를 진행하면서 활용한 프로그래밍 언어는 무엇? 그 도구를 활용하면서 가장 어려웠던 점은 무엇?

### 가장 최근에 겪은 기술적인 어려움과 그것을 어떻게 극복했는지?

### 웹 사이트를 새로 만들거나 유지보수할 때 성능을 향상시키기 위해서 사용한 테크닉에 대해서 설명해주세요

### 웹 페이지를 만들 때의 당신의 worlflow를 설명해주세요

### 시니어 개발자란?

### 프로젝트 팀 내에서 주로 어떤 역할을 해 왔는지를 기술해주세요.

팀이 당면한 문제를 해결하기 위해 새로운 해결책을 고민하고 선행 기술을 팀 내에 공유하는 역할을 많이 했습니다. 특히 POC를 위한 프로토타이핑에 투입된 경우도 많습니다. 

이글루시큐리티 재직시절 신규 로그 수집 엔진을 실험하는 과정에서 프로토타이핑에 일부 참여했으며 언어는 Go를 썼습니다. 또한 당시 개발팀에 부하가 많이 걸리던 Agent 연동 관련 이슈를 해결하기 위해 새로운 Agent의 설계 및 구현을 도맡아 담당하여 해결한 경험이 있습니다. 

리디로 이직한 이후에도 리디스토리라는 신규 서비스 팀 구축시에 초기 멤버로 팀 변경 제안을 받아 성공적으로 런칭 및 운영하였습니다. 이때 기존 template 기반의 프론트엔드 형태로 구성했다가 성능 문제로 SPA로 넘어가야 하는 상황이었습니다. 당시 팀에 SPA에 대한 경험을 한 인원이 없어 본인이 선행하여 React-Router를 이용해 SPA를 위한 기본 틀을 잡은 뒤에 코딩 가이드를 정리하여 팀 내에 공유하였습니다. 

이후에도 새로운 프로젝트를 위한 언어 및 프레임워크로써 Kotlin과 Spring Boot가 고려되었을 때의 프로토타이핑도 크게 참여했으며, 개발 환경 및 배포 환경을 위해 Docker를 도입할 때에도 주도적으로 환경을 구성한 경험이 있습니다.

## 인성 부문 질문

### 당신의 꿈은?

### 이전 직장에서 업무로 어떤 평가를 받았는지?

### 왜 우리 회사에 오고 싶은지?

### 다른 사람은 당신을 어떤 사람이라고 생각?

# 코딩 테스트

## 단일 연결 리스트에서 맨 뒤에서 m번째 원소를 반환하는 함수를 구현

## 문자열이 반복되지 않는 첫 번째 문자를 찾아내는 효율적인 함수

"total" → "o"

"teeter" → "r"

## 문자열에 들어있는 단어의 순서를 뒤집는 함수 작성

"do or do not" → "not do or do"

## 두개의 문자열이 같은지를 검사하는, strcmp() 함수 구현. 같은 문자열이라면 0을 리턴

"abc", "cbc" → 음수

"cbc", "abc" → 양수

"abcde" → "abc" → 음수

## 두 개의 스택으로 큐 구현

## LinkedList를 뒤집는 연산

## 이진검색트리 구현

# 면접관들의 마인드셋

* 우리 회사의 업무를 받아들일 준비가 되어 있는가
* 설령 회사에서 주로 사용하는 언어를 몰라도 배울 자세가 되어 있는가
* 이미 구축된 회사 시스템에 적응할수 있는 사람인가
* 연봉 이상의 잠재력을 지녔는가
* 배우려는 사람인가, 일을 해서 이윤 창출에 도움이 될 만한 사람인가
* 우리회사에 입사하고자 하는 의자가 강한가

# 지원자로써의 마인드셋

* 이러한 문제가 있었는데 이 문제는 왜 어려웠고 이렇게 해결하였더니 좋은 결과를 얻었다. (단순히 어려운 일을 했다보다 문제 해결 능력)

# 회사에 던질 질문들

* 내가 들어가면 어떤 직무를 맡게 되는지? 팀 구성은 어떻게 되는지?
* 어떤 기술들을 사용하게 되는지?