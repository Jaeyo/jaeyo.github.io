<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title> interview —  &raquo;  FlowerBud</title>
<meta name="description" content="Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
">

<link rel="canonical" href="https://jaeyo.github.io/interview/">
        




<!-- Twitter Cards -->
<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="interview" />
<meta name="twitter:description" content="Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
" />
<meta name="twitter:image" content="https://jaeyo.github.io" />

<!-- Google plus -->
<meta name="author" content="">
<link rel="author" href="">

<!-- Open Graph -->
<meta property="og:locale" content="">
<meta property="og:type" content="article">
<meta property="og:title" content="interview">
<meta property="og:description" content="Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
">
<meta property="og:url" content="https://jaeyo.github.io/interview/">
<meta property="og:site_name" content="FlowerBud">

        <link href='http://fonts.googleapis.com/css?family=Inconsolata:400,700' rel='stylesheet' type='text/css'>
<link rel="stylesheet" href="/assets/vendor/normalize-css/normalize.css">
<link rel="stylesheet" href="/css/main.css">

  <link rel="stylesheet" href="/assets/vendor/highlight/styles/solarized_dark.css">

<link rel="stylesheet" href="/assets/vendor/font-awesome/css/font-awesome.css">
    </head>

    <body>
        <div class="wrapper">
            <header class="header">
    <div class="navigation">
        <a href="/" class="logo">FlowerBud</a>

        <ul class="menu">
            <li class="menu__entry"><a href="/about">About</a></li>
            <li class="menu__entry"><a href="/">Blog</a></li>
        </ul>
    </div>

    <ul class="social-links">
        
            <a href="https://github.com/Jaeyo" class="social-links__entry" target="_blank">
                <i class="fa fa-github"></i>
            </a>
        

        
            <a href="https://twitter.com/flower_bud_" class="social-links__entry" target="_blank">
                <i class="fa fa-twitter"></i>
            </a>
        
    </ul>
</header>

            <h1 class="page-title">
    <div class="page-title__text">interview</div>
    <div class="page-title__subtitle"></div>
</h1>

<blockquote>
  <p><a href="https://docs.google.com/document/d/1wF7cNM13ge4LgIxO9NRYEkR7IuEvXHoBDKJvkgXk1gc/edit">기술 면접 준비 (공개용)</a></p>
</blockquote>

<h1 id="채용공고">채용공고</h1>

<ul>
  <li>직무
    <ul>
      <li>Service Platform Programming</li>
    </ul>
  </li>
  <li>업무 내용
    <ul>
      <li>모바일 앱 모니터링 시스템을 개발합니다.</li>
      <li>현재 개발 환경
        <ul>
          <li>사용 언어: JavaScript(node.js) + TypeScript (추후 변경될 수 있으므로 Java 등 타 서버 언어에 대한 지식이 있으면 좋습니다.)</li>
          <li>DBMS: MySQL 및 NoSQL (Redis, MongoDB 등)</li>
          <li>프레임워크: express.js(서버), Angular(운영툴)</li>
          <li>기타: 로그 및 통계 처리 프로젝트이므로 대용량 데이터에 대한 통계 처리와 차트 등의 보고서 UI 개발이 포함됩니다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>경력 기간: 상기 업무에 대한 경력 4년 ~</li>
  <li>상세 자격
    <ul>
      <li>필요 역량
        <ul>
          <li>OS, 자료구조 등 전산학 기본 지식</li>
          <li>C/C++/Java 언어 및 개발과정에 대한 기본적인 지식</li>
          <li>JavaScript 기반 웹 및 node.js + MySQL 서버 개발 능력</li>
          <li>Linux 서버에서의 서비스 운영 및 shell script 개발 능력</li>
        </ul>
      </li>
      <li>경력 8년 이상일 경우 추가 요구 역량
        <ul>
          <li>형상관리에서 배포 자동화까지 개발 프로세스에 대한 전반적인 지식 및 경험</li>
          <li>부하를 고려한 DB 설계 능력</li>
        </ul>
      </li>
      <li>우대 사항
        <ul>
          <li>iOS/Android 에서의 native 앱/게임 엔진(unity, unreal engine) 기반 개발에 대한 기초적인 지식 및 경험</li>
          <li>DB 이중화 등 failover 등 부하 분산을 고려한 라이브 서비스 구성에 대한 지식 및 경험</li>
          <li>AWS 등 Cloud 환경이나 Docker 와 같은 Container 환경을 사용해 본 경험</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="정리해야-할-개념들">정리해야 할 개념들</h1>

<ul>
  <li>general
    <ul class="task-list">
      <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />알고리즘 / 데이터베이스 / 운영체제 / 네트워크 / 소프트웨어 공학</li>
      <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />TCP, UDP 어느 서비스에 적합한지</li>
    </ul>
  </li>
  <li>Java 개발 관련
    <ul class="task-list">
      <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" /><strong><em>GC</em></strong></li>
      <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" />String &amp; StringBuffer &amp; StringBuilder</li>
      <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Synchronized</li>
      <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" />OOP</li>
      <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Dependency Injection</li>
      <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />MVC</li>
      <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />AOP</li>
      <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" />Process &amp; Thread</li>
      <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Thread Pool</li>
      <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" />List 관련 (LinkedList, ArrayList) (Quip에 정리되어 있음)</li>
    </ul>
  </li>
  <li>자료구조나 알고리즘
    <ul class="task-list">
      <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" />연결리스트</li>
      <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" />트리</li>
      <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />그래프 (Quip에 정리되어 있음)</li>
      <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />배열과 문자열</li>
      <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />재귀호출</li>
      <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />정렬</li>
      <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />기타 또 필요한 거</li>
    </ul>
  </li>
  <li>개념
    <ul class="task-list">
      <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" />객체지향 원칙</li>
      <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" />각Database Join Query (Quip에 정리되어 있음)</li>
      <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />group by</li>
    </ul>
  </li>
  <li>기타
    <ul class="task-list">
      <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" />해시 테이블과 이진 검색 트리를 비교해보고 각각의 장단점을 논하라. 메모리가 제한된 모바일 기기용 주소록에 사용할 자료구조로 설계한다면 어느 쪽을 쓰는 것이 좋을까?</li>
      <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />ICPC 기출문제 찾아보기</li>
      <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />요즘 핫한 플랫폼이나 기술에 대한 대략적인 정리 해놓기 (ex. Kubernate)</li>
      <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />업무 성과 정리해놓기</li>
    </ul>
  </li>
  <li>기술과 무관한 질문</li>
</ul>

<hr />

<h1 id="자료구조">자료구조</h1>

<h2 id="linkedlist-arraylist">LinkedList, ArrayList</h2>

<p>LinkedList는 ArrayList에 비해서 몇 개의 참조자만 바꿈으로써 새로운 자료의 삽입이나 기존 자료의 삭제를 위치에 관계없이 빠른 시간안에 수행하래 수 있다. ArrayList 같은 경우는 O(N) 만큼의 연산 속도가 걸리기 때문에 자료의 최대 개수에 영향을 받지만 LinkedList는 그런 제약을 받지 않는다. 또한 LinkedList는 무한 개수의 자료를 삽입할 수 있는 반면에(메모리의 용량이 무한하다고 가정할 때) ArrayList는 크기가 한정되어 있기 때문에 결국 포화상태에 이르게 된다. ArrayList의 크기를 재조정하는 연산을 수행하여 크기를 늘릴 수도 잇지만, 상당한 연산량이 요구된다.</p>

<p>ArrayList는 사이즈가 고정되어 있기 때문에 삽입 시 사이즈를 늘려주는 연산이 추가되어야 하고, 삭제 시에는 순차적인 인덱스 구조로 인해서 삭제된 빈 엔덱스를 채워야 하기 때문에 채워주는 연산이 추가된다. 이런 부가적인 연산은 시스템 성능 저하로 이어져 삽입 / 삭제가 빈번하게 발생하는 프로세스의 경우 치명적이다. 따라서 추가 / 삭제가 ArrayList 보다 빠르고 용이하다.</p>

<p>단, ArrayList는 무작위 접근이 가능하지만, LinkedList는 순차 접근만이 가능하다. 따라서 인덱스를 이용하여 자료를 검색하는 어플리케이션에는 적합하지 않다. 사실 순차 접근도 참조의 지역성 (한번 참조한 데이터는 다시 참조될 가능성이 높고 참조된 데이터의 주변의 데이터 역시 같이 참조될 가능성이 높다는 이론) 때문에 LinkedList 보다는 ArrayList가 훨씬 빠르다. n개의 자료를 저장할 때, ArrayList는 자료들을 하나의 연속적인 묶음으로 묶어 자료를 저장하는 반면, LinkedList는 자료를 저장하는 공간에 불연속적인 단위로 젖아하게 된다. 그렇기 때문에 LinkedList는 메모리 이곳저곳에 산재해 저장되어 있는 노드들을 접근하는데 ArrayList 보다 긴 지연시간이 소모된다. LinkedList의 또 다른 단점은 참조자를 위해 추가적인 메모리를 할당해야 한다는 점이다. 자료들의 크기가 작은 리스트의 경우 참조자를 위한 추가적인 메로리 할당이 비효율적일 수 있다.</p>

<p>LinkedList의 장/단점을 정리하면 아래와 같다.</p>

<ul>
  <li>장점
    <ul>
      <li>자료의 삽입 / 삭제가 용이</li>
      <li>리스트 내에서 자료의 이동이 필요치 않음</li>
      <li>사용 후 기억장소의 재사용이 가능</li>
      <li>연속적인 기억장소 할당이 필요치 않음</li>
    </ul>
  </li>
  <li>단점
    <ul>
      <li>포인터의 사용으로 인해 저장공간 낭비</li>
      <li>알고리즘이 복잡</li>
      <li>특정 자료의 탐색 시간이 많이 소요됨</li>
    </ul>
  </li>
</ul>

<h2 id="tree">Tree</h2>

<h3 id="이진-탐색-트리">이진 탐색 트리</h3>

<ol>
  <li>각 노드에 값이 존재</li>
  <li>값이 중복된 노드가 없음</li>
  <li>노드의 왼쪽 서브트리에는 해당 노드의 값보다 작은 값들을 지닌 노드로 구성</li>
  <li>반대로 노드의 오른쪽 서브트리에는 해동 노드의 값보다 큰 값들을 가진 노드로 구성</li>
  <li>좌우의 서브 트리는 다시 각각 이진 탐색 트리이어야 함</li>
</ol>

<h3 id="avl-트리">AVL 트리</h3>

<p>일반 이진 탐색 트리의 경우 한쪽 방향으로만 뻗어나가는 형태가 될 수 있으며 이렇게 되면 탐색 효율이 나빠진다. 따라서 노드의 삽입 / 삭제 시 회전을 통해 균형을 맞춰나가는 트리가 AVL 트리이다.</p>

<ul>
  <li>특징
    <ul>
      <li>모든 노드의 서브트리 높이 차이가 1 이하이다. 만약 높이 차이가 2 이상 된다면 노드들은 스스로를 재배치하여 균형 상태를 유지한다.</li>
      <li>탐색은 이진 트리 탐색과 동일하다.</li>
    </ul>
  </li>
  <li>장점
    <ul>
      <li>탐색속도가 빠르다.</li>
      <li>트리 전체를 재배열하지 않아도 트리의 균형이 유지된다</li>
    </ul>
  </li>
</ul>

<h2 id="hashtable">Hashtable</h2>

<p>Hashtable은 key / value 쌍을 젖아하는 자료구조로써 DB의 기초가 되는 매우 중요한 자료구조이다. 내부에 bucket 이라는 공간이 배열 형태로 존재하고, 이 bucket에는 linked list 가 주렁주렁 달려있다. Hashtable의 가장 큰 장점은 검색이 매우 빠르다는 것이다.</p>

<p>저장시에는 key 값을 hash function 을 통해 특정 값으로 변환한 후에 이 값을 가지고 해당 값을 저장할 bucket 의 index를 찾아 linked list 형태로 저장한다. linked list를 사용하는 이유는 hash 값 충돌을 피하기 위해서 쓰인다.</p>

<p>검색 / 삭제도 마찬가지로, key의 hash 값을 계산한 뒤, 원하는 bucket으로 가서 bucket에 달려있는 데이터 노드와 비교를 하여(선형 탐색) 원하는 데이터를 찾는다.</p>

<p>검색에 필요한 시간 중 bucket까지 찾아가는 시간은 Hashtable의 크기가 얼마가 되었든 동일하다. 그러나 Hashtable에 너무 많은 데이터가 있어서 충돌이 일어나는 경우, 탐색하는 데 추가적인 시간이 소요되게 된다.</p>

<p>주의할 것은, Hashtable에 저장된 데이터는 순서를 예측할 수 없다.</p>

<h1 id="database">Database</h1>

<h2 id="inner-join">Inner Join</h2>

<p>Inner 조인은 우리가 생각하는 일반적인 용도에 사용한다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT gg._id, gg.name, s.title
FROM girl_group AS gg
JOIN song AS s
on s._id = gg.hit_song_id;
</code></pre></div></div>

<h2 id="left-join-right-joint">Left Join, Right Joint</h2>

<p>히트곡이 저장되어 있지 않은 경우 곡이 표시되지 않더라도 보이고 싶을 때는 하나의 테이블 기준으로 합치는 조인을 사용할 수 있다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT gg._id, gg.name, s.title
FROM girl_group AS gg
LEFT JOIN song AS s
on s._id = gg.hit_song_id;
</code></pre></div></div>

<p>마찬가지로 Right Join도 사용할 수 있다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT gg._id, gg.name, s.title
FROM girl_group AS gg
RIGHT JOIN song AS s
ON s._id = gg.hit_song_id;
</code></pre></div></div>

<h1 id="oop-원칙">OOP 원칙</h1>

<h2 id="1-srpsingle-responsibility-principle-단일-책임-원칙">1. SRP(Single Responsibility Principle), 단일 책임 원칙</h2>

<p>객체는 오직 하나의 책임을 가져야 한다. 즉, 객체는 오직 하나의 변경의 이유만을 가져야 한다.</p>

<p>사칙연산 함수를 가지고 있는 계산 클래스가 있다고 치자. 이 상태의 클래스는 오직 사칙연산 기능만을 책임진다. 만일 프로그램이 대대적으로 공사를 하게 되더라도 계산 클래스가 수정될만한 사유는 누가 봐도 사칙연산 함수와 관련된 문제 뿐이다. 이처럼 단일 책임 원칙은 클래스의 목적을 명확히 함으로써 구조가 난잡해지거나 수정사항이 불필요하게 넓어지는 것을 예방하고 기능을 명확히 분리할 수 있게 한다.</p>

<p>위의 원칙이 제대로 지켜지지 않으면 어떻게 될까? 어떤 프로그래머가 위의 계산 클래스를 통해 GUI를 가지는 계산기 프로그램을 개발하고 있다. 그런데 중간에 귀차니즘이 발동해 GUI 관련 코드를 계산 클래스에 때려박아 버렸다. 이렇게 되면 계산 클래스는 계산과 GUI라는 두 가지의 책임을 지니게 되는데 만일 GUI 관련 수정사항이 발생하게 되면 별 상관도 없어보이는 계산 클래스를 고치게 된다. 이처럼 하나의 클래스가 두 가지 이상의 책임을 지니게 되면 클래스의 목적이 모호해지고 기능을 수정할 때 영향을 받는 범위도 커져서 유지보수가 힘들어지며 결국 작성한 본인도 이게 정확히 뭐하는 클래스인지 명확히 설명할 수 없는 오징어 짬뽕같은 코드가 되어버린다.</p>

<h2 id="2-ocpopen-closed-principle-개방---폐쇄-원칙">2. OCP(Open Closed Principle), 개방 - 폐쇄 원칙</h2>

<p>객체는 확장에 대해서는 개방적이고 수정에 대해서는 폐쇄적이어야 한다는 원칙이다. 즉, 객체 기능의 확장을 허용하고 스스로의 변경은 피해야 한다.</p>

<p>예를 들자면, 스타크래프트의 유닛을 만든다고 치자. 당신은 이런저런 공통 사항을 생각하며 메소드와 필드를 정의한다. 이 중엔 이동 메소드도 있다. 이동 메소드는 대상 위치를 인수로 받아 속도에 따라 대상 위치까지 유닛을 길찾기 인공지능을 사용해 이동한다. 하지만 잠깐 곰곰히 생각해보니 이러면 브루들링은 유닛의 기묘한 움직임을 구현할 때 애로사항이 꽃필 것 같다. 당신은 고민하다가 이동 함수에서 이동 패턴을 나타내는 함수 (혹은 클래스) 를 분리해서 구현을 하위 클래스에 맡긴다. 그러면 부르들링 클래스에선 이것만 재정의 / 설정하면 유닛 클래스의 변경 없이 색다른 움직임을 보여줄 수 있다. 이 ‘유닛’ 클래스의 ‘이동’ 메소드를 수정할 필요조차 없다. (수정에 대해선 폐쇄). 그냥 브루들링 클래스의 이동 패턴만 재정의하면 그만인 것이다. (확장에 대해선 개방)</p>

<h2 id="3-lspliskov-substitution-principle-리스코프-치환-법칙">3. LSP(Liskov Substitution Principle), 리스코프 치환 법칙</h2>

<p>자식 클래스는 언제나 자신의 부모 클래스를 대체할 수 있다는 원칙이다. 즉, 부모 클래스가 들어갈 자리에 자식 클래스를 넣어도 계획대로 잘 작동해야 한다는 것. 상속의 본질인데 이를 지키지 않으면 부모 클래스 본래의 의미가 변해서 is a 관계가 박살나며, 그로 인해 다형성 불구자가 된다.</p>

<p>또다시 예를 들면, 컴퓨터용 ‘마우스’ 클래스가 있다고 치자. 이 컴퓨터용 ‘마우스’는 어떤 마우스를 사오던 컴퓨터에 있는 ps/2 포트나 usb 포트에 연결할 수 있을 것이다. 사용 면에서는 왼쪽과 오른쪽 버튼, 그리고 휠이 있어 사용자가 누르거나 굴릴 수 있을 것이다. 또한 무언가 바닥에 대고 움직이면 컴퓨터가 이를 받아들인다는 것도 안다. 마우스가 볼마우스던 광마우스던 간에 암튼 사용자는 바닥에 착 붙여 움직일 것이고, 모든 마우스는 예상대로 신호를 보내 줄 것이다. 또한 만약 추가적인 특별한 버튼이 있는 마우스(상속)라도 그 버튼의 사용을 제외한 다른 부분은 보통의 마우스와 다를 바 없으므로 사용자는 그 마우스의 버튼이 뭔 역할을 하던간에 아무 문제없이 잘 사용한다. 하지만 오른쪽 / 왼쪽 버튼 대신 뒷쪽 / 앞쪽 버튼을 사용하는 기묘한 마우스가 나왔다고 치자. 사용자는 평소 보던 버튼을 누를 수 없으므로 이상을 호소할 것이다. 위의 볼마우스나 광마우스는 LSP를 훌륭하게 지키지만 바로 위의 예제는 전혀 그렇지 못하다고 볼 수 있다.</p>

<h2 id="4-ispinterface-segregation-principle-인터페이스-분리-원칙">4. ISP(Interface Segregation Principle), 인터페이스 분리 원칙</h2>

<p>클라이언트에서 사용하지 않는 메소드는 사용해선 안된다. 그러므로 인터페이스를 다시 작게 나누어 만든다. OCP와 비슷한 느낌도 들지만 엄연히 다른 원칙이다. 하지만 ISP를 잘 지키면 OCP도 잘 지키게 될 확률이 비약적으로 증가한다.</p>

<p>예를 들어보자. 게임을 만드는데 충돌 처리와 이펙트 처리를 하는 서버를 각각 두고 이 처리 결과를 모두 클라이언트에게 보내야 한다고 가정하자. 그러면 아마 Client 라는 인터페이스를 정의하고 그 안에 충돌전달() 과 이펙트전달(이펙트)를 넣어놓을 것이다. 그리고 충돌 서버와 이펙트 서버에서 이 인터페이스를 구현하는 객체들을 모아두고 있으며 때에 따라 적절히 신호를 보낸다. 하지만 이렇게 해두면 충돌 서버에겐 쓸모없는 이펙트 전달 인터페이스가 제공되며, 이펙트 서버에겐 쓸모없는 충돌전달 인터페이스가 전달된다. 이를 막기 위해선 Client 인터페이스를 쪼개 이펙트 전달 가능 인터페이스와 충돌 전달 가능 인터페이스로 나눈 뒤, 충돌에는 충돌만, 이펙트에는 이펙트만 전달하면 될 것이다. 또한 Client 인터페이스는 남겨두되 이펙트 전달 가능과 충돌 전달 가능 이 둘을 상속하면 된다.</p>

<h2 id="5-dipdependency-inversion-principle-의존성-역전-원칙">5. DIP(Dependency Inversion Principle), 의존성 역전 원칙</h2>

<p>추상성이 높고 안정적인 고수준의 클래스는 구체적이고 불안정한 저수준의 클래스에 의존해서는 안된다는 원칙으로서, 일반적으로 객체지향의 인터페이스를 통해서 이 원칙을 준수할 수 있게 된다. (상대적으로 고수준인) 클라이언트는 저수준의 클래스에서 추상화한 인터페이스만을 바라보기 때문에, 이 인터페이스를 구현한 클래스는 클라이언트에 어떤 변경도 없이 얼마든지 나중에 교체될 수 있다.</p>

<h1 id="자기소개">자기소개</h1>

<p>안녕하세요. 지원자 이재용입니다. 저는 2013년부터 이글루시큐리티에서 통합보안관리 솔루션을 만들면서 개발자 생활을 시작했습니다. 그 솔루션 안에서는 미들웨어 파트와 로그 수집 Agent 파트를 담당해서 개발했습니다. 이후에는 리디에서 리디스토리라는 신규 서비스를 만드는 일에 풀스택 포지션으로 참여했습니다. 이번에 엔씨소프트에서 모니터링 시스템 개발 관련 채용 공고를 보고 평소에 모니터링 시스템에 관심이 많기도 했고 이전 회사인 이글루시큐리티나 리디에서 가졌던 개발 경험들로 더 나은 모니터링 시스템을 만드는 데 일조할 수 있다고 판단되어 이렇게 지원하게 되었습니다. 잘 부탁드립니다.</p>

<h1 id="지원-동기">지원 동기</h1>

<p>이전에 재직했던 이글루시큐리티에서 통합보안관리 솔루션을 개발할 때는 보안 로그들을 수집 / 저장하면서 정보보호 체계를 침해할 수 있는 행위들을 잡아내기 위한 지원을 했고, 리디에서 리디스토리 서비스를 개발할 때는 시스템의 안정적인 동작들을 위해 로그를 수집하고 모니터링 시스템을 구성했습니다. 그러다보니 로그 및 지표들을 수집 / 저장 / 분석 / 시각화 하는 일련의 모니터링 시스템 체계에 대해 관심이 많아졌습니다. 특히 재미있는 점은, 모니터링 시스템을 구현하다 보면 여러가지 재미있는 기술적인 요소들을 사용해볼만한 여지가 있다는 것입니다.</p>

<p>예를 들어, Agent를 이용한 로그 수집 방식의 경우 타겟 시스템 / 디바이스에서의 리소스 사용을 최소로 하기 위한 테크닉들이 필요하게 됩니다. 이런 경우에는 성능을 위해서 C/C++을 사용한 네이티브 개발을 하는 방법도 고려할 수 있고, 실질적인 액션이 필요한 시점에 필요한 기능만을 실행하는 방식으로 코드를 구성해야 합니다. 또한 필요한 경우 Agent 자체에서 오버헤드를 일으킬 수 있는 연산 로직을 돌리기 보다는 해당 로직을 서버로 옮겨 수행하도록 하는 방법이 유리하며 서버로 전달되는 페이로드의 사이즈를 줄이거나 횟수를 줄이는 방법도 고려될 수 있습니다. 또한 라이브러리 형태로 구성될 경우 동작들을 비동기 방식으로 구현하여 본래의 비즈니스 로직에 오버헤드를 주지 않게끔 하는 것이 중요합니다.</p>

<p>또한 로그 수집 양이 늘어나면 수집 서버를 병렬로 배치하는 분산 환경 구성에 대해서도 고민해야 합니다. 또한 수집 서버와 그 뒷쪽에 배치되는 분석 파이프라인 및 저장소 가운데에 메시지 큐를 배치하여 데이터 피크에 대비하여 쿠셔닝을 해주는 방법에 대해서도 고려할 필요가 있습니다.</p>

<p>로그 / 지표의 저장 방식도 고민해볼만한 여지가 많습니다. 단순하게 정규화된 지표를 RDB에 저장하는 방식부터 경우에 따라서는 timeseries 데이터베이스 사용을 고민해볼 수도 있습니다. timeseries 데이터베이스는 조회 시에 시계열 데이터에 특화된 함수들을 사용할 수 있다는 장점이 있습니다. 예를 들어, 매 10분마다 통계를 내 별도의 테이블에 저장한다던가 하는 기능들을 DB 상에서 지원하고 있습니다.</p>

<p>로그 검색 기능이 필요한 경우에는 파일로 떨어뜨려 놓고 ElasticSearch 등의 솔루션을 이용해 인덱싱을 하는 방법도 있습니다. 혹은 널리 사용되고 있는 ELK 스택(ElasticSearch, LogStash, Kibana)을 구성하는 방법도 있을 것입니다.</p>

<p>로그 분석에 대해서도 선저장 - 후분석 방식으로 구성하여 Spark 같은 도구들을 이용하는 방법도 있고, 선분석 - 후저장 방식으로 구성하여 Esper, Storm 같은 도구들을 이용하는 방법도 있습니다. 특히 이러한 분석 프로세스 내에서는 유연한 분석을 위해 SQLlike한 DSL을 정의하여 사용하는 경우도 있습니다. 상용 솔루션인 Splunk의 데모영상을 보면 사용자가 직접 DSL을 사용하지 않고 UI 요소들만을 이용해서 유연한 분석 방법을 지원하고 있는데 이러한 부분도 개발 난이도가 높고 재미있을 만한 부분이라고 생각합니다.</p>

<p>데이터 시각화를 제공하는 대시보드의 경우에도 대부분 사용자들이 직접 차트를 커스터마이징 하는 기능을 제공하고 있습니다. 이러한 기능을 통해 프론트엔드 단도 web document 에서 벗어나 복잡한 인터랙션을 지원하는 web application 으로 진화하고 있고 이에 따른 여러가지 기술적 요소들이 필요합니다.</p>

<h1 id="면접-질문">면접 질문</h1>

<h2 id="기술-부문-질문">기술 부문 질문</h2>

<h3 id="string-stringbuilder-stringbuffer의-차이점">String, StringBuilder, StringBuffer의 차이점?</h3>

<p>String은 기본적인 문자열을 다루기 위한 클래스. 하지만 concat을 할 때에는 성능에 좋지 않아 StringBuilder나 StringBuffer 등을 사용하게 된다. concat을 할 때마다 매번 String 인스턴스를 생성하는 방식이기 때문이다. jdk 1.5 버전 이후부터는 컴파일 단계에서 StringBuilder로 컴파일 되도록 변경되었다고 한다. 따라서 1.5 버전 이후부터는 그냥 String으로 concat을 해도 상관없다.</p>

<p>StringBuilder와 StringBuffer의 차이점은 동기화 지원 여부다. 두 클래스가 제공하는 함수들은 동일하지만 StringBuffer는 각 함수 별로 synchronized 키워드가 존재한다. 즉, 멀티스레드 상태에서 동기화를 지원한다는 것이다.</p>

<h3 id="stack과-queue에-대해-설명">stack과 queue에 대해 설명</h3>

<p>stack은 후입선출(Last In First Out), queue는 선입선출(First In First Out)</p>

<p>queue의 문제점은 Linked List가 아닌 배열 형태로 구현한다면 pop된 이후에 나머지 요소들을 전부 한자리씩 땡겨주어야 한다는 것이다. 이를 해결하기 위해 나온 것이 원형큐이다. 원형큐에서는 pop을 하더라도 나머지 요소들을 재배열하지 않고 다만 요소들의 head와 tail만 포인터로 가르키는 방법으로 구현한다.</p>

<h3 id="해시-테이블에-비해-이진-검색-트리의-장점">해시 테이블에 비해 이진 검색 트리의 장점</h3>

<p>범위 검색을 효율적으로 수행할 수 있다. 또한 해시테이블은 정렬되지 않은 데이터 구조이다. 따라서 정렬이 필요한 경우에는 이진 검색 트리를 사용하는 것이 유리하다. 이진 검색 트리는 정렬된 형태로 데이터를 저장하기 때문이다.</p>

<h3 id="다형성에-대해-설명">다형성에 대해 설명</h3>

<p>일반적으로 “여러가지 형태를 가질 수 있는 능력”을 의미한다. 즉 하나의 타입으로 여러 타입으로 선언할 수 있다는 뜻이다.</p>

<p>Java에서는 상속과 인터페이스를 통해서 이루어진다. 예를 들어, 마우스에는 볼마우스, 광마우스, 트랙볼 등 여러가지 구현체가 있을 수 있지만 그 모든 것들을 마우스 하나의 타입으로 다룰 수 있도록 하는 성질이다.</p>

<h3 id="데드락이란-데드락을-피하는-방법">데드락이란? 데드락을 피하는 방법</h3>

<p>무한 교착 상태를 의미한다. 즉, A는 B가 가진 자원이 반납되기를 기다리고 있는데, B는 A가 가진 자원이 반납되기를 기다리는 상태.</p>

<p>데드락을 방지하는 방법으로는 아래와 같다.</p>

<ul>
  <li>hold and wait. 한 번에 필요한 모든 자원을 모두 가지도록 하는 방법. 자원의 활용도가 떨어진다.</li>
  <li>no preemption. 하나의 작업이라도 실패하면 모든 자원을 release 한다.</li>
  <li>circular wait. 자원에 고유한 순서를 할당하고 순서대로 자원을 요구하도록 한다.</li>
</ul>

<h3 id="db에서-index란">DB에서 index란?</h3>

<p>데이터베이스 내의 테이블에서 원하는 데이터를 좀더 빨리 찾을 수 있게 데이터의 위치 정보를 모아놓은 데이터베이스 내의 개체.</p>

<p>생성 지침: where 절의 조회 조건이나 조인 조건으로 자주 사용되는 경우, 컬럼값이 unique한 경우, update가 자주 발생하지 않는 경우, 해당 컬럼을 통한 select 연산의 결과가 전체 데이터 수의 5% 이내인 큰 테이블</p>

<p>단, 데이터의 변경 작업(insert, update, delete)가 자주 일어날 경우 성능이 저하될 수 있다.</p>

<h3 id="restful의-의미는">RESTful의 의미는?</h3>

<p>client - server 간의 통신에 사용되는 아키텍처의 일종으로 몇 가지 특징들이 있다.</p>

<p>stateless 하다. 세션 등으로 클라이언트와 서버의 상호작용에 따라 다른 동작을 해서는 안된다. 똑같은 요청은 똑같은 자원을 반환한다.</p>

<p>자원은 URI를 바탕으로 이해하기 쉬운 디레곹리 형 구조로 노출되어야 한다. 즉 URI만 보고 이게 어떤 자원인지 알 수 있어야 한다.</p>

<p>자원은 JSON이나 XML로 표현되어야 한다.</p>

<p>POST, GET, PUT, DELETE 4개의 HTTP 메소드들을 고려하여 동일한 URL일 경우라도 메소드마다 다르게 구현한다.</p>

<p>cache를 사용할 수 있다. cache는 http 표준에서 사용하는 last-modified나 e-tag 헤더를 이용하여 구현할 수 있다.</p>

<h3 id="정렬-알고리즘-중-가장-빠른-방식은">정렬 알고리즘 중 가장 빠른 방식은?</h3>

<p>평균적인 상황에서는 quick sort가 가장 좋다.</p>

<h3 id="bubble-sort란">bubble sort란?</h3>

<p>1번째와 2번째를 비교하여 정렬하고, 2번째와 3번째를 비교하여 정렬하고 … 를 반복.</p>

<p>구현하기 제일 쉽지만 대부분의 경우 가장 최악의 성능을 보여준다.</p>

<h3 id="quick-sort란">quick sort란?</h3>

<p>적절한 하나의 피봇을 잡아 그보다 작은것은 앞으로 빼고 그 뒤에 피봇을 옮겨 피봇보다 작은 것, 큰 것으로 나눈 뒤 나누어진 각각에서 다시 피봇을 잡고 반복.</p>

<p>평균적인 상황에서 가장 좋은 성능을 낸다.</p>

<h3 id="js의-event-delegation에-대해-설명">js의 event delegation에 대해 설명</h3>

<p>event를 listening해야하는 요소들이 많은 경우에 각 요소들에 전부 event listener를 달지 않고 요소들의 단일 부모에만 event listener를 달아서 bubbling되어 올라오는 event를 부모 단에서 처리해주는 패턴. 성능에 좋다.</p>

<h3 id="js의-hoisting에-대해-설명">js의 hoisting에 대해 설명</h3>

<p>특정 스코프 안에서 선언된 변수가 있다면 해당 변수는 인터프리터 엔진에 의해서 해당 스코프의 최상위단으로 끌어올려진다. 예를 들어 아래와 같이 작성한 코드는,</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">test</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="s1">'hello'</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>아래와 같이 실행되어 오류가 발생하지 않는다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">test</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">value</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
    <span class="nx">value</span> <span class="o">=</span> <span class="s1">'hello'</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="js의-와-의-차이점">js의 ==와 ===의 차이점</h3>

<p><code class="highlighter-rouge">==</code> 는 타입과 상관없이 비교하고 <code class="highlighter-rouge">===</code> 는 타입까지 비교한다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s1">'185.3'</span> <span class="o">==</span> <span class="mf">185.3</span> <span class="c1">// true</span>
<span class="s1">'153.3'</span> <span class="o">===</span> <span class="mf">185.3</span> <span class="c1">// false</span>
<span class="kc">undefined</span> <span class="o">==</span> <span class="kc">null</span> <span class="c1">// true</span>
<span class="kc">undefined</span> <span class="o">===</span> <span class="kc">null</span> <span class="c1">// false</span>
</code></pre></div></div>

<h3 id="js의-use-strict의-의미">js의 use strict의 의미</h3>

<p>ECMA5 부터 적용되는 키워드인데 쉽게 말해 안전한 코딩을 위한 가이드 라인이라 할 수 있다.</p>

<p>strict 모드를 사용하게 되면 암시적으로 선언한 변수를 사용하거나 읽기 전용 속성에 값을 할당하거나 확장할 수 없는 개체에 속성을 추가할 수 없다.</p>

<h3 id="js의-let-var-const의-차이점">js의 let, var, const의 차이점</h3>

<p>var는 function-scoped이고 let, const는 block-scoped 이다.</p>

<p>예를 들어, for문 안에서 i를 var로 선언했다면 for문이 종료된 이후에도 i를 참조할 수 있다.</p>

<p>let, const는 ECMA6부터 추가된 키워드로 var와 다르게 재선언이 불가능하다.</p>

<p>let은 변수에 재할당이 가능하지만, const는 변수 재선언, 재할당 모두 불가능하다.</p>

<h3 id="뮤텍스와-세마포어에-대해-설명">뮤텍스와 세마포어에 대해 설명</h3>

<p>Mutex는 일종의 Locking 메커니즘으로 lock을 가지고 있을 때만 공유 데이터에 접근 가낭하다는 개념. 화장실 갈 때 키를 가진 사람만 갈 수 있고 일을 다 본 후에 키를 반납하면 그 다음 사람이 이용 가능한 메커니즘. lock에 대한 소유권이 있다.</p>

<p>Semaphore는 동시에 리소스에 접근할 수 있는 허용 가능한 counter의 개수를 의미한다. 어느 병실에 최대 5명 까지 수용가능하다면 5명 까지 counting을 하고 그 이후는 밖에서 기다렸다가 한 사람이 나오면 다음 사람이 들어오는 메커니즘.</p>

<p>Mutex는 lock을 한개만 가질 수 있고 Semaphore는 여러 개를 가질 수 있다.</p>

<h3 id="thread에-대해-설명">thread에 대해 설명</h3>

<p>하나의 프로세스 내에서 복수개로 실행될 수 있는 실행 흐름의 단위. 여러 스레드가 메모리를 공유하며 작동할 수 있으며, 너무 많이 생성되는 경우 context switching 부하가 생길 수 있다. 데드락 관련된 부분을 조심해야 한다.</p>

<h3 id="tdd의-의미">TDD의 의미</h3>

<p>자신이 작성한 함수 단위에 대해 테스트를 수행하여 이후에 발생하는 테스트 단계에서의 결함 발생 비용을 줄여준다.</p>

<p>일반적인 소프트웨어 개발은 기능을 구현하고 테스트를 수행하는 형태이나 TDD는 이와 반대. 목표 이미지를 먼저 세우고 자동화된 테스트 케이스를 작성하고 만족시키는 로직을 작성하는 형태.</p>

<p>올 그린 상태는 만족감과 성취감을 제공한다.</p>

<p>복잡한 함수의 경우 테스트 케이스만 보고도 함수의 역할을 유추할 수 있는 경우가 있다.</p>

<p>결과적으로 지속적인 테스트 가능. 프로그램 안정성에 크게 기여.</p>

<h3 id="nosql이란">NoSQL이란?</h3>

<p>Not Only SQL의 약자로 기존의 관계형 데이터베이스가 아닌 다른 형태의 데이터 저장 기술을 의미한다. 제품에 따라 각기 그 특성이 매우 달라서 하나의 제품군으로 정의할 수 없다.</p>

<p>일반적인 특징으로는,</p>

<p>테이블 스키마가 고정되지 않는다.</p>

<p>분산형 구조를 가지는 경우가 많다.</p>

<p>대용량 데이터를 저장할 수 있도록 지원하는 경우가 많다.</p>

<p>보통 CAP 이론과 함께 많이 거론되는데, CAP 이론이란 Consistency, Availability, Partitioning 세가지의 요소 중 보통 2가지의 요소에 집중한다는 의미.</p>

<p>Consistency: 분산된 어느 노드를 접근하더라도 데이터의 값이 같아야 한다.</p>

<p>Availability: 하나 이상의 노드가 Fail 되더라도 정상적으로 요청을 처리할 수 있어야 한다.</p>

<p>Partitioning: 물리적 네트워크 분산 환경에서 시스템이 잘 작동한다.</p>

<h3 id="os의-페이징-개념">OS의 페이징 개념</h3>

<p>페이징이란 사용되지 않고 있는 메모리 영역을 디스크에 일시적으로 저장하는 과정을 말한다. 이 테크닉을 이용하면 애플리케이션은 실제 물리 메모리 용량보다 더 많이 사용할 수 있다.</p>

<h2 id="경험-부문-질문">경험 부문 질문</h2>

<h3 id="최근에-공부한-기술이-있다면">최근에 공부한 기술이 있다면?</h3>

<p>이벤트 소싱에 대한 개념을 근래에 공부한 적이 있습니다. 이벤트 소싱 개념을 들여다보게 된 이유는 기존 레거시 서비스를 MSA 형태로 분리해서 별도의 팀들이 관리하게끔 하는 일을 하게 되었는데 이때 서비스 별 동기화되어야 하는 데이터를 처리하기 위한 방법 중 하나로 고려되었기 때문입니다.</p>

<p>이벤트 소싱이 일반적인 개발 방법과 다른 부분은, 일반적으로는 어떠한 로직을 수행한 결과값만을 저장해왔다면 이벤트 소싱은 순차적으로 발생한 이벤트들을 모두 저장한다는 점입니다. 예를 들어 사용자가 데이터 A, B를 추가했다가 A를 삭제한 경우 데이터베이스에는 B만 남아있게 되지만 이벤트 소싱을 사용하면 A, B를 추가한 이벤트와 A를 삭제한 이벤트가 모두 남게 되는 것입니다.</p>

<p>이러한 방법을 고려하게 되었던 이유는, 팀간 데이터 불일치가 일어나거나 데이터가 깨졌을 경우 쌓인 이벤트들을 전부 다시 훑어서 데이터를 복구할 수 있다는 점 때문이었습니다.</p>

<p>결과적으로 현업에는 적용하지 못했는데 그 이유는, 레거시를 다루는 팀 쪽에서 발생되는 모든 이벤트들을 저희팀으로 넘겨줘야 하는 상황이었는데 레거시의 규모가 크고 오래되다보니 모든 이벤트들을 빠짐없이 넘겨주는 것을 보장하기가 힘들다는 것이 이유였습니다.</p>

<p>이벤트소싱을 사용하다보면 조회 요청시에 조회 대상 데이터의 모든 이벤트 이력을 훑어야 하기 때문에 성능이 좋지 않습니다. 이러한 부분을 해결하기 위해 특정 시점마다 스냅샷을 떠놓는 방법이 있습니다.</p>

<p>하지만 스냅샷으로도 성능을 필요한 만큼 끌어올리기는 쉽지 않습니다. 따라서 CQRS 형태로 사용하는 것이 일반적입니다. CQRS란 명령을 처리하는 책임과 조회를 처리하는 책임을 분리하는 패턴입니다. 이 패턴을 이벤트소싱과 조합하면, 명령을 처리하는 데이터 저장소와 조회를 처리하는 데이터 저장소를 분리합니다. 이후에 데이터 변경 요청을 포함하는 명령이 실행되면 해당 명령은 이벤트로써 이벤트 소싱 데이터 저장소에 기록되고 그렇게 쌓인 이벤트 데이터들을 가지고 조회를 책임지는 데이터 저장소에 반영을 해줍니다. 이후에 조회 요청이 날아오면 조회를 책임지는 저장소에서 처리를 합니다.</p>

<p>또한 Operational Transformation 알고리즘에 대해서도 얼마전에 공부를 한 적이 있습니다. OT 알고리즘은 실시간 문서 편집기 등에서 데이터 동기화를 수행하기 위해 만들어진 알고리즘입니다. 실시간 편집기를 구현하다보면 사용자별로 네트워크 단에서 발생되는 지연 때문에 서로 다른 데이터를 가지게 되는 시점에서 서로 다른 액션들이 취해지게 되는데 이를 해결하기 위한 방법입니다.</p>

<p>이 알고리즘에 관심을 가지게 되었던 이유는 당시 팀이 부여받았던 미션이 디바이스별 동기화였기 때문입니다. 디바이스 특성상 오프라인 상태인 시간이 굉장히 긴 경우가 많았기 때문에 동기화 설계를 꼼꼼하게 해야 했습니다. 전 직장에서 OT 알고리즘을 응용하여 동기화 설계를 수행했습니다.</p>

<p>OT 알고리즘을 응용한 방법은, 동기화가 되어야 하는 각 디바이스들이 어떤 디렉토리 구조와 비슷한 데이터를 들고 있어야 하는 상황이었습니다. 이때 A 디바이스에서는 root에 있는 파일을 지웠고 B 디바이스에서는 같은 파일을 특정 하위 폴더 아래로 이동시켜는 액션을 취했다고 하면, OT 알고리즘을 적용시키지 않으면 A 디바이스에서 취한 오퍼레이션이 B 디바이스에 동기화되었을 때 파일은 삭제되지 않게 됩니다.</p>

<h3 id="최근-본-기술서적-중-기억에-남는-부분">최근 본 기술서적 중 기억에 남는 부분</h3>

<p>Immutable Infrastructure 와 관련된 부분을 읽은 기억이 제일 최근에 인상 깊었던 부분입니다. 특정 책을 읽다가 II과 관련된 내용을 읽은게 아니라 II와 관련된 내용을 찾아보려고 여러 책을 뒤진거라 정확히 책 제목은 기억이 나질 않습니다만 클라우드에서 인프라를 구성하는 방법을 설명해주는 책과 인프라 실전 구축 가이드 같은 책들에서 본 것 같습니다.</p>

<p>II가 해결하고자 하는 상황은 II의 반대인 Mutable Infrastructure 입니다. 의미 그대로 보통 전통적으로 인프라를 다룰 때는 처음 구축을 해놓고 필요시마다 애플리케이션을 설치한다던지 패키지를 업데이트하거나 OS 버전을 올려준다던지 하는 변경 동작들을 하게 되는데요, 다루게 되는 서버의 대수가 많아지거나 중간에 관리 인원이 변경되거나 하면 이 히스토리에 대해서 알기 어려워지는 문제들이 많이 발생합니다. 이러한 변경사항에 대해서는 철저하게 기록이 되고 관리가 되어야 하는데 현실적으로 그러리가 쉽지 않은 점이 있습니다.</p>

<p>II는 그러한 상황을 해결하고자 나온 패러다임인데, 말이 좀 거창하지 사실 요즘 많이 하는 Docker를 이용한 컨테이너 기반 배포나 Ansible 같은 툴을 이용해서 서버 구성을 자동화하고 클라우드 상에서 하는 VM 기반의 배포 시스템을 추상적으로 설명하는 개념입니다. 서버에 변경사항 있는 경우에는 운영중인 서버에 변경을 가하는 것이 아니라, 별도의 서버에 변경 사항을 반영시켜놓고 해당 서버로 갈아치는 개념을 이야기합니다. 여기에 이런 서버/컨테이너의 추가/삭제같은 작업들이 API를 통해서 지원이 되어야 하고 이를 통해서 자동화가 가능해야 한다 뭐 이런 부분들이 II의 패러다임이라고 볼 수 있을 것 같습니다.</p>

<p>이렇게 II를 도입하게 되면 서버 별로 변경사항이 다르게 적용되는 문제나 스케일 아웃시에 수월해지고 서버 변경이 단순해지고 이력을 관리할 수 있다 정도가 될 수 있을 것 같습니다.</p>

<p>반대로 단점으로는 간단한 설정 변경도 새로 서버/컨테이너를 기동해야 하기 때문에 상태 변경 비용의 증가가 일어난다는 점이 있구요, 결과적으로 서버/컨테이너의 생성 및 파기 작업이 자주 일어나기 때문에 이에 따른 비용 문제도 있을 수 있습니다. 또한 웹서버 같은 stateless 서버들만 이런 방식으로 다룰 수 있고 stateful 한 서버는 II로는 다룰 수 없다는 점도 있습니다.</p>

<h3 id="기억에-남는-트러블슈팅-경험이-있다면">기억에 남는 트러블슈팅 경험이 있다면</h3>

<p>리디스토리 서비스 런칭 후 모니터링 중에 이상한 지표를 발견한 적이 있습니다. 일부 서버들에서 network out 트래픽이 튀고 있었습니다. 차트를 자세히 살펴보니 정확히 6시 반쯤 시작해서 11시 경에는 정상 수치로 돌아왔습니다. 제일 먼저 해당 서버에서 주기적으로 스케쥴링 되어있는 태스크들을 확인했으나 해당 서버에 걸려있는 태스크라고는 CloudWatch 지표값들을 수집하는 Agent 뿐이었고 해당 태스크도 5분마다 실행되도록 되어있어서 용의선상에서 벗어났습니다.</p>

<p>문제는 다른 부분에서도 일어나고 있었습니다. 메모리 사용량이 조금씩 증가하고 있었습니다. 소스코드를 비롯하여 의심될만한 부분들을 샅샅이 뒤져봤으나 애초에 해당 서버는 AWS S3에 있는 데이터를 변환해서 던져주는 심플한 역할만 하는 서버였기 때문에 원인을 진단하기 어려웠습니다.</p>

<p>그러던 중 서버에 설치되어 있는 s3fs가 눈에 들어왔습니다. 당시 해당 서버는 S3에 있는 데이터를 서빙하기 위해 s3fs라는 오픈소스를 사용하여 S3의 특정 버킷을 가상으로 마운트 시켜놓고 있었습니다. s3fs 프로젝트의 issue 들을 뒤져보니 memory leak 있다는 issue가 유난히 많았습니다. 이에 팀 내부에서 s3fs 버그 현상으로 진단하고 s3fs 의 대용으로 쓸 수 있는 goofys 로 넘어가자는 이야기가 나왔으나 그렇게 단정해버리기엔 찜찜한 부분이 있었습니다. s3fs 의 memory leak bug 라고 올라온 리포트들은 대부분 수십 분에서 길어야 수 시간 내에 서버의 메모리를 모두 잡아먹고 뻗어버리는 현상이 있다고 올라와 있었습니다. 하지만 우리의 증상은 일주일 동안 전체 메모리의 20% 정도를 추가 점유하는 현상만 보였을 뿐이었습니다.</p>

<p>좀 더 정확한 정황을 확인하기 위해 s3fs의 디버그 로그 옵션을 켜고 재기동 후 다음날 로그를 확인하니 확실히 이상한 부분이 눈에 띄었습니다. network out 트래픽 지표가 튀기 시작했던 6시 반 경에 s3fs에 의해서 가상 마운트되어 있는 폴더의 모든 오브젝트들을 하나씩 순회하는 로그들이 찍혀있었습니다. S3 버킷에 있는 수만개의 오브젝트들을 전부 순회하고 마친 시간은 network out 트래픽 지표에서 튀는 차트가 정상으로 돌아온 시간과 일치했습니다. 슬슬 꼬리가 보이기 시작했습니다. 무언가로 인해서 매일 아침 6시 반경에 s3fs 마운트 폴더로 순회 요청이 던져지고, 마운트 폴더로의 순회 요청은 그대로 디스크를 뒤지는 것이 아니라 네트워크를 타고 S3 서버로 요청을 던지게 되면서 network out 트래픽 지표가 튀게 되는 것이었습니다.</p>

<p>또 한가지 이상했던 점은 s3fs를 순회하는 로그가 정확히 syslog의 가장 첫줄부터 시작되고 있었다는 점입니다. syslog는 logrotate에 의해서 롤링되고 있었기 때문에 logrotate가 실행되는 시점에 어떤 명령에 의해서 s3fs 마운트 폴더를 순회하는 명령이 발생되었다고 추정할 수 있었습니다. 그렇게 logrotate 실행 스크립트가 담겨있는 cron.daily 폴더를 확인해보았고 mlocate 라는 프로세스를 찾아낼 수 있었습니다. mlocate는 빠른 파일 접근을 위해 디스크 내용을 인덱싱하는 역할을 하고 있었는데, 그 인덱싱 작업은 매일 아침마다 돌고 있었고 그 대상에는 s3fs 마운트 폴더로 포함되어 있었습니다. mlocate가 인덱싱을 위해서 매일 아침매다 해당 폴더를 순회하였고, 이로인해 S3에 요청이 날아가면서 network out 트래픽 지표가 튀게 되었던 것이었습니다. 메모리 사용량 증가도 정확한 원인까지는 확인할 수 없었지만 짧은 시간 내 감당하기 힘든 네트워크 요청들로 인해서 발생한 것이라고 이해하기에 어려움이 없었습니다.</p>

<p>이에 mlocate가 인덱싱을 하는 대상 폴더에서 s3fs를 제외 처리 하였고, 그 결과 network out 트래픽 지표와 메모리 사용량 지표 모두 정상으로 돌아왔습니다.</p>

<h3 id="팀원들간의-의견-불일치를-해결하는-당신만의-방법이-있다면-팀원-중-의견이-안맞는-직원이-있다면">팀원들간의 의견 불일치를 해결하는 당신만의 방법이 있다면? 팀원 중 의견이 안맞는 직원이 있다면?</h3>

<p>우선적으로 팀의 판단 기준을 정해야 할 것 같습니다. 일의 방향을 결정함에 있어서 우선순위 따라서 고려해야 하는 기준들을 미리 정해두면 불필요한 충돌이 많이 없어질 것 같습니다. 그래도 충돌하는 부분이 있다면 상충하는 각 의견들을 구체화시켜서 팀원 모두와 함께 공유해놓고 이야기를 해야 할 것 같습니다. 말로만 이야기를 주고받다보면 같은 것을 놓고도 서로 다르게 이야기를 하는 경우가 많으므로 일단 그 생각의 형태 자체를 통일시켜놓고 거기서 각 의견을 부분별로 쪼개서 타협안을 만들어 나가는 것이 합리적이라고 생각합니다.</p>

<h3 id="가장-최근에-겪은-기술적인-어려움과-그것을-어떻게-극복했는지">가장 최근에 겪은 기술적인 어려움과 그것을 어떻게 극복했는지?</h3>

<h3 id="진행했던-프로젝트를-기술적인-측면에서-설명">진행했던 프로젝트를 기술적인 측면에서 설명</h3>

<h3 id="이전-업무에서-기능을-개선한-사례에-대해-설명">이전 업무에서 기능을 개선한 사례에 대해 설명</h3>

<h3 id="프로젝트를-진행하면서-활용한-프로그래밍-언어는-무엇-그-도구를-활용하면서-가장-어려웠던-점은-무엇">프로젝트를 진행하면서 활용한 프로그래밍 언어는 무엇? 그 도구를 활용하면서 가장 어려웠던 점은 무엇?</h3>

<h3 id="웹-사이트를-새로-만들거나-유지보수할-때-성능을-향상시키기-위해서-사용한-테크닉에-대해서-설명해주세요">웹 사이트를 새로 만들거나 유지보수할 때 성능을 향상시키기 위해서 사용한 테크닉에 대해서 설명해주세요</h3>

<h3 id="시니어-개발자란">시니어 개발자란?</h3>

<h3 id="프로젝트-팀-내에서-주로-어떤-역할을-해왔습니까">프로젝트 팀 내에서 주로 어떤 역할을 해왔습니까?</h3>

<p>팀이 당면한 문제를 해결하기 위해 새로운 해결책을 고민하고 선행 기술을 팀 내에 공유하는 역할을 많이 했습니다. 특히 POC를 위한 프로토타이핑에 투입된 경우도 많습니다.</p>

<p>이글루시큐리티 재직시절 신규 로그 수집 엔진을 실험하는 과정에서 프로토타이핑에 일부 참여했으며 언어는 Go를 썼습니다. 또한 당시 개발팀에 부하가 많이 걸리던 Agent 연동 관련 이슈를 해결하기 위해 새로운 Agent의 설계 및 구현을 도맡아 담당하여 해결한 경험이 있습니다.</p>

<p>리디로 이직한 이후에도 리디스토리라는 신규 서비스 팀 구축시에 초기 멤버로 팀 변경 제안을 받아 성공적으로 런칭 및 운영하였습니다. 이때 기존 template 기반의 프론트엔드 형태로 구성했다가 성능 문제로 SPA로 넘어가야 하는 상황이었습니다. 당시 팀에 SPA에 대한 경험을 한 인원이 없어 본인이 선행하여 React-Router를 이용해 SPA를 위한 기본 틀을 잡은 뒤에 코딩 가이드를 정리하여 팀 내에 공유하였습니다.</p>

<p>이후에도 새로운 프로젝트를 위한 언어 및 프레임워크로써 Kotlin과 Spring Boot가 고려되었을 때의 프로토타이핑도 크게 참여했으며, 개발 환경 및 배포 환경을 위해 Docker를 도입할 때에도 주도적으로 환경을 구성한 경험이 있습니다.</p>

<h3 id="어떤-프로그래밍-언어를-가장-좋아하시나요">어떤 프로그래밍 언어를 가장 좋아하시나요?</h3>

<blockquote>
  <p>다양한 언어에 익숙하고 한 언어로 세상 모든 일을 할 수 있는 것은 아니라고 생각한다.</p>
</blockquote>

<p>그때그때 해결하고자 하는 문제에 가장 적합한 언어를 사용하는 편이지만, 개인적인 선호도로는 python이나 javascript를 좋아합니다. 문법 등에 번잡스럽게 신경쓸 일이 적고 코어 로직에 좀 더 신경쓸 수 있기 때문입니다.</p>

<h3 id="페이스북과-동일한-서비스를-만든다면-어떤-스택으로-설계할-건지">페이스북과 동일한 서비스를 만든다면 어떤 스택으로 설계할 건지?</h3>

<p>예전에 트위터와 페이스북의 초기 아키텍처에 관련된 글을 본 적이 있습니다. 인상깊었던 부분은, 페이스북에서는 마치 게시판을 구현하듯이 모든 포스팅들을 하나의 저장소 공간에 나열하고 이를 조건절 쿼리를 이용해 나와 관련이 있는 게시물들을 필터링하여 타임라인을 만들고 최적화를 위해 cache를 활용하는 반면, 트위터는 게시물이 포스팅되면 해당 게시물은 별도의 저장소에 저장되고 해당 게시물의 대한 pk가 해당 게시물과 관련이 있는 사용자 별 타임라인 저장소에 각각 저장되는 방식을 취한다는 점이었습니다. 비유한다면 email과 비슷합니다.</p>

<p>이 두 아키텍처를 비교한다면 페이스북의 아키텍처는 쓰기 시점에는 빠르게 처리되나 읽기 시점에는 부하가 걸릴 수 있고 이를 cache로 처리하는 반면에, 트위터는 읽기 시점에는 별도의 조건절 쿼리를 이용할 필요없이 본인의 타임라인 저장소만 조회하면 되므로 빠르게 처리되는 반면 쓰기 시점에 부하가 걸린다는 점입니다.</p>

<p>따라서 상세 요구사항에 따라서 설계는 달라질 수 있겠지만 기본적인 아키텍처는 트위터의 아키텍처를 따라가는게 합리적이라고 생각합니다. 단, 쓰기 시점에 각 사용자의 타임라인 저장소에 게시물 pk이 배달되는 걸 게시자가 기다릴 필요는 없으므로 이 부분은 비동기로 이루어지도록 처리해야 합니다.</p>

<p>이 아키텍처를 구현하기 위해 사용할만한 솔루션으로는, 먼저 저장소 쪽에서는 데이터 디자인 상으로는 카산드라 같은 컬림 기반 데이터베이스가 가장 유리하나, 관리 포인트가 부담된다면 RDB로 처리하는 것이 유리해 보입니다. 스키마 구조는 하나의 행 별로 타임라인 소유자의 아이디와 게시물의 아이디, 그리고 정렬을 위해 게시 일자 컬럼을 가지도록 구성합니다.</p>

<p>그리고 성능 향상 및 DB 부하 감소를 위해 DB 앞단에 memcached 같은 cache를 하나 붙이도록 구성할 것 같습니다.</p>

<p>언어 및 프레임워크는 이러한 문제를 해결하기에 적합하다는 전제 하에 팀원 전체가 가장 손에 익은 것으로 선정하는 것이 가장 바람직해보입니다. 단, 이러한 부분을 신경쓰지 않아도 된다고 하면, 백엔드는 대부분 DB에 대한 CRUD를 수행하는 것이 대부분이기 때문에 그런 종류의 문제를 잘 해결할 수 있는 ORM이 잘 지원되는 Django나 Flask 같은 프레임워크를 사용할 것 같습니다.</p>

<h2 id="인성-부문-질문">인성 부문 질문</h2>

<h3 id="당신의-꿈은">당신의 꿈은?</h3>

<h3 id="왜-우리-회사에-오고-싶은지">왜 우리 회사에 오고 싶은지?</h3>

<h3 id="다른-사람은-당신을-어떤-사람이라고-생각">다른 사람은 당신을 어떤 사람이라고 생각?</h3>

<h3 id="왜-이직을-하려고-하나요">왜 이직을 하려고 하나요?</h3>

<p>솔직히 말씀드리면 이전 직장에서는 번아웃 현상이 좀 오는 것 같아서 개인적인 휴식기가 필요하다고 판단했습니다. 이전 직장에서는 퇴직이 아닌 휴직을 제의했으나 아무래도 심적으로 좀 지친 상태라 돌아올 시기를 정해놓고 쉬는 것이 큰 도움이 되지 않을 것 같다는 생각이 들었다. 또한 리디스토리 서비스가 종료되면서 새롭게 맡게 될 일이 내가 잘할 수 있는 일이 아니라는 생각이 들었다. 그 자리는 오히려 다른 분이 더 좋은 아웃풋을 내줄 수 있을 꺼라고 생각해서 퇴직했다.</p>

<h3 id="그-전-직장에서는-왜-이직을-했나요">그 전 직장에서는 왜 이직을 했나요?</h3>

<p>일단 이직을 떠올리게 된 첫번째 이유는, 계속 비슷하고 익숙한 업무를 반복하게 되다 보니 나중가서는 성장이 더디게 되는 느낌이 들어서 였습니다. 그래서 팀 이동이나 직무 변경도 고려를 했으나 당시 B2C 서비스에 직접 참여해보고 싶다는 생각이 들었습니다.</p>

<h3 id="왜-회사에서-당신을-고용해야-할까요">왜 회사에서 당신을 고용해야 할까요?</h3>

<p>실제 입사 이후에 어떤 일들을 구체적으로 하게 될 지, 귀사에서 어떤 시스템을 만들고 있는지는 정확히 모르겠지만, 채용 공고에 드러난 부분들이나 뉴스를 통해 노출된 내용들만 종합해서 보면 제가 가진 경력과 경험들이 분명 도움이 될 꺼라고 생각합니다.</p>

<p>예를 들어, 귀사에서 현재 사용중인 Node.js 뿐만 아니라 다양한 언어들을 그동한 경험해오면서 새로운 언어로 코드를 작성하는 것에 익숙해져 있습니다. 그리고 그런 언어들로 웹 백엔드를 구성하고 프론트엔드를 구성하는 것 또한 제가 경험했던 영역 중 하나입니다. 특히 프론트엔드에 대해서는 단순 웹 문서가 아니라 웹 애플리케이션에 속하는 프로덕트를 만든 경험이 있기 때문에 볼륨이 크고 복잡한 소스도 얼마든지 맡아서 작업을 할 수 있다고 생각합니다.</p>

<p>그 외에 이전 회사에서 서비스를 A부터 Z까지 만들면서 인프라 쪽 경험도 여러모로 하게 되었는데 이런 경험들도 도움이 될 꺼라고 생각합니다.</p>

<p>또한 로그 및 지표를 수집하고 저장하고 분석해서 시각화하는 종류의 시스템들에 그동안 관심이 많았고 실제로 이글루시큐리티에서 만들었던 프로그램도 그런 류이기 때문에 시너지를 낼 수 있는 부분이 있다고 생각합니다.</p>

<h3 id="우리-팀에-들어오면-무엇을-하고-싶습니까">우리 팀에 들어오면 무엇을 하고 싶습니까?</h3>

<p>팀의 미션을 해결하기 위해 멤버로써 노력하고 싶습니다.</p>

<h3 id="이-회사에서-일하고-싶은-이유를-말씀해주세요">이 회사에서 일하고 싶은 이유를 말씀해주세요.</h3>

<p>국내 최고의 기술 중심 회사, 기술에 목 맨 회사</p>

<p>대기업의 경직된 조직문화와 비교되는 주도적으로 업무를 수행할 수 있는 분위기</p>

<p>국내외의 최고의 전문가들이 사내에 많음</p>

<p>디테일을 중요하게 생각하는 회사</p>

<h3 id="단순하고-반복적인-업무를-한다면-어떻게-대응할-것인지">단순하고 반복적인 업무를 한다면 어떻게 대응할 것인지?</h3>

<p>단순 반복은 사람보다는 컴퓨터가 더 잘할 수 있는 일입니다. 따라서 사람이 계속해서 반복하는 부분을 컴퓨터로 자동화할 수 있는 부분을 찾아서 가능하다면 자동화가 가능하도록 구현을 하고 남는 시간에 다른 업무를 수행할 것 같습니다.</p>

<p>사례로는, 군대있을 때 사단 배차계원으로 일을 한 적이 있는데 배차계원의 업무라는 것도 하위부대의 배차현황을 취합하여 보고서를 만드는 단순 반복의 작업이었습니다. 이 단순 반복 업무를 자동화 하기 위해 엑셀에서 VBA를 이용하여 하위부대 배차현황을 자동으로 취합하는 시스템을 만들어 업무시간을 상당부분 줄인 경험이 있습니다.</p>

<p>또한 이전에 재직했던 이글루시큐리티에서도 개발자가 매번 단순한 코드를 수정해야 했던 로그 수집 Agent의 로직에 대해서도 많이 사용하는 패턴의 경우 개발자의 손을 직접 타지 않아도 되게끔 스크립트 자동 생성 기능을 구현한 바 있습니다.</p>

<h1 id="코딩-테스트">코딩 테스트</h1>

<h2 id="피보나치-수열-구현">피보나치 수열 구현</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fib</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">n</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<blockquote>
  <p>위의 코드는 n이 조그만 커져도 stack overflow가 일어날 수 있음. 이를 방지하기 위해서는 tail recursion 이 적용된 방식으로 재귀를 짜거나 혹은 반복문 형태로 구현할 수 있음.</p>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># iteration
</span><span class="k">def</span> <span class="nf">fib</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
  <span class="n">f1</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="n">f2</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="n">result</span> <span class="o">=</span> <span class="bp">None</span>
  
  <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>
  <span class="k">while</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">f1</span> <span class="o">+</span> <span class="n">f2</span>
    <span class="n">f1</span> <span class="o">=</span> <span class="n">f2</span>
    <span class="n">f2</span> <span class="o">=</span> <span class="n">result</span>
    <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>

  <span class="k">return</span> <span class="n">result</span>

<span class="c1"># tail recursion
</span><span class="k">def</span> <span class="nf">fib_tail</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">_fib</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">f1</span>
    <span class="k">return</span> <span class="n">_fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">f1</span> <span class="o">+</span> <span class="n">f2</span><span class="p">,</span> <span class="n">f1</span><span class="p">)</span>
</code></pre></div></div>

<blockquote>
  <p>단, tail recursion 은 언어단에서 지원해야 사용할 수 있다.</p>

  <p>재귀문을 사용해서 문제가 되는 경우는 계속해서 stack이 쌓이게 되는 부분이고, stack 이 쌓이게 되는 이유는 함수를 호출한 뒤에 도출된 결과값을 가지고 해야하는 후속작업이 남아있기 때문이다. 만일 tail recursion 에 대한 최적화를 언어단에서 지원한다면 함수를 호출한 뒤에 후속작업이 없는 경우에는 새롭게 stack을 쌓지 않고 현재의 stack을 새롭게 치환해서 사용하기 때문에 stack이 추가적으로 쌓이지 않는다.</p>
</blockquote>

<h2 id="단일-연결-리스트에서-맨-뒤에서-m번째-원소를-반환하는-함수를-구현">단일 연결 리스트에서 맨 뒤에서 m번째 원소를 반환하는 함수를 구현</h2>

<h2 id="문자열이-반복되지-않는-첫-번째-문자를-찾아내는-효율적인-함수">문자열이 반복되지 않는 첫 번째 문자를 찾아내는 효율적인 함수</h2>

<p>“total” → “o”</p>

<p>“teeter” → “r”</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">word</span><span class="p">):</span>
  <span class="n">counts</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)):</span>
    <span class="n">char</span> <span class="o">=</span> <span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">counts</span><span class="p">:</span>
      <span class="n">counts</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">counts</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
  
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)):</span>
    <span class="n">char</span> <span class="o">=</span> <span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">counts</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">char</span>
  
  <span class="k">return</span> <span class="bp">None</span>
</code></pre></div></div>

<h2 id="문자열에-들어있는-단어의-순서를-뒤집는-함수-작성">문자열에 들어있는 단어의 순서를 뒤집는 함수 작성</h2>

<p>“do or do not” → “not do or do”</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">sentence</span><span class="p">):</span>
  <span class="n">words</span> <span class="o">=</span> <span class="n">sentence</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)</span>
  <span class="n">words</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
  <span class="k">return</span> <span class="s">' '</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">words</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="두개의-문자열이-같은지를-검사하는-strcmp-함수-구현-같은-문자열이라면-0을-리턴">두개의 문자열이 같은지를 검사하는, strcmp() 함수 구현. 같은 문자열이라면 0을 리턴</h2>

<p>“abc”, “cbc” → 음수</p>

<p>“cbc”, “abc” → 양수</p>

<p>“abcde” → “abc” → 음수</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">word1</span><span class="p">,</span> <span class="n">word2</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">word1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">word2</span><span class="p">):</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
  
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">word1</span><span class="p">)):</span>
    <span class="k">if</span> <span class="n">word1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">word2</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
  
  <span class="k">return</span> <span class="mi">0</span>
</code></pre></div></div>

<h2 id="두-개의-스택으로-큐-구현">두 개의 스택으로 큐 구현</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Queue</span><span class="p">:</span>
  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">in_stack</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">out_stack</span> <span class="o">=</span> <span class="p">[]</span>
  
  <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">out_stack</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">in_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">out_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>
    
    <span class="bp">self</span><span class="o">.</span><span class="n">in_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
  
  <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">in_stack</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">out_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">in_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>
    
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
</code></pre></div></div>

<h2 id="linkedlist를-뒤집는-연산">LinkedList를 뒤집는 연산</h2>

<h2 id="이진검색트리-구현">이진검색트리 구현</h2>

<h1 id="면접관들의-마인드셋">면접관들의 마인드셋</h1>

<ul>
  <li>우리 회사의 업무를 받아들일 준비가 되어 있는가</li>
  <li>설령 회사에서 주로 사용하는 언어를 몰라도 배울 자세가 되어 있는가</li>
  <li>이미 구축된 회사 시스템에 적응할수 있는 사람인가</li>
  <li>연봉 이상의 잠재력을 지녔는가</li>
  <li>배우려는 사람인가, 일을 해서 이윤 창출에 도움이 될 만한 사람인가</li>
  <li>우리회사에 입사하고자 하는 의자가 강한가</li>
</ul>

<h1 id="지원자로써의-마인드셋">지원자로써의 마인드셋</h1>

<ul>
  <li>이러한 문제가 있었는데 이 문제는 왜 어려웠고 이렇게 해결하였더니 좋은 결과를 얻었다. (단순히 어려운 일을 했다보다 문제 해결 능력)</li>
</ul>

<h1 id="회사에-던질-질문들">회사에 던질 질문들</h1>

<ul>
  <li>내가 들어가면 어떤 직무를 맡게 되는지? 팀 구성은 어떻게 되는지?</li>
  <li>어떤 기술들을 사용하게 되는지?</li>
</ul>


<div class="explore">
    <div class="explore__devider">*****</div>
    <div class="explore__label">Explore the different categories</div>
    <ul class="categories">
        
            <li class="categories__item"><a href="/categories/troubleshoot">Troubleshoot</a></li>
        
            <li class="categories__item"><a href="/categories/daily">Daily</a></li>
        
            <li class="categories__item"><a href="/categories/tech">Tech</a></li>
        
            <li class="categories__item"><a href="/categories/trip">Trip</a></li>
        
		<li class="categories__item"><a href="/">All</a></li>
    </ul>
</div>


        </div>

        <script src="/assets/vendor/highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
        
    </body>
</html>